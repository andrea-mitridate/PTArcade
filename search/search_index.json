{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"contributing/","title":"Contributing","text":""},{"location":"outputs/","title":"Output","text":"<p>The structure of the PTArcade output is the following: <pre><code>out_dir/ # (1)!\n\u2514\u2500\u2500 name/ # (2)!\n\u2514\u2500\u2500 chain_0/\n        \u251c\u2500\u2500 chain_1.txt\n        \u251c\u2500\u2500 pars.txt\n        \u251c\u2500\u2500 priors.txt\n        \u2514\u2500\u2500 ...\n</code></pre></p> <ol> <li>By default, <code>out_dir = ./chains</code>. The user can specify a different  output directory via the configuration file.</li> <li>By default, <code>name=np_model</code>. The user can specify a different  name in the model file.</li> </ol> <p>The output generated by PTArcade matches that of ENTERPRISE and it includes, beyond the MC chains, a number of files which summarize key information on the run and the MC sampler. For our purposes, the most important files produced by PTArcade are:</p> <code>pars.txt</code> <p>This file contains the names of the model parameters. The order in  which the parameters appear in this file will also dictate the order  in which the parameters appear in the <code>chain_1.txt</code> file.</p> <p>When running with <code>mode=\"ceffyl\"</code>, the <code>pars.txt</code> file for the example model discussed in the introduction will read as follows: (1)</p> <ol> <li>When running with <code>mode = \"enterprise\"</code>, in addition to the user-specified parameters, <code>pars.txt</code> will also include intrinsic red noise parameters (two per pulsar) and, in the case of the IPTA dataset, DM parameters. </li> </ol> <p></p> <code>chain_1.txt</code> <p>This file contains the MC chains. It is formatted such that each line represents an MC sample and each column corresponds to a  parameter of our model. The ordering of the parameters, i.e., which  column is associated to each parameter, can be read out from the  <code>pars.txt</code> file. (1) </p> <ol> <li>Note that, when running with <code>mode = \"enterprise\"</code>, in addition to the user-specified parameters, the chains will also include intrinsic red noise parameters (two per pulsar) and, in the case of the IPTA dataset, DM parameters. </li> </ol> <p>In addition to the model parameters, the last four columns of each row  report the values of the posterior, the likelihood, the acceptance rate, and  an indicator variable for parallel tempering, which does not matter  in our case since PTArcade does not use parallel tempering.</p> <p>For the example model discussed in the introduction, the  output of a run in Ceffyl-mode will be: </p> <p></p> <p>Here, the first two columns give the values of \\(\\log_{10}A_*\\) and  \\(\\log_{10}(f_*/{\\textrm Hz})\\) while the remaining columns give the  value of the posterior, the likelihood, the acceptance rate, and the parallel-tempering indicator.</p> <code>priors.txt</code> <p>The prior file is similar to the <code>pars.txt</code> file, but, in addition to  the parameter names, it also includes their prior distributions. Here is an example for our test model, when running in Ceffyl-mode:</p> <p></p>"},{"location":"getting_started/","title":"Getting started","text":"<p>PTArcade streamlines the implementation of Bayesian inference analyses for PTA data by providing an easy-to-use wrapper of ENTERPRISE and Ceffyl.</p> <p>Already confused? Let's try to be more concrete. Say you have a new-physics model  that produces a gravitational-wave background with a relic abundance given by \\(\\Omega_{\\textrm{GW}}(f;\\,\\vec{\\theta})\\), where \\(\\vec{\\theta}\\) is a set of parameters describing the signal. You might now be interested in knowing if there are regions in  the \\(\\vec{\\theta}\\) parameter space that could reproduce the signal observed in PTA data.<sup>1</sup> PTArcade will allow you to answer this question in under 10 minutes (plus computational time) using real PTA data and the same statistical tools used by PTA collaborations.</p> <p>The only thing that is asked of the user is to define the GWB produced by their model  and the prior distribution of the model parameters. This is done via, what we call, a model file. Let's consider the specific example where</p> \\[ h^2\\Omega_{\\textrm{GW}}(f) = \\frac{A_*}{f/f_* + f_*/f}. \\] <p>In this case, the model file will look something like this</p> <pre><code>from ptarcade.models_utils import prior\nparameters = {# (1)! \n'log_A_star' : prior(\"Uniform\", -14, -6), # (4)! \n'log_f_star' : prior(\"Uniform\", -10, -6)\n}\ndef S(x):\nreturn 1 / (1/x + x)\ndef spectrum(f, log_A_star, log_f_star):  # (2)!\nA_star = 10**log_A_star\nf_star = 10**log_f_star\nreturn A_star * S(f/f_star) # (3)!\n</code></pre> <ol> <li> <p>The parameter priors are defined via a dictionary named <code>parameters</code>. The keys of this dictionary will be the names of the model parameters, and the values are parameter objects specifying the parameter prior distributions.</p> </li> <li> <p>The GWB spectrum is defined via the <code>spectrum</code> function. The first argument of this function has to be called <code>f</code> and is supposed to be an array of frequencies (in units of Hz) at which the spectrum will be evaluated. The remaining parameters should be named like the keys of the <code>parameters</code> dictionary. </p> </li> <li> <p>For any given set of new-physics parameters, in this example <code>log_A_star</code> and  <code>log_f_star</code>, the <code>spectrum</code> function should return an array which contains the value of  \\(h^2\\Omega_{\\textrm{GW}}\\) evaluated at those parameter values and at all the   frequencies contained in the <code>f</code> list.</p> </li> <li> <p>Use any prior from enterprise.signals.parameter or ptarcade.models_utils.</p> </li> </ol> <p>Once you have defined the model file, you can feed it to PTArcade by running it in a  terminal </p> <pre><code>ptarcade -m ./model_file.py # (1)!\n</code></pre> <ol> <li>The argument passed to the <code>-m</code> input flag should be the path to the model file.  Here, we are assuming that the model file is named <code>model_file.py</code> and is located in the folder from which we are running PTArcade. </li> </ol> <p>This will implement and run the analysis, whose results are Markov chains that can be used to derive posterior distributions for the parameters of our model. For the example that we are considering, this yields the result:</p> <p></p> <p><sub> The lower left panel shows the 68% and 95% levels of the 2D posterior distribution for the \\(\\log_{10}A_*\\) and \\(\\log_{10}(f/{\\rm Hz})\\) parameters. The  other two panels report 1D marginalized posterior distributions. The dashed vertical lines in the plots for the 1D distributions indicate the 68% credible intervals.</sub></p> <p>Deterministic signals</p> <p>PTArcade can also be used with deterministic signals. In this case, the user will have to specify the signal time series instead of the signal power-spectrum in the model file. See here for more details. </p> <p>The chains produced by PTArcade can also be used to derive excluded regions of the  parameter space and to perform model selection against the standard astrophysical interpretation of the PTA signal in terms of supermassive black-hole binaries.</p> <p>After this high-level summary of what PTArcade can do, in the next sections, we will discuss:</p> <ul> <li>How to install PTArcade (locally, or on a cluster)</li> <li>How to define a model file</li> <li>How to change the parameters of PTArcade runs (PTA dataset, number of MC points, ...) using a configuration file</li> <li>The structure of the PTArcade outptut</li> <li>PTArcade utilities that can help in constructing model files or  analyzing and plotting the MC chains.</li> </ul> <p>How to cite PTArcade</p> <p>If you use PTArcade in your work, please cite</p> <pre><code>@article{andrea mitridate_2023,\n    title={PTArcade},\n    DOI={10.5281/zenodo.7876430},\n    publisher={Zenodo},\n    author={Andrea Mitridate}, \n    year={2023}, \n    month={Apr},\n    copyright = {Open Access}}\n\n@article{Mitridate:2023oar,\n    author = {Mitridate, Andrea and Wright, David and von Eckardstein, Richard and Schr\\\"oder, Tobias and Nay, Jonathan and Olum, Ken and Schmitz, Kai and Trickle, Tanner},\n    title = \"{PTArcade}\",\n    eprint = \"2306.16377\",\n    archivePrefix = \"arXiv\",\n    primaryClass = \"hep-ph\",\n    month = \"6\",\n    year = \"2023\"}   \n</code></pre> <ol> <li> <p>See here for more details about the PTA signal.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting_started/hpc_install/","title":"Set up for HPC","text":""},{"location":"getting_started/hpc_install/#prerequisites","title":"Prerequisites","text":"<p><code>conda</code> likes to install its own version of MPI, which frequently causes issues on HPC clusters. To get around that, first, load your HPC's MPI module. Save the path to the <code>mpicc</code> executable in an environment variable. <pre><code>export MPICC=$(which mpicc)\n</code></pre></p>"},{"location":"getting_started/hpc_install/#install-the-code","title":"Install the Code","text":"<p>Now you can <code>pip</code> install as shown here</p>"},{"location":"getting_started/hpc_install/#singularity-container","title":"singularity Container","text":"<p>singularity is widely supported on HPC systems. Assuming you have a singularity module available to you, you can follow the instructions here</p>"},{"location":"getting_started/local_install/","title":"Installation","text":"<p>If you're familiar with Python, you can install PTArcade with <code>pip</code> or <code>conda</code>, the Python package manager. If not, we recommend using a <code>docker</code> or <code>singularity</code> virtual environment.</p>"},{"location":"getting_started/local_install/#with-pip","title":"With conda (recommended)","text":"<p>We are in the process of submitting PTArcade to the conda forge-channel, and soon you will be able to install PTArcade as a conda package. In the meantime,  you can install PTArcade using conda by downloading this environment file,  and typing in a terminal (1)</p> <ol> <li>See here for conda installation info.</li> </ol> <pre><code>conda env create -f ptarcade.yml # (1)!\n</code></pre> <ol> <li>Here we are assuming that the <code>yml</code> file is located in the current directory, otherwise you will have to specify the  path to the <code>yml</code> file when executing <code>conda env create</code>.</li> </ol> <p>This will install PTArcade and all the required dependencies in a conda environment named <code>ptarcade</code>, and download the following PTA datasets: NANOGrav 12.5-year, NANOGrav 15-year, and IPTA DR2.</p>"},{"location":"getting_started/local_install/#with-pip_1","title":"With pip","text":"<p>PTArcade is also published as a PyPI package and can be installed with <code>pip</code>, ideally by using a virtual environment. Open up a terminal  and install PTArcade with: <pre><code>pip install ptarcade # (1)!\n</code></pre></p> <ol> <li>We suggest to install PTArcade in a virtual environment. You can do     so by running     <pre><code>python3 -m venv &lt;path/to/env&gt;\nsource &lt;path/to/env&gt;/bin/activate\npython3 -m pip install ptarcade\n</code></pre></li> </ol> <p>This will automatically install compatible versions of all Python dependencies and, as  for the conda installation, download the following PTA datasets: NANOGrav 12.5-year, NANOGrav 15-year, and IPTA DR2.</p> <p>Non-Python Dependencies</p> <p>If you choose to install from PyPI, you'll need to get the non-Python dependencies yourself.</p> <ul> <li><code>libstempo</code> needs tempo2. You can install it by typing in a terminal <pre><code>curl -sSL https://raw.githubusercontent.com/vallis/libstempo/master/install_tempo2.sh | sh\n</code></pre></li> <li> <p><code>sckit-sparse</code> needs suitesparse.  You can install it by typing in a terminal </p> MacDebian <pre><code>brew install suite-sparse\n</code></pre> <pre><code>sudo apt-get install libsuitesparse-dev\n</code></pre> </li> <li> <p><code>mpi4py</code> needs an MPI implementation. You can install it by typing in a terminal </p> MacDebian <pre><code>brew install open-mpi\n</code></pre> <pre><code>sudo apt install libopenmpi-dev openmpi-bin\n</code></pre> </li> </ul>"},{"location":"getting_started/local_install/#with-docker","title":"With docker","text":"<p>The official Docker image is a great way to get up and running in a few minutes, as it comes with all dependencies pre-installed. Open up a terminal and pull the image with: <pre><code>docker pull ngnewphy/ptarcade:latest\n</code></pre></p>"},{"location":"getting_started/local_install/#with-singularity","title":"With singularity","text":"<p>A singularity environment with all the necessary dependencies already installed can be downloaded by typing  <pre><code>singularity pull ptarcade.sif docker://ngnewphy/ptarcade:latest\n</code></pre> This will create a Singularity image and save it as \\texttt{ptarcade.sif} in the current working directory.</p>"},{"location":"getting_started/run/","title":"Run PTArcade","text":""},{"location":"getting_started/run/#pip-and-conda","title":"pip and conda","text":"<p>If you have installed PTArcade with  <code>pip</code> or <code>conda</code>, open a terminal and  run PTArcade with  <pre><code>ptarcade -m ./model.py </code></pre> The argument passed to the <code>-m</code> input flag is the path to a  model file. In addition to a model file, the following  optional arguments can be passed to <code>ptarcade</code>:</p> <ul> <li> <p>A configuration file can be passed via the input flag <code>-c</code>. The configuration file allows to control several parameters of  the run, including the dataset to be analyzed, the number of MC trials, etc. More details on the model and configuration files can be found in the inputs section. </p> </li> <li> <p>A string to append to the output folder. By default, the chains will be saved in <code>./chains/np_model/chain_0</code>. Each of the  three elements of this path can be controlled by the user. <code>./chains</code> can be changed by using the <code>out_dir</code> parameter in the configuration  file, <code>np_model</code> can be changed via the <code>name</code> parameter in the  model file, and <code>chain_0</code> can be changed via the <code>-n</code> input flag passed  to <code>ptarcade</code>. The passed argument will be appended to <code>chain_</code>, so, if you want  to save the chains in a folder named <code>chain_42</code>, just pass the argument <code>-n 42</code>.  This can be useful if you are running multiple chains for the same model and  you want to save them in the same root folder. </p> </li> </ul>"},{"location":"getting_started/run/#using-a-docker-container","title":"Using a docker Container","text":"<p>The commands of the previous section must be slightly modified to run within a Docker container. Docker does not mount any directories into the container by default.  You must pass directories to mount inside the container using the syntax <code>-v &lt;source&gt;:&lt;destination&gt;</code>.  In the example below, we assume that the only directories you will pass to the command line options of PTArcade are accessible from your current working directory. <pre><code>docker run -v $(pwd):$(pwd) -w $(pwd) -i -t ptarcade -m ./model.py\n</code></pre></p> <ul> <li><code>-v</code> tells Docker what to mount from the host computer and where to mount it in the container. Here, we mount the current working directory of the host into the container using its full path.</li> <li><code>-w</code> sets the working directory of the container. In this case, it sets it to the current working directory that was just mounted.</li> <li><code>-i -t</code> keeps <code>STDIN</code> open and allocates a pseudo-TTY </li> </ul> <p>The PYArcade in the <code>docker run</code> command refers to the name of the Docker image. If you would like to run something else inside the container, then replace the PTArcade options with the program to run. For example, to run an interactive Bash shell</p> <pre><code>docker run -v $(pwd):$(pwd) -w $(pwd) -i -t ptarcade bash\n</code></pre>"},{"location":"getting_started/run/#using-a-singularity-container","title":"Using a singularity Container","text":"<p>As with Docker, the commands to run PTArcade must be slightly modified to run using Singularity. However, the commands are much simpler because Singularity will automatically mount your home directory inside the container. Using the <code>ptarcade.sif</code> file you created during the singularity installation, type into a terminal <pre><code>singularity run ptarcade.sif -m ./model.py\n</code></pre> You can also pass another command to run. For example, to start a Jupyter notebook type</p> <pre><code>singularity run ptarcade.sif jupyter notebook\n</code></pre> <p>If you want an interactive shell, run the following command</p> <pre><code>singularity shell ptarcade.sif\n</code></pre>"},{"location":"getting_started/trouble/","title":"Troubleshooting","text":""},{"location":"getting_started/trouble/#mpi4py-fails-to-install","title":"<code>mpi4py</code> Fails to Install","text":"<p>You most likely don't have an MPI implementation installed. Choose one that works on your system, probably OpenMPI or MPICH.</p>"},{"location":"getting_started/trouble/#libstempo-fails-to-install","title":"<code>libstempo</code> Fails to Install","text":"<p>If you are <code>pip</code> installing, check that you have installed <code>tempo2</code> as instructed here.</p>"},{"location":"getting_started/trouble/#scikit-sparse-fails-to-install","title":"<code>scikit-sparse</code> Fails to Install","text":"<p>If you are <code>pip</code> installing, check that you have installed <code>suitesparse</code> as instructed here.</p>"},{"location":"inputs/","title":"Inputs","text":"<p>When running PTArcade, the user can provide two input files:</p> <ul> <li> <p>Model file \u00b7  Required \u2013 This file, passed via the <code>-m</code> input flag, contains the definition of the new-physics signal. In the case of stochastic signals, this boils down to defining the GWB energy density per logarithmic frequency interval, \\(d\\rho_{\\textrm{GW}}/d\\ln f\\), as a fraction of the closure density:</p> \\[ h^2\\Omega_{\\textrm{GW}}(f;\\,\\vec{\\theta}) \\equiv \\frac{h^2}{\\rho_c}\\frac{d\\rho_{\\textrm{GW}}(f;\\,\\vec{\\theta})}{d\\ln f}\\,, \\] <p>where \\(\\vec{\\theta}\\) is the set of new-physics parameters describing the signals. In case of deterministic signals, the user should define the time series of induced timing delays, \\(s(t;\\,\\vec{\\theta})\\), in units of seconds.</p> </li> <li> <p>Configuration file \u00b7  Optional \u2013 In addition to the model file, the user can also pass a configuration file via the input flag <code>-c</code>. The configuration file is a simple Python file that allows the user to adjust several parameters of the run.</p> </li> </ul> <p>In the following, we will discuss the details of both these input files. </p>"},{"location":"inputs/config/","title":"Configuration file","text":"<p>The configuration file is a Python file that allows to adjust several  parameters of the run. The parameters that can be set in the configuration file are:</p> <code>pta_data</code> <p> Default: <code>'NG15'</code>\u2013  This variable needs to be assigned to a string specifying the PTA dataset which will be used in the analysis. The datasets currently implemented in PTArcade are NANOGrav 15-year (<code>pta_data = \"NG15\"</code>), NANOGrav 12.5-year (<code>pta_data = \"NG12\"</code>), and IPTA DR2 (<code>pta_data = \"IPTA2\"</code>).</p> <code>N_samples</code> <p> Default: <code>int(2e6)</code> \u2013  This variable can be assigned to an integer specifying the number of points that will be generated by the Monte Carlo sampler.</p> <p>Thinning</p> <p>In order to reduce the autocorrelation length, the MC chains are automatically thinned by a factor of 10. Therefore, the number of MC samples that will be  saved is given by <code>N_samples</code>/10.</p> <code>mode</code> <p> Default: <code>ceffyl</code> \u2013  PTArcade can be run in two modes: </p> <ul> <li> <p><code>mode = \"enterprise\"</code>: In this configuration, the code will analyze the full PTA dataset in the time domain by using the numerical techniques implemented in  ENTERPRISE.</p> </li> <li> <p><code>mode = \"ceffyl\"</code>: In this configuration, the code will analyze PTA data at the level of the Bayesian peridograms (1), and fit the user-specified signal to these periodograms using the numerical techniques implemented in Ceffyl.</p> <ol> <li>Probability density reconstructions of the pulsar-timing-residual  power-spectral-density at each frequency (commonly referred to as the \"violin plot\"). See here for more details.</li> </ol> </li> </ul> <p>Ceffyl and Deterministic Signals</p> <p>The Ceffyl mode can only be used to analyze stochastic signals. If your  signal is deterministic, you have to run the code in ENTERPRISE-mode. </p> Additional Citations <p>If you use PTArcade in ENTERPRISE-mode, please add the following  citations:</p> <pre><code>@misc{enterprise,\n    author       = {Justin A. Ellis and Michele Vallisneri and Stephen R. Taylor and Paul T. Baker},\n    title        = {ENTERPRISE: Enhanced Numerical Toolbox Enabling a Robust PulsaR Inference SuitE},\n    month        = sep,\n    year         = 2020,\n    howpublished = {Zenodo},\n    doi          = {10.5281/zenodo.4059815},\n    url          = {https://doi.org/10.5281/zenodo.4059815}\n    }\n\n@misc{enterprise-ext,\n    author       = {Stephen R. Taylor and Paul T. Baker and Jeffrey S. Hazboun and Joseph Simon and Sarah J. Vigeland},\n    title        = {enterprise_extensions},\n    year         = {2021},\n    url          = {https://github.com/nanograv/enterprise_extensions},\n    note         = {v2.3.3}\n    }\n</code></pre> <p>If you use PTArcade in Ceffyl mode, please cite</p> <pre><code>@misc{lamb2023need,\n    title={The Need For Speed: Rapid Refitting Techniques for Bayesian Spectral Characterization of the Gravitational Wave Background Using PTAs}, \n    author={William G. Lamb and Stephen R. Taylor and Rutger van Haasteren},\n    year={2023},\n    eprint={2303.15442},\n    archivePrefix={arXiv},\n    primaryClass={astro-ph.HE}\n    }\n</code></pre> <code>out_dir</code> <p> Default: <code>'./chains/'</code> \u2013 This variable can be assigned to a string to specify the output directory.</p> <code>resume</code> <p> Default: <code>False</code> \u2013 If <code>resume = True</code>, the code will look for MCMC chains in the output directory and, if it finds any, it will restart sampling from those instead of starting from scratch. If <code>resume = True</code>, but no chains are found in the output  directory, the sampler will start from scratch.</p> <p>Warning</p> <p>If <code>resume = False</code> (which is the default value), any chain that is present in the output  directory at the start of your run will be overwritten. </p> <code>mod_sel</code> <p> Default: <code>False</code> \u2013 PTArcade can also be used to compare new-physics interpretations of PTA signals  against the astrophysical interpretation in terms of SMBHBs. If <code>mod_sel = True</code>,  a model-indexing variable controlling which model likelihood is active at each MCMC iteration will be sampled along with the parameters of the competing model. This will then allow to derive the Bayes factor between models by simply taking the ratio of samples spent in each bin of the model-indexing variable.</p> <p>Get the Bayes factor</p> <p>After running with <code>mod_sel = True</code>, you can easily derive the Bayes factor  using the function <code>get_bf</code> defined in the  PTArcade <code>chains_utils</code> module.</p> <p>Mod sel and Ceffyl</p> <p>At the moment <code>mod_sel</code> can only be used with <code>mode=\"enterprise\"</code>. We are currently  working on adding the <code>mod_sel</code> option to the Ceffyl-mode. </p> <code>corr</code> <p> Default: <code>False</code> \u2013 This parameter controls the inter-pulsar correlations for any user-specified stochastic signal. If <code>corr=False</code>, spatial correlations between pulsars are set to zero and the  overlap reduction function is taken to be a delta function in the pulsar space. If <code>corr=True</code>, Hellings &amp; Downs correlations are assumed..</p> <p>Running time</p> <p>When <code>mode = \"enterprise\"</code>, running with <code>corr = True</code> is approximately one order of magnitude slower than running with <code>corr = False</code>. If you want to run with  <code>corr = True</code>, we suggest either using <code>mode = \"ceffyl\"</code> or running the code on a cluster.</p> <code>red_components</code> <p> Default: <code>30</code> \u2013 This variable can be assigned to an integer specifying the number of frequency components that will be used to model intrinsic red noise. (1)</p> <ol> <li>Intrinsic red noise is modeled using a Fourier basis of frequencies \\(i/T_{\\textrm{obs}}\\), where \\(i\\) indexes the harmonics of the basis and \\(T_{\\textrm{obs}}\\) is the timing baseline. The  <code>red_components</code> parameter sets the harmonics at which this expansion is truncated.</li> </ol> <code>gwb_components</code> <p> Default: <code>14</code> \u2013 This variable can be assigned to an integer specifying the number of frequency components that will be used to model common red noise. (1) </p> <ol> <li>The common red noise produced induced by a GWB is modeled using a Fourier basis of frequencies \\(i/T_{\\textrm{obs}}\\), where \\(i\\) indexes the harmonics of the basis and \\(T_{\\textrm{obs}}\\) is the timing baseline. The <code>gwb_components</code> parameter sets the harmonics at which this expansion is truncated.</li> </ol> <p>Suggested Number of GWB Components</p> IPTA2NG12NG15 <p>We suggest using <code>gwb_components = 13</code>. </p> <p>We suggest using <code>gwb_components = 5</code>.</p> <p>We suggest using <code>gwb_components = 14</code>.</p> <p>As we already mentioned, the GWB signal specified by the user can be superimposed with the signal from SMBHBs or compared to it. The GWB signal from SMBHBs is modeled as  a power-law:</p> \\[ h^2\\Omega_{\\textrm{GW}}(f) = \\frac{2 \\pi^2 A_{\\textrm{BHB}}^2}{3 H_0^2} \\left(\\frac{f}{\\textrm{year}^{-1}}\\right)^{5-\\gamma_{\\textrm{BHB}}}\\textrm{year}^{-2}. \\] <p>The prior distributions for \\(A_{\\textrm{BHB}}\\) and \\(\\gamma_{\\textrm{BHB}}\\) can be controlled with the following parameters in the configuration file:</p> <code>bhb_th_prior</code> <p> Default: <code>True</code> \u2013 If <code>bhb_th_prior = True</code>, the prior for the SMBHB signal parameters will be chosen to  reflect predictions from astrophysical models. This is only relevant if you have selected <code>smbhb = True</code> in the model file or  <code>mod_sel = True</code> in the configuration file. (1)</p> <ol> <li>For more information on the astrophysical models used to derived these priors, see      here and here</li> </ol> <code>A_bhb_logmin</code> <p> Default: <code>-18</code> \u2013 Can be assigned to a floating point or integer number to set the lower bound of the log-uniform prior for the SMBHB-signal amplitude. This is only relevant if <code>bhb_th_prior = False</code> and you have selected <code>smbhb = True</code> in the model file or <code>mod_sel = True</code> in the configuration file.</p> <code>A_bhb_logmax</code> <p> Default: <code>-14</code> \u2013 Can be assigned to a floating point or integer number to set the upper bound of the log-uniform prior for the SMBHB-signal amplitude. This is only relevant if <code>bhb_th_prior = False</code> and you have selected <code>smbhb = True</code> in the model file or <code>mod_sel = True</code> in the configuration file.</p> <code>gamma_bhb</code> <p> Default: <code>None</code> \u2013 Can be assigned to a floating point or integer number to set the value of \\(\\gamma_{\\textrm{BHB}}\\). If <code>gamma_bhb = None</code>, a uniform prior between \\(0\\) and \\(7\\) will be used instead.</p> <p>Default Configuration File</p> <p>If no configuration file is specified by the user, the following file will be  used instead</p> <pre><code>pta_data = 'NG15'\nmode = 'ceffyl'\nmod_sel = False\nout_dir = './chains/'\nresume = False \nN_samples = int(2e6) \n# intrinsic red noises parameters\nred_components = 14 \n# bhbh signal parameters\ncorr = False \ngwb_components = 14 \nbhb_th_prior = True \n</code></pre>"},{"location":"inputs/model/","title":"Model file","text":"<p>The model file is a simple Python file that, at minimum, needs to contain the following information:</p> <ul> <li>Names and prior distributions of the signal parameters.</li> <li>Parametrized form of the signal, which can either be stochastic     (and parametrized via its power-spectrum), or deterministic (and parametrized     as a times eries).</li> </ul> <p>In the following, we will explain how these two quantities are defined in the model file. </p>"},{"location":"inputs/model/#priors","title":"Priors","text":"<p>The priors for the signal parameters are defined via the <code>parameters</code> dictionary. The keys of this dictionary must be strings, which will be used as names for the model parameters. The values of this dictionary are ENTERPRISE Parameter objects, the user can create these object via the <code>prior</code> helper function that can be imported from the ptarcade.models_utils module. The first argument that the user needs to pass to the <code>prior</code> function is a string with the name of the prior class they want to use for that parameter, the remaining arguments are used to set the attributes of the prior. By default, parameters are assumed to be common across all pulsars. If the user wants to define a pulsar-dependent parameter, this can be done by passing <code>common=False</code> as a keyword argument.</p> Priors Example <p>The <code>parameters</code> dictionary of a model described by the parameters \\(a\\) and \\(b\\), which are common among all the pulsars, will look as follows for different choices of the priors:</p> Uniform Priors1D Normal Priors2D Normal PriorsExponential Priors <pre><code>parameters = {'a' : prior(\"Uniform\", 0, 1), 'b' : prior(\"Uniform\", 0, 1)} # (1)!\n</code></pre> <ol> <li>In this case, we have chosen uniform priors in the range [0,1] for both     parameters.</li> </ol> <pre><code>parameters = {'a' : prior(\"Normal\", mu=1, sigma=1), 'b' : prior(\"Normal\", 1, 1)} # (1)!\n</code></pre> <ol> <li>In this case, we have chosen 1D normal priors with unit mean and variance for     both parameters.</li> </ol> <pre><code>mu = [1, 1]\ncov = [[1, 0.1],[0.1, 1]]\nparameters = {'a_b' : prior(\"Normal\", mu, cov, size=2)} # (1)!\n</code></pre> <ol> <li>In this case, we have chosen a joint 2D normal prior for the model parameters, which are grouped in a single two dimensional parameter called <code>a_b</code>.</li> </ol> <pre><code>parameters = {'a' : prior(\"LinearExp\", 1, 1), 'b' : prior(\"LinearExp\", 1, 1)} # (1)!\n</code></pre> <ol> <li>In this case, we have assumed </li> </ol> Constructing Priors <p>Notice, how we used both positional and keyword arguments: Both are allowed. These arguments correspond to the functions defined in either enterprise.signals.parameter or ptarcade.models_utils. Below are links to all supported parameters:</p> <ul> <li>enterprise.signals.parameter.Normal </li> <li>enterprise.signals.parameter.Uniform </li> <li>enterprise.signals.parameter.TruncNormal </li> <li>enterprise.signals.parameter.LinearExp </li> <li>enterprise.signals.parameter.Constant </li> <li>ptarcade.models_utils.Gamma.</li> </ul> Common Parameters vs. Pulsar-Dependent <p>Parameters are assumed to be common by default. If they are pulsar-dependent, you must pass <code>common=False</code> as a keyword argument to <code>prior</code>.  For example, if we want to set the <code>b</code> parameters of previous examples to be pulsar-dependent, we can do that as follows </p> <pre><code>parameters = {'a' : prior(\"Uniform\", 0, 1), 'b' : prior(\"Uniform\", 0, 1, common=False)} # (1)!\n</code></pre> <ol> <li>In this example, <code>b</code> is a pulsar-dependent parameter. By default, the parameters are common to all pulsars in the PTA.</li> </ol>"},{"location":"inputs/model/#stochastic-signals","title":"Stochastic Signals","text":"<p>Stochastic signals are defined via the <code>spectrum</code> function. The first parameter of this function should be named <code>f</code> and it is supposed to be a NumPy array containing the frequencies (in units of Hz) at which the spectrum will be evaluated. The names of the remaining parameters should match the keys of the <code>parameters</code> dictionary. The <code>spectrum</code> function should return a NumPy array containing the value of \\(h^2\\Omega_{\\mathrm{GW}}\\) at each of the frequencies in <code>f</code>.</p> Stochastic Signal Example <p>The <code>spectrum</code> function for a model with </p> \\[ h^2\\Omega_{\\rm GW}(f) = \\frac{a}{1+b/f} \\] <p>is given by</p> <pre><code>def spectrum(f, a, b):\nreturn a * 1 / (1 + b/f)\n</code></pre>"},{"location":"inputs/model/#+model.deterministic","title":"Deterministic Signals","text":"<p>Deterministic signals are defined via the <code>signal</code> function. The first parameter of this function should be named <code>toas</code> and it is supposed to be a NumPy array containing the times of arrival (TOAs) (in units of seconds) at which the deterministic signal will be evaluated. The name of the remaining parameters should match the keys of the <code>parameters</code> dictionary. The <code>signal</code> function should return a NumPy array with the same dimensions as <code>toas</code> containing the value of the induced shift for each TOA contained in <code>toas</code>.</p> Deterministic Signal Example <p>For a deterministic signal,</p> \\[ s(t) = a\\sin(b t), \\] <p>the <code>signal</code> is given by</p> <pre><code>def signal(toas, a, b):\nreturn a * numpy.sin(b * toas)\n</code></pre> Model File Example StochasticDeterministic <p>This is a model file for a stochastic signal with a broken power-law spectrum,</p> \\[ h^2\\Omega_{\\rm GW}(f) = A_* \\frac{f/f_*}{1+f^2/f_*^2}, \\] <p>whose parameters, \\(A_*\\) and \\(f_*\\), are assumed to have a log-uniform prior between \\([10^{-14},10^{-6}]\\) and \\([10^{-10},10^{-6}]\\), respectively.</p> <pre><code>from ptarcade.models_utils import prior\nparameters = {\n'log_A_star' : prior(\"Uniform\", -14, -6),\n'log_f_star' : prior(\"Uniform\", -10, -6)\n}\ndef S(x):\nreturn x / (1 + x**2)\ndef spectrum(f, log_A_star, log_f_star):\nA_star = 10**log_A_star\nf_star = 10**log_f_star\nreturn A_star * S(f/f_star)\n</code></pre> <p>This is a model file for a deterministic signal given by </p> \\[ s(t) = A\\sin(k t), \\] <p>and assuming log-uniform priors between \\([10^{-14},10^{-6}]\\) and \\([10^{-10},10^{-6}]\\) for the two model parameters \\(A\\) and \\(k\\), respectively. </p> <pre><code>import numpy\nfrom ptarcade.models_utils import prior\nparameters = {\n'log_A' : prior(\"Uniform\", -14, -6),\n'log_k' : prior(\"Uniform\", -10, -6)\n}\ndef signal(toas, log_A, log_k):\nA = 10**log_A\nk= 10**log_k\nreturn A *  numpy.sin(k * toas)\n</code></pre> <p>Model File Flexibility</p> <p>In defining the <code>spectrum</code> or <code>signal</code> functions in the model file, you have all the  flexibility of a normal Python file. You can, for example, define auxiliary functions, import and interpolate tabulated data etc.</p>"},{"location":"inputs/model/#additional-settings","title":"Additional Settings","text":"<p>The model file can also contain additional (optional) variables that can be used to control the new-physics signal in more detail. Specifically, you can control the following:</p> <code>name</code> <p> Default: <code>\"np_model\"</code> \u2013  This variable can be assigned to a string to specify the model name. This will be used to name the output directory.</p> <code>smbhb</code> <p> Default: <code>False</code> \u2013  If set to <code>True</code>, the expected signal from SMBHBs will be added to the user-specified signal.</p> <p>NG15 Model Files</p> <p>The model files used in the NANOGrav 15-year new-physics search can be found here.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>ptarcade<ul> <li>chains_utils</li> <li>data<ul> <li>default_config</li> </ul> </li> <li>fast_interpolate</li> <li>input_handler</li> <li>models_utils</li> <li>plot_utils</li> <li>pta_importer</li> <li>sampler</li> <li>signal_builder</li> </ul> </li> </ul>"},{"location":"reference/ptarcade/__init__/","title":"init","text":""},{"location":"reference/ptarcade/__init__/#ptarcade-attributes","title":"Attributes","text":""},{"location":"reference/ptarcade/__init__/#ptarcade.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = version('ptarcade')\n</code></pre> <p>Get version from pyproject.toml metadata.</p>"},{"location":"reference/ptarcade/chains_utils/","title":"chains_utils","text":"<p>Utilities to be used with output MCMC chains of PTArcade.</p>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils-functions","title":"Functions","text":""},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.params_loader","title":"params_loader","text":"<pre><code>params_loader(\nfile: str | Path,\n) -&gt; dict[str, tuple[float, float] | None]\n</code></pre> <p>Load a parameter file and return a dictionary of the parameters with their respective values or None.</p> PARAMETER DESCRIPTION <code>file</code> <p>The path to the prior.txt file.</p> <p> TYPE: <code>str | Path</code> </p> RETURNS DESCRIPTION <code>params</code> <p>A dictionary with the parameters' prior ranges.</p> <p> TYPE: <code>dict[str, tuple[float, float] | None]</code> </p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def params_loader(file: str | Path) -&gt; dict[str, tuple[float, float] | None]:\n\"\"\"Load a parameter file and return a dictionary of the parameters with their respective values or None.\n    Parameters\n    ----------\n    file : str | Path\n        The path to the prior.txt file.\n    Returns\n    -------\n    params : dict[str, tuple[float, float] | None]\n        A dictionary with the parameters' prior ranges.\n    \"\"\"\nparams = {}\nwith open(file) as f:\nfor line in f:\nif ':' not in line:\ncontinue\nkey = line.split(\":\")[0]\nif \"Uniform\" in line:\nminimum = float(re.search('pmin=(.*?),', line).group(1)) # type: ignore\nmaximum = float(re.search('pmax=(.*?)\\\\)', line).group(1)) # type: ignore\nparams[key] = (minimum, maximum)\nelif \"Normal\" in line:\ndim = len(re.search('\\\\[(.*?)\\\\]', line).group(1).split()) # type: ignore\nfor i in range(dim):\nparams[f\"{key}_{i}\"] = None # type: ignore\nelse:\nparams[key] = None # type: ignore\nreturn params # type: ignore\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.convert_chains_to_hdf","title":"convert_chains_to_hdf","text":"<pre><code>convert_chains_to_hdf(\nchains_dir: str | Path,\nburn_frac: float = 0.0,\nquick_import: bool = False,\nchain_name: str = \"chain_1.txt\",\ndest_path: Path | None = None,\n**kwargs: Path | None\n) -&gt; None\n</code></pre> <p>Convert the raw output of PTArcade to HDF format and write to disk.</p> PARAMETER DESCRIPTION <code>chains_dir</code> <p>Name of the directory containing the chains.</p> <p> TYPE: <code>str | Path</code> </p> <code>burn_frac</code> <p>Fraction of the chain that is removed from the head (default is 0).</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>0.0</code> </p> <code>quick_import</code> <p>Flag to skip importing the rednoise portion of chains (default is False).</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>False</code> </p> <code>chain_name</code> <p>The name of the chain files, include the file extension of the chain files. Compressed files with extension \".gz\" can be used (default is \"chain_1.txt\").</p> <p> TYPE: <code>str, optional</code> DEFAULT: <code>'chain_1.txt'</code> </p> <code>dest_path</code> <p>The destination path including filename (default is to save in chains_dir with a unique timestamp).</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional arguments passed to pandas.DataFrame.to_hdf</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Saves an HDF5 file to <code>dest_path</code> in \"table\" format. There is one group for each chain (\"chain_N\"), with a \"table\" dataset in each group that contains the MCMC samples. There is also a single group for parameters called \"parameters\", also with a dataset called \"table\".</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def convert_chains_to_hdf(\nchains_dir: str | Path,\nburn_frac: float = 0.0,\nquick_import: bool = False,  # noqa: FBT001, FBT002\nchain_name: str = \"chain_1.txt\",\ndest_path: Path | None = None,\n**kwargs,\n) -&gt; None:\n\"\"\"Convert the raw output of PTArcade to HDF format and write to disk.\n    Parameters\n    ----------\n    chains_dir : str | Path\n        Name of the directory containing the chains.\n    burn_frac : float, optional\n        Fraction of the chain that is removed from the head (default is 0).\n    quick_import : bool, optional\n        Flag to skip importing the rednoise portion of chains (default is False).\n    chain_name : str, optional\n        The name of the chain files, include the file extension of the chain files.\n        Compressed files with extension \".gz\" can be used (default is \"chain_1.txt\").\n    dest_path : Path | None\n        The destination path including filename (default is to save\n        in chains_dir with a unique timestamp).\n    **kwargs : dict\n        Additional arguments passed to [pandas.DataFrame.to_hdf][]\n    Returns\n    -------\n    None\n        Saves an HDF5 file to `dest_path` in \"table\" format. There is one group for each\n        chain (\"chain_N\"), with a \"table\" dataset in each group that contains the\n        MCMC samples. There is also a single group for parameters called \"parameters\",\n        also with a dataset called \"table\".\n    \"\"\"\nif isinstance(chains_dir, str):\nchains_dir = Path(chains_dir)\nuse_index = kwargs.pop(\"index\", False)\ncomplevel = kwargs.pop(\"complevel\", 9)\ncomplib = kwargs.pop(\"complib\", \"blosc:lz4\")\nif dest_path is None:\ndest_path = (\nchains_dir / f\"chains-{chains_dir.name}-{dt.now().strftime('%Y%m%d_%H%M%S')}\").with_suffix( # noqa: DTZ005\n\".h5\",\n)\nparams, dataframes = import_to_dataframe(chains_dir, burn_frac, quick_import, chain_name, merge_chains=False)\nfor num, frame in enumerate(dataframes):\nframe.to_hdf(dest_path, key=f\"chain_{num}\", index=use_index, complevel=complevel, complib=complib, **kwargs)\nparams.to_hdf(dest_path, key=\"parameters\", index=use_index, complevel=complevel, complib=complib, **kwargs)\nprint(f\"Successfully converted to HDF. Saved at {dest_path}.\")\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.import_to_dataframe","title":"import_to_dataframe","text":"<pre><code>import_to_dataframe(\nchains_dir: str | Path,\nburn_frac: float = 0.0,\nquick_import: bool = False,\nchain_name: str = \"chain_1.txt\",\nmerge_chains: bool = True,\n) -&gt; tuple[pd.DataFrame, pd.DataFrame]\n</code></pre> <p>Import the chains and their parameter file as a pandas dataframe.</p> <p>Given a <code>chain_dir</code> that contains chains, this function imports the chains, removes <code>burn_frac</code>, and returns a dictionary of parameters: values and a numpy array of the merged chains.</p> PARAMETER DESCRIPTION <code>chains_dir</code> <p>Name of the directory containing the chains.</p> <p> TYPE: <code>str | Path</code> </p> <code>burn_frac</code> <p>Fraction of the chain that is removed from the head (default is 0).</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>0.0</code> </p> <code>quick_import</code> <p>Flag to skip importing the rednoise portion of chains (default is False).</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>False</code> </p> <code>chain_name</code> <p>The name of the chain files, include the file extension of the chain files. Compressed files with extension \".gz\" and HDF5 files with extension \".h5\" can be used (default is \"chain_1.txt\").</p> <p> TYPE: <code>str, optional</code> DEFAULT: <code>'chain_1.txt'</code> </p> <code>merge_chains</code> <p>Whether to merge the chains into one dataframe (default is True).</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>params</code> <p>Dataframe containing the parameter names and their values.</p> <p> TYPE: <code>pandas.DataFrame</code> </p> <code>chains</code> <p>Dataframe array containing the merged chains without the burn-in region. Can also optionally return a list of unmerged chains if <code>merg_chains</code> is False.</p> <p> TYPE: <code>pandas.DataFrame | list[pandas.DataFrame]</code> </p> RAISES DESCRIPTION <code>SystemExit</code> <p>Raised when the chains have different parameters.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def import_to_dataframe(\nchains_dir: str | Path,\nburn_frac: float = 0.0,\nquick_import: bool = False,  # noqa: FBT001, FBT002\nchain_name: str = \"chain_1.txt\",\nmerge_chains: bool = True, # noqa: FBT001, FBT002\n) -&gt; tuple[pd.DataFrame, pd.DataFrame]:\n\"\"\"Import the chains and their parameter file as a pandas dataframe.\n    Given a `chain_dir` that contains chains, this function imports the chains, removes `burn_frac`, and returns\n    a dictionary of parameters: values and a numpy array of the merged chains.\n    Parameters\n    ----------\n    chains_dir : str | Path\n        Name of the directory containing the chains.\n    burn_frac : float, optional\n        Fraction of the chain that is removed from the head (default is 0).\n    quick_import : bool, optional\n        Flag to skip importing the rednoise portion of chains (default is False).\n    chain_name : str, optional\n        The name of the chain files, include the file extension of the chain files. Compressed files\n        with extension \".gz\" and HDF5 files with extension \".h5\" can be used (default is \"chain_1.txt\").\n    merge_chains : bool, optional\n        Whether to merge the chains into one dataframe (default is True).\n    Returns\n    -------\n    params : pandas.DataFrame\n        Dataframe containing the parameter names and their values.\n    chains : pandas.DataFrame | list[pandas.DataFrame]\n        Dataframe array containing the merged chains without the burn-in region. Can also optionally\n        return a list of unmerged chains if `merg_chains` is False.\n    Raises\n    ------\n    SystemExit\n        Raised when the chains have different parameters.\n    \"\"\"\nprint(\"Starting import from\", chains_dir)\nstart_time = time.time()\nif isinstance(chains_dir, str):\nchains_dir = Path(chains_dir)\nchain_ext = Path(chain_name).suffix\nif chain_ext == \".txt\" or chain_ext == \".gz\":\n# get all the chain directories\ndirectories = [x for x in chains_dir.iterdir()\nif x.is_dir()]\n# get the parameter lits and check that all the chains have the same parameters\nparams = params_loader(directories[0] / \"priors.txt\")\nfor chain in directories:\ntemp_par = params_loader(chain / \"priors.txt\")\nif temp_par != params:\nerr = f\"Chains have different parameters. {temp_par=} != {params=}\"\nlog.error(err)\nraise SystemExit\nn_pars = len(np.loadtxt(directories[0] / \"chain_1.txt\", max_rows=1))\n# add name for sampler parameters\nif n_pars - len(params) == 5:\nparams.update(\n{\n\"nmodel\": None,\n\"log_posterior\": None,\n\"log_likelihood\": None,\n\"acceptance_rate\": None,\n\"n_parall\": None,\n},\n)\nelif n_pars - len(params) == 4:\nparams.update({\"log_posterior\": None, \"log_likelihood\": None, \"acceptance_rate\": None, \"n_parall\": None})\n# import and merge all the chains removing the burn-in\nname_list = list(params.keys())\nred_noise_filter = re.compile(\".*red_noise.*\")\nif quick_import and any(filter(red_noise_filter.match, name_list)): # type: ignore\n# Search reversed list for first occurence of \"red_noise\"\n# Return the index (remember, the list is reversed!)\n# The use of `next` and a generator makes it so that we don't have to\n# search the whole list, we stop when we get the first match\nred_noise_ind = next(i for i in enumerate(name_list[::-1]) if \"red_noise\" in i[1])[0]\n# Slice the list so that we begin directly after the index found above\nusecols = name_list[-1 * red_noise_ind :]\nparams = {name: params[name] for name in usecols}\nelse:\nusecols = name_list\ndtypes = {name: float for name in usecols}\n# import and merge all the chains removing the burn-in\nif merge_chains:\nchains = pd.concat(\n(\npd.read_csv(\n(drct / chain_name),\nsep=\"\\t\",\nnames=name_list,\ndtype=dtypes,\nusecols=usecols,\n).iloc[lambda x: int(len(x) * burn_frac) &lt;= x.index]\nfor drct in directories\n),\nignore_index=True,\nsort=False,\n)\nchains = chains.dropna()\nelse:\nchains = [\npd.read_csv(\n(drct / chain_name),\nsep=\"\\t\",\nnames=name_list,\ndtype=dtypes,\nusecols=usecols,\n).iloc[lambda x: int(len(x) * burn_frac) &lt;= x.index]\nfor drct in directories\n]\nparams = pd.DataFrame.from_dict(params).fillna(np.nan)  # need to fill `None` with a numeric value\nelif chain_ext == \".h5\":\nwith pd.HDFStore(chains_dir / chain_name) as h5:\nkeys = h5.keys()\nchain_keys = [key for key in keys if \"chain\" in key]\nparams = h5.get(\"/parameters\")\nchains = pd.concat(\n[\npd.read_hdf(h5, key=chain_key).iloc[lambda x: int(len(x) * burn_frac) &lt;= x.index]\nfor chain_key in chain_keys\n],\nignore_index=True,\nsort=False,\n)\nchains = chains.dropna()\nprint(f\"Finished importing   {chains_dir} in {time.time() - start_time:.2f}s\")\nreturn params, chains\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.import_chains","title":"import_chains","text":"<pre><code>import_chains(\nchains_dir: str | Path,\nburn_frac: float = 1 / 4,\nquick_import: bool = True,\nchain_name: str = \"chain_1.txt\",\n) -&gt; tuple[dict, NDArray]\n</code></pre> <p>Import the chains and their parameter file.</p> <p>Given a <code>chain_dir</code> that contains chains, this function imports the chains, removes <code>burn_frac</code>, and returns a dictionary of parameters: values and a numpy array of the merged chains.</p> PARAMETER DESCRIPTION <code>chains_dir</code> <p>Name of the directory containing the chains.</p> <p> TYPE: <code>str | Path</code> </p> <code>burn_frac</code> <p>Fraction of the chain that is removed from the head (default is \u00bc).</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>1 / 4</code> </p> <code>quick_import</code> <p>Flag to skip importing the rednoise portion of chains (default is True).</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>True</code> </p> <code>chain_name</code> <p>The name of the chain files, include the file extension of the chain files. Compressed files with extension \".gz\" and HDF5 files with extension \".h5\" can be used (default is \"chain_1.txt\").</p> <p> TYPE: <code>str, optional</code> DEFAULT: <code>'chain_1.txt'</code> </p> RETURNS DESCRIPTION <code>params</code> <p>Dictionary containing the parameter names and their values.</p> <p> TYPE: <code>dict</code> </p> <code>mrgd_chain</code> <p>Numpy array containing the merged chains without the burn-in region.</p> <p> TYPE: <code>NDArray</code> </p> RAISES DESCRIPTION <code>SystemExit</code> <p>Raised when the chains have different parameters.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def import_chains(chains_dir: str | Path,\nburn_frac: float = 1/4,\nquick_import: bool = True, # noqa: FBT001, FBT002\nchain_name: str = \"chain_1.txt\") -&gt; tuple[dict, NDArray]:\n\"\"\"Import the chains and their parameter file.\n    Given a `chain_dir` that contains chains, this function imports the chains, removes `burn_frac`, and returns\n    a dictionary of parameters: values and a numpy array of the merged chains.\n    Parameters\n    ----------\n    chains_dir : str | Path\n        Name of the directory containing the chains.\n    burn_frac : float, optional\n        Fraction of the chain that is removed from the head (default is 1/4).\n    quick_import : bool, optional\n        Flag to skip importing the rednoise portion of chains (default is True).\n    chain_name : str, optional\n        The name of the chain files, include the file extension of the chain files. Compressed files\n        with extension \".gz\" and HDF5 files with extension \".h5\" can be used (default is \"chain_1.txt\").\n    Returns\n    -------\n    params : dict\n        Dictionary containing the parameter names and their values.\n    mrgd_chain : NDArray\n        Numpy array containing the merged chains without the burn-in region.\n    Raises\n    ------\n    SystemExit\n        Raised when the chains have different parameters.\n    \"\"\"\nparams, mrgd_chain = import_to_dataframe(chains_dir, burn_frac, quick_import, chain_name)\nmrgd_chain = mrgd_chain.to_numpy(dtype=float)\nparams = params.to_dict(orient=\"list\")\nreturn params, mrgd_chain\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.chain_filter","title":"chain_filter","text":"<pre><code>chain_filter(\nchain: NDArray,\nparams: list[str],\nmodel_id: int | None,\npar_to_plot: list[str] | None,\n) -&gt; tuple[NDArray, list[str]]\n</code></pre> <p>Filter chains.</p> <p>This function filters the rows in the provided chain according to the specified model and parameters. It selects rows that correspond to the specified model ID and parameters to plot their posteriors.</p> PARAMETER DESCRIPTION <code>chain</code> <p>The Markov Chain Monte Carlo (MCMC) chain to be filtered. This should be a multi-dimensional array where each row represents a state in the chain, and each column represents a parameter.</p> <p> TYPE: <code>NDArray</code> </p> <code>params</code> <p>The names of the parameters in the chain. This should be a list of strings with the same length as the number of columns in the chain.</p> <p> TYPE: <code>list[str]</code> </p> <code>model_id</code> <p>The ID of the model to filter the chain for. This should be either 0 or 1. If None, the function will select rows for model 0.</p> <p> TYPE: <code>int | None</code> </p> <code>par_to_plot</code> <p>The names of the parameters to filter the chain for. If None, the function will select all parameters except 'nmodel', 'log_posterior', 'log_likelihood', 'acceptance_rate', and 'n_parall', and parameters containing '+' or '-'.</p> <p> TYPE: <code>list[str] | None</code> </p> RETURNS DESCRIPTION <code>chain</code> <p>The filtered chain, containing only rows corresponding to the specified model ID and parameters.</p> <p> TYPE: <code>NDArray</code> </p> <code>filtered_par</code> <p>The list of filtered parameter names.</p> <p> TYPE: <code>list[str]</code> </p> RAISES DESCRIPTION <code>SystemExit</code> <p>If the provided <code>model_id</code> is not an integer equal to 0 or 1.</p>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.chain_filter--notes","title":"Notes","text":"<p>This function filters the chain in-place, meaning that the original chain will be modified.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def chain_filter(\nchain: NDArray,\nparams: list[str],\nmodel_id: int | None,\npar_to_plot: list[str] | None,\n) -&gt; tuple[NDArray, list[str]]:\n\"\"\"Filter chains.\n    This function filters the rows in the provided chain according to the specified model and parameters. It selects\n    rows that correspond to the specified model ID and parameters to plot their posteriors.\n    Parameters\n    ----------\n    chain : NDArray\n        The Markov Chain Monte Carlo (MCMC) chain to be filtered. This should be a multi-dimensional array where each\n        row represents a state in the chain, and each column represents a parameter.\n    params : list[str]\n        The names of the parameters in the chain. This should be a list of strings with the same length as the number\n        of columns in the chain.\n    model_id : int | None\n        The ID of the model to filter the chain for. This should be either 0 or 1. If None, the function will select\n        rows for model 0.\n    par_to_plot : list[str] | None\n        The names of the parameters to filter the chain for. If None, the function will select all parameters except\n        'nmodel', 'log_posterior', 'log_likelihood', 'acceptance_rate', and 'n_parall', and parameters\n        containing '+' or '-'.\n    Returns\n    -------\n    chain : NDArray\n        The filtered chain, containing only rows corresponding to the specified model ID and parameters.\n    filtered_par: list[str]\n        The list of filtered parameter names.\n    Raises\n    ------\n    SystemExit\n        If the provided `model_id` is not an integer equal to 0 or 1.\n    Notes\n    -----\n    This function filters the chain in-place, meaning that the original chain will be modified.\n    \"\"\"\nif 'nmodel' in list(params):\nnmodel_idx = list(params).index('nmodel')\nif model_id is None:\nprint(\"No model ID specified, posteriors are plotted for model 0\")\nfilter_model = chain[:, nmodel_idx] &lt; 0.5\nelif model_id == 0:\nfilter_model = chain[:, nmodel_idx] &lt; 0.5\nelif model_id == 1:\nfilter_model = chain[:, nmodel_idx] &gt; 0.5\nelse:\nerr = f\"'model_idx' can only be an integer equal to 0 or 1. I got {model_id=}.\"\nlog.error(err)\nraise SystemExit\nchain = chain[filter_model]\nelse:\npass\nif par_to_plot:\nfilter_par = [list(params).index(x) for x in par_to_plot if x in params]\nelse:\nfilter_par = [list(params).index(x)\nfor x in params\nif x\nnot in [\n\"nmodel\",\n\"log_posterior\",\n\"log_likelihood\",\n\"acceptance_rate\",\n\"n_parall\"]\nand '+' not in x\nand '-' not in x]\nfiltered_par = [par.replace('_','-') for par in params[filter_par]] # type: ignore\nfiltered_par = [par.replace('np-', '') if 'gw-bhb-np' in par else par for par in filtered_par]\nreturn chain[:, filter_par], filtered_par\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.calc_df","title":"calc_df","text":"<pre><code>calc_df(chain: NDArray) -&gt; NDArray\n</code></pre> <p>Calculate dropout bayes factor</p> PARAMETER DESCRIPTION <code>chain</code> <p>input dropout chain with shape assumed to be (n_bootstrap, n_samples)</p> <p> TYPE: <code>NDArray</code> </p> RETURNS DESCRIPTION <code>bayes_facs</code> <p>dropout bayes factor with shape (n_bootstrap,)</p> <p> TYPE: <code>NDArray</code> </p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def calc_df(chain: NDArray) -&gt; NDArray:\n\"\"\"Calculate dropout bayes factor\n    Parameters\n    ----------\n    chain : NDArray\n        input dropout chain with shape assumed to be (n_bootstrap, n_samples)\n    Returns\n    -------\n    bayes_facs : NDArray\n        dropout bayes factor with shape (n_bootstrap,)\n    \"\"\"\nbayes_facs = np.full(chain.shape[0], 0.0)\nfor ii, arr in enumerate(chain):\nbayes_facs[ii] = model_utils.odds_ratio(arr)[0]\nreturn bayes_facs\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.bf_bootstrap","title":"bf_bootstrap","text":"<pre><code>bf_bootstrap(\nchain: NDArray, burn: int = 0\n) -&gt; tuple[float, float]\n</code></pre> <p>Compute mean and variance of bayes factor.</p> <p>This function computes the mean and variance of the bayes factor after bootstrapping for a given chain.</p> PARAMETER DESCRIPTION <code>chain</code> <p>The Markov Chain Monte Carlo (MCMC) chain to be analyzed. This should be a multi-dimensional array where each row represents a state in the chain, and each column represents a parameter.</p> <p> TYPE: <code>NDArray</code> </p> <code>burn</code> <p>The burn-in period to be discarded from the start of the chain. This should be a non-negative integer. If not provided, no burn-in period will be discarded.</p> <p> TYPE: <code>int, optional</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>mean</code> <p>The mean of the bootstrapped degrees of freedom distribution.</p> <p> TYPE: <code>float</code> </p> <code>var</code> <p>The variance of the bootstrapped degrees of freedom distribution.</p> <p> TYPE: <code>float</code> </p>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.bf_bootstrap--notes","title":"Notes","text":"<p>This function uses the <code>acor</code> library to compute the autocorrelation time of the chain, which is then used to thin the chain. The thinned chain is then bootstrapped using the 'bootstrap' function with the <code>calc_df</code> user statistic, to obtain a distribution of degrees of freedom. The mean and variance of this distribution are then computed.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def bf_bootstrap(chain: NDArray, burn: int = 0) -&gt; tuple[float, float]:\n\"\"\"Compute mean and variance of bayes factor.\n    This function computes the mean and variance of the bayes factor after bootstrapping\n    for a given chain.\n    Parameters\n    ----------\n    chain : NDArray\n        The Markov Chain Monte Carlo (MCMC) chain to be analyzed. This should be a multi-dimensional array where each\n        row represents a state in the chain, and each column represents a parameter.\n    burn : int, optional\n        The burn-in period to be discarded from the start of the chain. This should be a non-negative integer.\n        If not provided, no burn-in period will be discarded.\n    Returns\n    -------\n    mean : float\n        The mean of the bootstrapped degrees of freedom distribution.\n    var : float\n        The variance of the bootstrapped degrees of freedom distribution.\n    Notes\n    -----\n    This function uses the `acor` library to compute the autocorrelation time of the chain, which is then used to thin\n    the chain. The thinned chain is then bootstrapped using the 'bootstrap' function with the `calc_df` user statistic,\n    to obtain a distribution of degrees of freedom. The mean and variance of this distribution are then computed.\n    \"\"\"\ncorr_len = int(acor.acor(chain[burn:,-1])[0])\ntest = chain[burn::corr_len]\ndf_dist_bs = bootstrap(test[:,0], n_bootstraps = 50000, user_statistic = calc_df)\nmean = np.mean(df_dist_bs)\nvar = np.var(df_dist_bs)\nreturn mean, var\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.compute_bf","title":"compute_bf","text":"<pre><code>compute_bf(\nchain: NDArray,\nparams: list[str],\nbootstrap: bool = False,\n) -&gt; tuple[float, float]\n</code></pre> <p>Compute the Bayes factor and estimate its uncertainty.</p> PARAMETER DESCRIPTION <code>chain</code> <p>The Markov Chain Monte Carlo (MCMC) chain to be analyzed. This should be a multi-dimensional array where each row represents a state in the chain, and each column represents a parameter. The 'nmodel' and 'log_posterior' columns should be used to specify the model index and the log of the posterior probabilities.</p> <p> TYPE: <code>NDArray</code> </p> <code>params</code> <p>The names of the parameters in the chain. This should be a list of strings with the same length as the number of columns in the chain. It is expected to contain 'nmodel' and 'log_posterior', which will be used to filter the chain based on the model index and compute the Bayes factor.</p> <p> TYPE: <code>list[str]</code> </p> <code>bootstrap</code> <p>A flag indicating whether to compute the Bayes factor using a bootstrap method. If True, the Bayes factor will be computed using the 'get_bf' function. The bootsrap calculation is significantly slower. Defaults to False.</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>bf</code> <p>The computed Bayes factor. This gives the evidence for model 0 over model 1. A higher value provides stronger evidence for model 0.</p> <p> TYPE: <code>float</code> </p> <code>unc</code> <p>The computed uncertainty of the Bayes factor.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>SystemExit</code> <p>If <code>nmodel</code> or <code>log_posterior</code> is not found in the <code>params</code> list.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def compute_bf(chain: NDArray, params: list[str], bootstrap: bool = False) -&gt; tuple[float, float]:  # noqa: FBT001, FBT002\n\"\"\"Compute the Bayes factor and estimate its uncertainty.\n    Parameters\n    ----------\n    chain : NDArray\n        The Markov Chain Monte Carlo (MCMC) chain to be analyzed. This should be a multi-dimensional array where each\n        row represents a state in the chain, and each column represents a parameter. The 'nmodel' and 'log_posterior'\n        columns should be used to specify the model index and the log of the posterior probabilities.\n    params : list[str]\n        The names of the parameters in the chain. This should be a list of strings with the same length as the number of\n        columns in the chain. It is expected to contain 'nmodel' and 'log_posterior', which will be used to filter the\n        chain based on the model index and compute the Bayes factor.\n    bootstrap : bool, optional\n        A flag indicating whether to compute the Bayes factor using a bootstrap method. If True, the Bayes factor will\n        be computed using the 'get_bf' function. The bootsrap calculation is significantly slower. Defaults to False.\n    Returns\n    -------\n    bf : float\n        The computed Bayes factor. This gives the evidence for model 0 over model 1. A higher value provides\n        stronger evidence for model 0.\n    unc : float\n        The computed uncertainty of the Bayes factor.\n    Raises\n    ------\n    SystemExit\n        If `nmodel` or `log_posterior` is not found in the `params` list.\n    \"\"\"\ntry:\nnmodel_idx = list(params).index('nmodel')\nexcept ValueError:\nerr = (\"'nmodel' was not found in params.\\n\"\nf\"You supplied {params=}\")\nlog.error(err)\nraise SystemExit from None\ntry:\nposterior_idx = list(params).index('log_posterior')\nexcept ValueError:\nerr = (\"'log_posterior' was not found in params.\\n\"\nf\"You supplied {params=}\")\nlog.error(err)\nraise SystemExit from None\nif bootstrap:\ndata = chain[:,[nmodel_idx, posterior_idx]]\nbf, unc = bf_bootstrap(data)\nelse:\nbf, unc = model_utils.odds_ratio(chain[:, nmodel_idx], models=[0,1])\nreturn bf, unc\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.bisection","title":"bisection","text":"<pre><code>bisection(\nf: Callable[[Any], float],\na: float,\nb: float,\ntol: float,\n) -&gt; float | None\n</code></pre> <p>Find roots for real-valued function using bisection method.</p> <p>This function implements the bisection method for root finding of a real-valued function. It recursively divides the interval [a, b] into two subintervals until the absolute value of f evaluated at the midpoint is less than the specified tolerance, at which point it returns the midpoint as an approximation of the root.</p> PARAMETER DESCRIPTION <code>f</code> <p>The function for which the root is to be found. It must be real-valued and continuous on the interval [a, b].</p> <p> TYPE: <code>Callable[[Any], float]</code> </p> <code>a</code> <p>The left endpoint of the interval in which the root is sought. It must be less than b.</p> <p> TYPE: <code>float</code> </p> <code>b</code> <p>The right endpoint of the interval in which the root is sought. It must be greater than a.</p> <p> TYPE: <code>float</code> </p> <code>tol</code> <p>The tolerance for the root approximation. The function will return when the absolute value of f evaluated at the midpoint is less than tol. It must be greater than 0.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float | None</code> <p>The midpoint of the final subinterval if a root is found; None otherwise. The root approximation m is guaranteed to satisfy |f(m)| &lt; tol if the function converges.</p> RAISES DESCRIPTION <code>SystemExit</code> <p>If a is not less than b, or if tol is not greater than 0.</p>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.bisection--notes","title":"Notes","text":"<p>This is a recursive implementation of the bisection method. The bisection method assumes that the function f changes sign over the interval [a, b], which implies that a root exists in this interval by the Intermediate Value Theorem.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def bisection(f: Callable[[Any], float], a: float, b: float, tol: float) -&gt; float | None:\n\"\"\"Find roots for real-valued function using bisection method.\n    This function implements the bisection method for root finding of a real-valued function. It recursively divides\n    the interval [a, b] into two subintervals until the absolute value of f evaluated at the midpoint is less than\n    the specified tolerance, at which point it returns the midpoint as an approximation of the root.\n    Parameters\n    ----------\n    f : Callable[[Any], float]\n        The function for which the root is to be found. It must be real-valued and continuous on the interval [a, b].\n    a : float\n        The left endpoint of the interval in which the root is sought. It must be less than b.\n    b : float\n        The right endpoint of the interval in which the root is sought. It must be greater than a.\n    tol : float\n        The tolerance for the root approximation. The function will return when the absolute value of f evaluated at\n        the midpoint is less than tol. It must be greater than 0.\n    Returns\n    -------\n    float | None\n        The midpoint of the final subinterval if a root is found; None otherwise. The root approximation m is guaranteed\n        to satisfy |f(m)| &lt; tol if the function converges.\n    Raises\n    ------\n    SystemExit\n        If a is not less than b, or if tol is not greater than 0.\n    Notes\n    -----\n    This is a recursive implementation of the bisection method. The bisection method assumes that the function f changes\n    sign over the interval [a, b], which implies that a root exists in this interval by the Intermediate Value Theorem.\n    \"\"\"\nif a &gt;= b:\nerr = f\"a is not less than b {a=} {b=}.\"\nlog.error(err)\nraise SystemExit\nif tol &lt;= 0:\nerr = f\"tol is not greater than 0 {tol=}.\"\nlog.error(err)\nraise SystemExit\nif np.sign(f(a)) == np.sign(f(b)):\nreturn None\nm = (a + b) / 2\nif np.abs(f(m)) &lt; tol:\nreturn m\nelif np.sign(f(a)) == np.sign(f(m)):\nreturn bisection(f, m, b, tol)\nelif np.sign(f(b)) == np.sign(f(m)):\nreturn bisection(f, a, m, tol)\nelse:\nreturn None\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.k_ratio_aux_1D","title":"k_ratio_aux_1D","text":"<pre><code>k_ratio_aux_1D(\nsample: MCSamples,\nbf: float,\npar: str,\npar_range: list[float],\nk_ratio: float,\n) -&gt; float | None\n</code></pre> <p>Returns the bound value for a given k-ratio in a 1D posterior density plot.</p> PARAMETER DESCRIPTION <code>sample</code> <p>An instance of the MCSamples class, containing the multivariate Monte Carlo samples on which the function is operating.</p> <p> TYPE: <code>MCSamples</code> </p> <code>bf</code> <p>The Bayes factor for the exotic + SMBHB vs. SMBHB model. Represents the strength of evidence in favour of the exotic model.</p> <p> TYPE: <code>float</code> </p> <code>par</code> <p>The name of the parameter for which the k-ratio bound should be computed.</p> <p> TYPE: <code>str</code> </p> <code>par_range</code> <p>The lower and upper prior limits for the parameter. It is represented as a list where the first element is the lower limit and the second element is the upper limit.</p> <p> TYPE: <code>list[float]</code> </p> <code>k_ratio</code> <p>The fraction of plateau height at which the height level is determined. This is used to compute the height_KB, which represents the height at which the bound is computed.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>k_val</code> <p>The computed k-ratio bound value. This is the value of the parameter at which the 1D posterior density crosses the height_KB.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the integration or the bisection search fails due to numerical issues or if the specified parameter range does not contain a valid root.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def k_ratio_aux_1D(\nsample: MCSamples,\nbf: float,\npar: str,\npar_range: list[float],\nk_ratio: float) -&gt; float | None:\n\"\"\"Returns the bound value for a given k-ratio in a 1D posterior density plot.\n    Parameters\n    ----------\n    sample : MCSamples\n        An instance of the MCSamples class, containing the multivariate\n        Monte Carlo samples on which the function is operating.\n    bf : float\n        The Bayes factor for the exotic + SMBHB vs. SMBHB model.\n        Represents the strength of evidence in favour of the exotic model.\n    par : str\n        The name of the parameter for which the k-ratio bound should be computed.\n    par_range : list[float]\n        The lower and upper prior limits for the parameter. It is represented as a list where\n        the first element is the lower limit and the second element is the upper limit.\n    k_ratio : float\n        The fraction of plateau height at which the height level is determined. This is used\n        to compute the height_KB, which represents the height at which the bound is computed.\n    Returns\n    -------\n    k_val : float\n        The computed k-ratio bound value. This is the value of the parameter at which the\n        1D posterior density crosses the height_KB.\n    Raises\n    ------\n    ValueError\n        If the integration or the bisection search fails due to numerical issues or\n        if the specified parameter range does not contain a valid root.\n    \"\"\"\ndensity1D = MCSamples.get1DDensity(sample, par)\nnorm = integrate.quad(density1D, par_range[0], par_range[1], full_output=1)[0]\nprior = 1/(par_range[1]-par_range[0])\nheight_KB = k_ratio*prior/bf*norm\nk_val = bisection(f = (lambda x: density1D(x)-height_KB), a = par_range[0], b = par_range[1], tol = 10**(-8))\nreturn k_val\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.k_ratio_aux_2D","title":"k_ratio_aux_2D","text":"<pre><code>k_ratio_aux_2D(\nsample: MCSamples,\nbf: float,\npar_1: str,\npar_2: str,\npar_range_1: list[float],\npar_range_2: list[float],\nk_ratio: float,\n) -&gt; float\n</code></pre> <p>Returns the height level corresponding to the given k-ratio in a 2D posterior density plot.</p> PARAMETER DESCRIPTION <code>sample</code> <p>An instance of the MCSamples class, containing the multivariate Monte Carlo samples on which the function is operating.</p> <p> TYPE: <code>MCSamples</code> </p> <code>bf</code> <p>The Bayes factor for the exotic + SMBHB vs. SMBHB model. Represents the strength of evidence in favour of the exotic model.</p> <p> TYPE: <code>float</code> </p> <code>par_1</code> <p>The names of the two parameters for which the k-ratio bound should be computed.</p> <p> TYPE: <code>str</code> </p> <code>par_2</code> <p>The names of the two parameters for which the k-ratio bound should be computed.</p> <p> TYPE: <code>str</code> </p> <code>par_range_1</code> <p>The lower and upper prior limits for the parameters. Each is represented as a list where the first element is the lower limit and the second element is the upper limit.</p> <p> TYPE: <code>list[float]</code> </p> <code>par_range_2</code> <p>The lower and upper prior limits for the parameters. Each is represented as a list where the first element is the lower limit and the second element is the upper limit.</p> <p> TYPE: <code>list[float]</code> </p> <code>k_ratio</code> <p>The fraction of plateau height at which the height level is determined. This is used to compute the height_KB, which represents the height at which the bound is computed.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>height_KB</code> <p>The computed height level in the 2D posterior density plot. This is the height at which the density equals the computed height_KB.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the double integration fails due to numerical issues.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def k_ratio_aux_2D(\nsample: MCSamples,\nbf: float,\npar_1: str,\npar_2: str,\npar_range_1: list[float],\npar_range_2: list[float],\nk_ratio: float) -&gt; float:\n\"\"\"\n    Returns the height level corresponding to the given k-ratio in a 2D posterior density plot.\n    Parameters\n    ----------\n    sample : MCSamples\n        An instance of the MCSamples class, containing the multivariate\n        Monte Carlo samples on which the function is operating.\n    bf : float\n        The Bayes factor for the exotic + SMBHB vs. SMBHB model.\n        Represents the strength of evidence in favour of the exotic model.\n    par_1, par_2 : str\n        The names of the two parameters for which the k-ratio bound should be computed.\n    par_range_1, par_range_2 : list[float]\n        The lower and upper prior limits for the parameters. Each is represented as a list\n        where the first element is the lower limit and the second element is the upper limit.\n    k_ratio : float\n        The fraction of plateau height at which the height level is determined. This is used\n        to compute the height_KB, which represents the height at which the bound is computed.\n    Returns\n    -------\n    height_KB : float\n        The computed height level in the 2D posterior density plot. This is the height at which\n        the density equals the computed height_KB.\n    Raises\n    ------\n    ValueError\n        If the double integration fails due to numerical issues.\n    \"\"\"\ndensity2D = MCSamples.get2DDensity(sample, par_1, par_2)\nwith warnings.catch_warnings():\nwarnings.simplefilter(\"ignore\")\n#Calculate prior value at each point\nnorm = integrate.dblquad(density2D, par_range_2[0], par_range_2[1], par_range_1[0], par_range_1[1])[0]\nprior = 1/(par_range_2[1]-par_range_2[0]) * 1/(par_range_1[1]-par_range_1[0])\nheight_KB = k_ratio*prior/bf*norm\nreturn height_KB\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.get_k_levels","title":"get_k_levels","text":"<pre><code>get_k_levels(\nsample: MCSamples,\npars: list[str],\npriors: dict,\nbf: float,\nk_ratio: float,\n) -&gt; tuple[NDArray, NDArray]\n</code></pre> <p>Compute and return the 1D and 2D k-ratio bounds for a given set of parameters.</p> PARAMETER DESCRIPTION <code>sample</code> <p>An instance of the MCSamples class, containing the multivariate Monte Carlo samples on which the function is operating.</p> <p> TYPE: <code>MCSamples</code> </p> <code>pars</code> <p>The list of all parameters for which the k-ratio bounds should be computed. The parameters 'gw-bhb-0' and 'gw-bhb-1' are excluded from this computation.</p> <p> TYPE: <code>list[str]</code> </p> <code>priors</code> <p>A dictionary containing the lower and upper prior limits for each parameter. Each key-value pair in the dictionary corresponds to a parameter and its limits, respectively.</p> <p> TYPE: <code>dict</code> </p> <code>bf</code> <p>The Bayes factor for the exotic + SMBHB vs. SMBHB model. Represents the strength of evidence in favour of the exotic model.</p> <p> TYPE: <code>float</code> </p> <code>k_ratio</code> <p>The fraction of plateau height at which the height level is determined.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>numpy array representing the 1D k-ratio bounds. Each element in the array is a list where the first elements are the parameter names and the last element is the computed k-ratio bound.</p> <code>NDArray</code> <p>numpy array representing the 2D k-ratio bounds. Each element in the array is a list where the first elements are the parameter names and the last element is the computed k-ratio bound.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def get_k_levels(sample: MCSamples,\npars: list[str],\npriors: dict,\nbf: float,\nk_ratio: float) -&gt; tuple[NDArray, NDArray]:\n\"\"\"Compute and return the 1D and 2D k-ratio bounds for a given set of parameters.\n    Parameters\n    ----------\n    sample : MCSamples\n        An instance of the MCSamples class, containing the multivariate\n        Monte Carlo samples on which the function is operating.\n    pars : list[str]\n        The list of all parameters for which the k-ratio bounds should be computed.\n        The parameters 'gw-bhb-0' and 'gw-bhb-1' are excluded from this computation.\n    priors : dict\n        A dictionary containing the lower and upper prior limits for each parameter.\n        Each key-value pair in the dictionary corresponds to a parameter and its limits,\n        respectively.\n    bf : float\n        The Bayes factor for the exotic + SMBHB vs. SMBHB model.\n        Represents the strength of evidence in favour of the exotic model.\n    k_ratio : float\n        The fraction of plateau height at which the height level is determined.\n    Returns\n    -------\n    NDArray\n        numpy array representing the 1D k-ratio bounds.\n        Each element in the array is a list where the first elements are the parameter names\n        and the last element is the computed k-ratio bound.\n    NDArray\n        numpy array representing the 2D k-ratio bounds.\n        Each element in the array is a list where the first elements are the parameter names\n        and the last element is the computed k-ratio bound.\n    \"\"\"\nnp_pars = [p for p in pars if p not in [\"gw-bhb-0\", \"gw-bhb-1\"]]\nlevels_2d = []\nfor par_1, par_2 in combinations(np_pars, r=2):\nlevels_2d.append(\n[par_1,\npar_2,\nk_ratio_aux_2D(\nsample=sample,\nbf=bf,\npar_1=par_1,\npar_2=par_2,\npar_range_1=priors[par_1],\npar_range_2=priors[par_2],\nk_ratio=k_ratio)])\nlevels_1d = []\nfor par in np_pars:\nlevels_1d.append(\n[par,\nk_ratio_aux_1D(\nsample = sample,\nbf = bf,\npar = par,\npar_range = priors[par],\nk_ratio = k_ratio)])\nreturn np.array(levels_1d), np.array(levels_2d)\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.get_bayes_est","title":"get_bayes_est","text":"<pre><code>get_bayes_est(\nsamples: MCSamples, params: list[str]\n) -&gt; dict[str, tuple[float, float]]\n</code></pre> <p>Compute and return the Bayesian estimates for a given set of parameters based on a sample of data.</p> PARAMETER DESCRIPTION <code>samples</code> <p>An instance of the MCSamples class, containing the multivariate Monte Carlo samples on which the function is operating.</p> <p> TYPE: <code>MCSamples</code> </p> <code>params</code> <p>The list of parameters for which the Bayesian estimates should be computed.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>x</code> <p>A dictionary representing the Bayesian estimates for each parameter. Each key-value pair in the dictionary corresponds to a parameter and its Bayesian estimate, respectively. Each estimate is represented as a tuple, where the first element is the mean and the second element is the standard deviation.</p> <p> TYPE: <code>dict[str, tuple[float, float]]</code> </p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def get_bayes_est(samples: MCSamples, params: list[str]) -&gt; dict[str, tuple[float, float]]:\n\"\"\"Compute and return the Bayesian estimates for a given set of parameters based on a sample of data.\n    Parameters\n    ----------\n    samples : MCSamples\n        An instance of the MCSamples class, containing the multivariate\n        Monte Carlo samples on which the function is operating.\n    params : list[str]\n        The list of parameters for which the Bayesian estimates should be computed.\n    Returns\n    -------\n    x : dict[str, tuple[float, float]]\n        A dictionary representing the Bayesian estimates for each parameter.\n        Each key-value pair in the dictionary corresponds to a parameter and its\n        Bayesian estimate, respectively. Each estimate is represented as a tuple,\n        where the first element is the mean and the second element is the standard\n        deviation.\n    \"\"\"\nx = list(samples.setMeans())\nxerr = list(np.sqrt(samples.getVars()))\nx = zip(x, xerr)\nx = dict(zip(params, x))\nreturn x\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.get_max_pos","title":"get_max_pos","text":"<pre><code>get_max_pos(\nparams: list[str],\nbayes_est: dict[str, tuple[float, float]],\nsample: MCSamples,\npriors: dict[str, tuple[float, float]],\nspc: int = 10,\n) -&gt; dict[str, float]\n</code></pre> <p>Compute and return the maximum posterior position for a given set of parameters.</p> PARAMETER DESCRIPTION <code>params</code> <p>The list of parameters for which the maximum posterior position should be computed.</p> <p> TYPE: <code>list[str]</code> </p> <code>bayes_est</code> <p>A dictionary containing the Bayesian estimates for each parameter. Each key-value pair in the dictionary corresponds to a parameter and its Bayesian estimate, respectively. Each estimate is represented as a tuple, where the first element is the mean and the second element is the standard deviation.</p> <p> TYPE: <code>dict[str, tuple[float, float]]</code> </p> <code>sample</code> <p>An instance of the MCSamples class, containing the multivariate Monte Carlo samples on which the function is operating.</p> <p> TYPE: <code>MCSamples</code> </p> <code>priors</code> <p>A dictionary containing the lower and upper prior limits for each parameter. Each key-value pair in the dictionary corresponds to a parameter and its limits, respectively.</p> <p> TYPE: <code>dict[str, tuple[float, float]]</code> </p> <code>spc</code> <p>The number of equally spaced points to be considered within the bounds of each parameter when searching for the maximum posterior position. Default is 10.</p> <p> TYPE: <code>int, optional</code> DEFAULT: <code>10</code> </p> RETURNS DESCRIPTION <code>out</code> <p>A dictionary representing the maximum posterior positions for each parameter. Each key-value pair in the dictionary corresponds to a parameter and its maximum posterior position, respectively.</p> <p> TYPE: <code>dict[str, float]</code> </p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def get_max_pos(params: list[str],\nbayes_est: dict[str, tuple[float, float]],\nsample: MCSamples,\npriors: dict[str, tuple[float, float]],\nspc: int = 10) -&gt; dict[str, float]:\n\"\"\"Compute and return the maximum posterior position for a given set of parameters.\n    Parameters\n    ----------\n    params : list[str]\n        The list of parameters for which the maximum posterior position should be computed.\n    bayes_est : dict[str, tuple[float, float]]\n        A dictionary containing the Bayesian estimates for each parameter.\n        Each key-value pair in the dictionary corresponds to a parameter and its\n        Bayesian estimate, respectively. Each estimate is represented as a tuple,\n        where the first element is the mean and the second element is the standard\n        deviation.\n    sample : MCSamples\n        An instance of the MCSamples class, containing the multivariate\n        Monte Carlo samples on which the function is operating.\n    priors : dict[str, tuple[float, float]]\n        A dictionary containing the lower and upper prior limits for each parameter.\n        Each key-value pair in the dictionary corresponds to a parameter and its limits,\n        respectively.\n    spc : int, optional\n        The number of equally spaced points to be considered within the bounds of\n        each parameter when searching for the maximum posterior position. Default is 10.\n    Returns\n    -------\n    out : dict[str, float]\n        A dictionary representing the maximum posterior positions for each parameter.\n        Each key-value pair in the dictionary corresponds to a parameter and its\n        maximum posterior position, respectively.\n    \"\"\"\nout = {}\nfor par in params:\nbounds = priors.get(par)\ndensity =  MCSamples.get1DDensity(sample, par, normalized=False)\nmind = lambda x: -density(x)[0]\nif not bounds:\nx = minimize(mind, np.array(bayes_est.get(par)[0]))\nx0 = x.x\nd0 = mind(x0)\nelse:\nini = np.linspace(bounds[0], bounds[1], spc)\nini = [val for val in ini]\nini.append(bayes_est.get(par)[0])\nx = []\nfor i in range(len(ini)):\nx1 = minimize(mind, ini[i])\nx.append(x1.x)\nbnds = Bounds(bounds[0], bounds[1])\nx2 = minimize(mind, ini[i], bounds=bnds)\nx.append(x2.x)\nd0 = 0\nx0 = 0\nfor val in x:\nif(mind(val)&lt;d0):\nx0 = val\nd0 = mind(val)\nout[par] = x0[0]\nreturn out\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.get_c_levels","title":"get_c_levels","text":"<pre><code>get_c_levels(\nsample: MCSamples, pars: list[str], levels: list[float]\n) -&gt; NDArray\n</code></pre> <p>Compute and return the highest posterior interval (HPI) for a given set of parameters and confidence levels.</p> PARAMETER DESCRIPTION <code>sample</code> <p>An instance of the MCSamples class, containing the multivariate Monte Carlo samples on which the function is operating.</p> <p> TYPE: <code>MCSamples</code> </p> <code>pars</code> <p>The list of parameters for which the HPI should be computed.</p> <p> TYPE: <code>list[str]</code> </p> <code>levels</code> <p>The list of confidence levels for which the HPI should be computed. Each value in the list should be between 0 and 1.</p> <p> TYPE: <code>list[float]</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>A numpy array representing the HPI for each parameter and each confidence level. Each element in the array is a list, where the first element is a parameter name and the second element is a list of HPIs for each confidence level.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def get_c_levels(sample: MCSamples, pars: list[str], levels: list[float]) -&gt; NDArray:\n\"\"\"Compute and return the highest posterior interval (HPI) for a given set of parameters and confidence levels.\n    Parameters\n    ----------\n    sample : MCSamples\n        An instance of the MCSamples class, containing the multivariate\n        Monte Carlo samples on which the function is operating.\n    pars : list[str]\n        The list of parameters for which the HPI should be computed.\n    levels : list[float]\n        The list of confidence levels for which the HPI should be computed.\n        Each value in the list should be between 0 and 1.\n    Returns\n    -------\n    NDArray\n        A numpy array representing the HPI for each parameter and each confidence level.\n        Each element in the array is a list, where the first element is a parameter name and\n        the second element is a list of HPIs for each confidence level.\n    \"\"\"\nhpi = []\nfor par in pars:\ndensity = MCSamples.get1DDensity(sample, par)\npoints = [[]] * len(levels)\nfor idx, level in enumerate(levels):\nx = density.getLimits(level)\nif not x[-1] and not x[-2]:\npoints[idx] = [x[0], x[1]]\nelif not x[-1]:\npoints[idx] = [False, x[1]]\nelif not x[-2]:\npoints[idx] = [x[0], False]\nelse:\npoints[idx] = [False, False]\nhpi.append([par, points])\nreturn np.array(hpi, dtype='object')\n</code></pre>"},{"location":"reference/ptarcade/fast_interpolate/","title":"fast_interpolate","text":"<p>Utilities for fast interpolation of spectra.</p>"},{"location":"reference/ptarcade/fast_interpolate/#ptarcade.fast_interpolate-functions","title":"Functions","text":""},{"location":"reference/ptarcade/fast_interpolate/#ptarcade.fast_interpolate.load_data","title":"load_data","text":"<pre><code>load_data(\nfile: str,\n) -&gt; tuple[list[tuple[str, float, float]], NDArray]\n</code></pre> <p>Load HDF5 file.</p> <p>Read data from an HDF5 file and use it for interpolation of the spectrum. The file must have the following data sets:</p> <p><code>parameter_names</code>: array of strings giving the names of the parameters in order. The last parameter must be the gravitational wave frequency <code>f</code>. Each parameter name: array giving start and step values.</p> <p><code>spectrum</code>: array indexed by parameters in order, giving omega_GW for these parameters.</p> PARAMETER DESCRIPTION <code>file</code> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple(list[tuple[str, float, float]], NDArray)</code> <p>Returns info: list of (name, start, step) and multidimensional array of data points</p> Source code in <code>src/ptarcade/fast_interpolate.py</code> <pre><code>def load_data(file: str) -&gt; tuple[list[tuple[str, float, float]], NDArray]:\n\"\"\"Load HDF5 file.\n    Read data from an HDF5 file and use it for interpolation of the spectrum.\n    The file must have the following data sets:\n    `parameter_names`: array of strings giving the names of the parameters in order.\n    The last parameter must be the gravitational wave frequency `f`.\n    Each parameter name: array giving start and step values.\n    `spectrum`: array indexed by parameters in order, giving omega_GW for these parameters.\n    Parameters\n    ----------\n    file : str\n    Returns\n    -------\n    tuple(list[tuple[str, float, float]], NDArray)\n        Returns info: list of (name, start, step) and multidimensional array of data points\n    \"\"\"\nwith h5py.File(file) as h5:\ninfo = [(par, h5[par][0], h5[par][1]) for par in h5['parameter_names'].asstr()]\nspectrum = np.array(h5['spectrum'])\nreturn (info, spectrum)\n</code></pre>"},{"location":"reference/ptarcade/fast_interpolate/#ptarcade.fast_interpolate.interp","title":"interp","text":"<pre><code>interp(\ninfo: list[tuple[float, float, array_like]],\ndata: NDArray,\n) -&gt; NDArray\n</code></pre> <p>Do interpolation.</p> <p>Called with info: list of (start, step, value) and multidimensional array of data points. Multiple values (in an np.array) are OK for the last value, but not earlier ones or else we will get confusion about array indexes.</p> PARAMETER DESCRIPTION <code>info</code> <p>list of (start, step, value)</p> <p> TYPE: <code>list[tuple[float, float, float]]</code> </p> <code>data</code> <p>Multidimensional array of data points. Multiple values (in an np.array) are OK for the last value, but not earlier ones or else we will get confusion about array indexes.</p> <p> TYPE: <code>NDArray</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>Interpolated values</p> Source code in <code>src/ptarcade/fast_interpolate.py</code> <pre><code>def interp(info: list[tuple[float, float, array_like]], data: NDArray) -&gt; NDArray:\n\"\"\"Do interpolation.\n    Called with info: list of (start, step, value) and multidimensional array of data points. Multiple values\n    (in an np.array) are OK for the last value, but not earlier ones or else we will get confusion about\n    array indexes.\n    Parameters\n    ----------\n    info : list[tuple[float, float, float]]\n        list of (start, step, value)\n    data : NDArray\n        Multidimensional array of data points. Multiple values (in an np.array) are OK for the last value, but\n        not earlier ones or else we will get confusion about array indexes.\n    Returns\n    -------\n    NDArray\n        Interpolated values\n    \"\"\"\nif len(info) == 0:       # Nothing to do: just return element\nreturn data\nx0, dx, x = info[0]\n# This function exploits single integer vs array of integer indexing.\n# Ceffyl returns an array, even if it only contains a single element.\n# Enterprise doesn't experience this issue.\n# The type of `x` below can change the type of `index` s.t. it breaks\n# this function (i.e. `index` will become [3] instead of just 3).\n# So, here we cast all single element arrays `x` to their\n# scalar representations.\n# We use getattr as a quick test for the type (if it's not an\n# array it won't have the attribute) and to get the shape\n# if it is an array.\n# There is probably a much more intelligent way to solve this issue\nif getattr(x, \"shape\", None)==(1,):\nx = x.item() # type: ignore\n(fract, index) = np.modf((x - x0) / dx) # type: ignore\nindex = index.astype(int)\n# Call ourselves to interpolate over remaining variables if any\n# then combine results linearly\nreturn (interp(info[1:], data[index]) * (1-fract)\n+ interp(info[1:], data[index+1]) * fract)\n</code></pre>"},{"location":"reference/ptarcade/fast_interpolate/#ptarcade.fast_interpolate.reformat","title":"reformat","text":"<pre><code>reformat(infile: str, outfile: str) -&gt; None\n</code></pre> <p>Convert an old-style file to our HDF5 format.</p> PARAMETER DESCRIPTION <code>infile</code> <p>The input file.</p> <p> TYPE: <code>str</code> </p> <code>outfile</code> <p>The output file where the reformatted <code>infile</code> will be saved.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>Exception</code> <p>Raised if frequency is not last parameter</p> RETURNS DESCRIPTION <code>None</code> <p>No explicit return value. The function creates <code>outfile</code></p>"},{"location":"reference/ptarcade/fast_interpolate/#ptarcade.fast_interpolate.reformat--notes","title":"Notes","text":"<p>The old-style has a header giving the parameter names including <code>spectrum</code>, then on each line the parameter values and the resulting omega_GW. The last parameter must vary fastest, and for each earlier parameter, the later parameters must go through precisely the same values. The values must be evenly spaced and in ascending order. There is no error checking in this code!</p> Source code in <code>src/ptarcade/fast_interpolate.py</code> <pre><code>def reformat(infile: str, outfile: str) -&gt; None:\n\"\"\"Convert an old-style file to our HDF5 format.\n    Parameters\n    ----------\n    infile : str\n        The input file.\n    outfile : str\n        The output file where the reformatted `infile` will be saved.\n    Raises\n    ------\n    Exception\n        Raised if frequency is not last parameter\n    Returns\n    -------\n    None\n        No explicit return value. The function creates `outfile`\n    Notes\n    -----\n    The old-style has a header giving the parameter names including `spectrum`,\n    then on each line the parameter values and the resulting omega_GW. The\n    last parameter must vary fastest, and for each earlier parameter,\n    the later parameters must go through precisely the same values. The values\n    must be evenly spaced and in ascending order. There is no error checking\n    in this code!\n    \"\"\"\npar_names = np.loadtxt(infile, max_rows=1, dtype='str') # Parameter names\ndata = np.loadtxt(infile, skiprows=1)\nspec_col = np.where(par_names=='spectrum')[0] # Index of spectrum\nspectrum = data.T[spec_col]              # List of data\ndata = np.delete(data, spec_col, axis=1)      # Remove data\npar_names = np.delete(par_names, spec_col)    # and 'spectrum'\nshape = np.zeros(len(par_names))              # This will be shape of data array\nwith h5py.File(outfile,'w') as out:\nout.create_dataset(\"parameter_names\", data=par_names.tolist())\nfor idx, par in enumerate(par_names):\nif par == 'f' and idx != len(par_names)-1:\nraise Exception(\"f field should have been last\") # Otherwise interp can't do multiple probes\nvalues = np.sort(np.unique(data.T[idx]))\ndataset = out.create_dataset(par, data=[values[0], values[1]-values[0]]) # Start and step\nshape[idx] = len(values)\nout.create_dataset(\"spectrum\", data=spectrum, shape=shape) # Reshape and write\n</code></pre>"},{"location":"reference/ptarcade/input_handler/","title":"input_handler","text":"<p>Methods to handle inputs.</p>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler-classes","title":"Classes","text":""},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.bcolors","title":"bcolors  <code>dataclass</code>","text":"<p>Class to hold ANSI escape sequences.</p> ATTRIBUTE DESCRIPTION <code>HEADER</code> <p> TYPE: <code>str</code> </p> <code>OKBLUE</code> <p> TYPE: <code>str</code> </p> <code>OKCYAN</code> <p> TYPE: <code>str</code> </p> <code>OKGREEN</code> <p> TYPE: <code>str</code> </p> <code>WARNING</code> <p> TYPE: <code>str</code> </p> <code>FAIL</code> <p> TYPE: <code>str</code> </p> <code>ENDC</code> <p> TYPE: <code>str</code> </p> <code>BOLD</code> <p> TYPE: <code>str</code> </p> <code>UNDERLINE</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/ptarcade/input_handler.py</code> <pre><code>@dataclass(frozen=True)\nclass bcolors:\n\"\"\"Class to hold ANSI escape sequences.\n    Attributes\n    ----------\n    HEADER : str\n    OKBLUE : str\n    OKCYAN : str\n    OKGREEN : str\n    WARNING : str\n    FAIL : str\n    ENDC : str\n    BOLD : str\n    UNDERLINE : str\n    \"\"\"\nHEADER: str = \"\\033[95m\"\nOKBLUE: str = \"\\033[94m\"\nOKCYAN: str = \"\\033[96m\"\nOKGREEN: str = \"\\033[92m\"\nWARNING: str = \"\\033[0;33m\"\nFAIL: str = \"\\033[0;31m\"\nENDC: str = \"\\033[0m\"\nBOLD: str = \"\\033[1m\"\nUNDERLINE : str = \"\\033[4m\"\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler-functions","title":"Functions","text":""},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.import_file","title":"import_file","text":"<pre><code>import_file(full_name: str, path: str) -&gt; ModuleType\n</code></pre> <p>Import a python module from a path.</p> PARAMETER DESCRIPTION <code>full_name</code> <p>Full name of the module.</p> <p> TYPE: <code>str</code> </p> <code>path</code> <p>Path to the module.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>mod</code> <p>The loaded module.</p> <p> TYPE: <code>ModuleType</code> </p>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.import_file--notes","title":"Notes","text":"<p>Python 3.4+ only. Does not call <code>sys.modules[full_name] = path</code></p> Source code in <code>src/ptarcade/input_handler.py</code> <pre><code>def import_file(full_name: str, path: str) -&gt; ModuleType :\n\"\"\"Import a python module from a path.\n    Parameters\n    ----------\n    full_name : str\n        Full name of the module.\n    path : str\n        Path to the module.\n    Returns\n    -------\n    mod : ModuleType\n        The loaded module.\n    Notes\n    -----\n    Python 3.4+ only. Does not call `sys.modules[full_name] = path`\n    \"\"\"\nspec = util.spec_from_file_location(full_name, path)\nmod = util.module_from_spec(spec)\nspec.loader.exec_module(mod)\nreturn mod\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.get_cmdline_arguments","title":"get_cmdline_arguments","text":"<pre><code>get_cmdline_arguments() -&gt; tuple[dict[str, Any], bool]\n</code></pre> <p>Create dictionary of command line arguments supplied.</p> RETURNS DESCRIPTION <code>options</code> <p>Dictionary containing command line arguments</p> <p> TYPE: <code>dict</code> </p> <code>comd_input_okay</code> <p>Boolean that is True if command line arguments are all present</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/ptarcade/input_handler.py</code> <pre><code>def get_cmdline_arguments() -&gt; tuple[dict[str, Any], bool]:\n\"\"\"Create dictionary of command line arguments supplied.\n    Returns\n    -------\n    options : dict\n        Dictionary containing command line arguments\n    comd_input_okay : bool\n        Boolean that is True if command line arguments are all present\n    \"\"\"\ndefault_config = files('ptarcade.data').joinpath('default_config.py')\nparser = optparse.OptionParser()\nparser.add_option('-m', action=\"store\", default=\"\",\nhelp=\"Path to models file. Sets the details of the new physics signal.\")\nparser.add_option('-c', action=\"store\", default=default_config,\nhelp=\"Path to configuration file. Sets details of the monte carlo run.\")\nparser.add_option('-n', action=\"store\", default=\"0\",\nhelp=\"Specifies the number of the chain.\")\noptions_in, args = parser.parse_args()\noptions = vars(options_in)\ncmd_input_okay = False\nif options['m'] != '':\ncmd_input_okay = True\nreturn options, cmd_input_okay\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.load_inputs","title":"load_inputs","text":"<pre><code>load_inputs(\ninput_options: dict[str, Any]\n) -&gt; dict[str, ModuleType]\n</code></pre> <p>Load the input parameters from the relevant files.</p> PARAMETER DESCRIPTION <code>input_options</code> <p>Command line options. Output of get_cmdline_arguments</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>dict[str, ModuleType]</code> <p>Dictionary that maps to loaded inputs as Python modules</p> Source code in <code>src/ptarcade/input_handler.py</code> <pre><code>def load_inputs(input_options: dict[str, Any]) -&gt; dict[str, ModuleType]:\n\"\"\"Load the input parameters from the relevant files.\n    Parameters\n    ----------\n    input_options : dict[str, Any]\n        Command line options. Output of [get_cmdline_arguments][ptarcade.input_handler.get_cmdline_arguments]\n    Returns\n    -------\n    dict[str, ModuleType]\n        Dictionary that maps to loaded inputs as Python modules\n    \"\"\"\nmodels_input = input_options['m']\nconfig_input = input_options['c']\nmodel_input_mod_name = os.path.splitext(os.path.basename(models_input))[0]\nmodel_mod = import_file(model_input_mod_name, os.path.abspath(models_input))\nconfig_input_mod_name = os.path.splitext(os.path.basename(config_input))[0]\nconfig_mod = import_file(config_input_mod_name, os.path.abspath(config_input))\nreturn {\n\"model\": model_mod,\n\"config\": config_mod\n}\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.check_config","title":"check_config","text":"<pre><code>check_config(config: ModuleType) -&gt; None\n</code></pre> <p>Validate the config file.</p> PARAMETER DESCRIPTION <code>config</code> <p>The configuration file loaded as a Python module</p> <p> TYPE: <code>ModuleType</code> </p> RAISES DESCRIPTION <code>SystemExit</code> <ul> <li>If <code>config.pta_data</code> is not string matching PTA dataset or a dictionary.</li> <li>If boolean parameters from <code>bools</code> in <code>config</code> are not <code>bool</code>.</li> <li>If integer parameters from <code>integers</code> in <code>config</code> are not <code>int</code>.</li> <li>If BHB pars from <code>bhb_pars</code> are not <code>int</code>, <code>float</code>, or <code>None</code>. If the path in <code>config.pta_data['psrs_data']</code> doesn't exist.</li> <li>If the keys of the <code>config.pta_data</code> dictionary do match the correct form.</li> <li>If <code>config.pta_data</code> contains an illegal value.</li> </ul> Source code in <code>src/ptarcade/input_handler.py</code> <pre><code>def check_config(config: ModuleType) -&gt; None:\n\"\"\"Validate the config file.\n    Parameters\n    ----------\n    config : ModuleType\n        The configuration file loaded as a Python module\n    Raises\n    ------\n    SystemExit\n        * If `config.pta_data` is not string matching PTA dataset or a dictionary.\n        * If boolean parameters from `bools` in `config` are not `bool`.\n        * If integer parameters from `integers` in `config` are not `int`.\n        * If BHB pars from `bhb_pars` are not `int`, `float`, or `None`.\n        If the path in `config.pta_data['psrs_data']` doesn't exist.\n        * If the keys of the `config.pta_data` dictionary do match the correct form.\n        * If `config.pta_data` contains an illegal value.\n    \"\"\"\n# checks that all the parameters are present in the config file\ndefault = {\n\"pta_data\" : 'NG15',\n\"N_samples\" : int(2e6),\n\"mode\" : 'enterprise',\n\"mod_sel\" : False,\n\"out_dir\" : './chains/',\n\"resume\" : False,\n\"scam_weight\" : 30,\n\"am_weight\" : 15,\n\"de_weight\" : 50,\n\"red_components\" : 30,\n\"corr\" : False,\n\"gwb_components\" : 14,\n\"bhb_th_prior\" : True,\n\"A_bhb_logmin\": None,\n\"A_bhb_logmax\" : None,\n\"gamma_bhb\" : None,\n}\nfor par in default.keys():\nif not hasattr(config, par):\nsetattr(config, par, default[par])\nmessage = ( f\"[green bold]{par}[/] [underline]not found[/] in the configuration file, \" +\nf\"it [underline]will be set to[/] [green bold]{default[par]}[/].\\n\")\nlog.info(message,extra={\"markup\": True, \"highlighter\": None})\n# checks PTA data\nif isinstance(config.pta_data, str):\nif config.pta_data in [\"NG15\", \"NG12\", \"IPTA2\"]:\npass\nelse:\nerror = (\nf\"The pta dataset [red]{config.pta_data}[/] is not included in PTArcade. \"\n\"Please, choose between 'NG15', 'NG12', 'IPTA2' \"\n\"or load your own data.\"\n)\nlog.error(error, extra={\"markup\":True})\nraise SystemExit\nelif isinstance(config.pta_data, dict):\nif list(config.pta_data.keys()) != [\"psrs_data\", \"noise_data\", \"emp_dist\"]:\nerror = (\n\"The keys of the pta_data dictionary in the configuration file \"\nf\"need to be {['psrs_data', 'noise_data', 'emp_dist']}.\\n\"\nf\"The keys I got were {list(config.pta_data.keys())}.\"\n)\nlog.error(error)\nraise SystemExit\nelif not os.path.exists(config.pta_data[\"psrs_data\"]):\nerror = f\"The path '[red]{config.pta_data['psrs_data']}[/]' specified in [green]pta_data['psrs_data'][/] does not exist.\"\nlog.error(error, extra={\"markup\":True, \"highlighter\":False})\nraise SystemExit\nelse:\npass\nelse:\nerror = (\n\"The 'pta_data' variable in the configuration file needs to be \"\n\"either a string between 'NG15', 'NG12', 'IPTA2', \"\n\"or a dictionary pointing to a set of PTA data.\\n\"\nf\"You supplied pta_data={config.pta_data}\"\n)\nlog.error(error)\nraise SystemExit\n# checks mod\nif isinstance(config.pta_data, str):\nif config.mode in [\"enterprise\", \"ceffyl\"]:\npass\nelse:\nerror = (\nf\"'{config.mode}' is not a valid run mode for PTArcade.\\n\"\n\"PTArcade can be run in two modes: 'enterprise' \"\n\"or 'ceffyl'. Please select one of these two for the 'mode' \"\n\"parameter in the configuration file.\"\n)\nlog.error(error)\nraise SystemExit\n# checks booleans variables\nbools = {\n\"mod_sel\": config.mod_sel,\n\"resume\": config.resume,\n\"corr\": config.corr,\n\"bhb_th_prior\": config.bhb_th_prior,\n}\nfor key, value in bools.items():\nif not isinstance(value, bool):\nerror = (\nf\"The variable '{key}' in the configuration file must be a boolean.\\n\"\nf\"You supplied {key}={bools[key]}.\"\n)\nlog.error(error)\nraise SystemExit\n# checks integers\nintegers = {\n\"N_samples\": config.N_samples,\n\"scam_weight\": config.scam_weight,\n\"am_weight\": config.am_weight,\n\"de_weight\": config.de_weight,\n\"red_components\": config.red_components,\n\"red_gwb_components\": config.gwb_components,\n}\nfor key, value in integers.items():\nif not isinstance(value, int):\nerror = (\nf\"variable '{key}' in the configuration file must be an integer.\\n\"\nf\"You supplied {key}={integers[key]}, type is {type(integers[key])}.\"\n)\nlog.error(error)\nraise SystemExit\n# checks bhb params\nbhb_pars = {\"A_bhb_logmin\": config.A_bhb_logmin, \"A_bhb_logmax\": config.A_bhb_logmax, \"gamma_bhb\": config.gamma_bhb}\nfor key, value in bhb_pars.items():\nif not isinstance(value, (float, int)) and value is not None:\nerror = (\nf\"The variable '{key}' in the configuration file must \"\n\"be a number (integer or float), or set to None.\\n\"\nf\"You supplied {key}={bhb_pars[key]}, type is {type(bhb_pars[key])}.\"\n)\nlog.error(error)\nraise SystemExit\nif config.bhb_th_prior and (config.A_bhb_logmin or config.A_bhb_logmax or config.gamma_bhb):\nwarning = (\n\"Since bhb_th_prior is set to True, any value of A_bhb_logmin, \"\n\"A_bhb_logmax, or gamma_bhb will be ignored.\\n\"\n)\nlog.warning(warning)\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.check_model","title":"check_model","text":"<pre><code>check_model(\nmodel: ModuleType,\npsrs: list[Pulsar],\nred_components: int,\ngwb_components: int,\nmode: str,\n) -&gt; None\n</code></pre> <p>Validate model file.</p> PARAMETER DESCRIPTION <code>model</code> <p>Loaded user configuration as python module.</p> <p> TYPE: <code>ModuleType</code> </p> <code>psrs</code> <p>List of enterprise.pulsar.Pulsar objects.</p> <p> TYPE: <code>list[Pulsar]</code> </p> <code>red_components</code> <p>Number of red components.</p> <p> TYPE: <code>int</code> </p> <code>gwb_components</code> <p>Number of GWB components.</p> <p> TYPE: <code>int</code> </p> RAISES DESCRIPTION <code>SystemExit</code> <ul> <li>If the shape of the output spectrum doesn't have the same shape as the input frequency list.</li> <li>If the output signal doesn't have the same shape as the input frequency list.</li> <li>If model file doesn't contain a parameter dictionary <code>parameters</code>.</li> <li>If model file doesn't contain <code>spectrum</code> or <code>signal</code>.</li> <li>If model <code>spectrum</code> evaluation fails.</li> <li>If model <code>signal</code> evaluation fails.</li> <li>If the keys of the model file's parameter dictionary do not match the keys of the signal or spectrum function.</li> </ul> Source code in <code>src/ptarcade/input_handler.py</code> <pre><code>def check_model(model: ModuleType, psrs: list[Pulsar], red_components: int, gwb_components: int, mode: str) -&gt; None:\n\"\"\"Validate model file.\n    Parameters\n    ----------\n    model : ModuleType\n        Loaded user configuration as python module.\n    psrs : list[Pulsar]\n        List of [enterprise.pulsar.Pulsar][] objects.\n    red_components : int\n        Number of red components.\n    gwb_components : int\n        Number of GWB components.\n    Raises\n    ------\n    SystemExit\n        * If the shape of the output spectrum doesn't have the same shape as the input frequency list.\n        * If the output signal doesn't have the same shape as the input frequency list.\n        * If model file doesn't contain a parameter dictionary `parameters`.\n        * If model file doesn't contain `spectrum` or `signal`.\n        * If model `spectrum` evaluation fails.\n        * If model `signal` evaluation fails.\n        * If the keys of the model file's parameter dictionary do not match the keys of the signal or spectrum function.\n    \"\"\"\n# checks that all the parameters are present in the config file\noptional = [\"name\", \"smbhb\"]\noptional_default = {\"name\": \"np_model\", \"smbhb\": False}\nif not (hasattr(model, \"parameters\")):\nerror = \"The model file needs to contain a parameter dictionary.\"\nlog.error(error)\nraise SystemExit\nif not (hasattr(model, \"signal\") or hasattr(model, \"spectrum\")):\nerror = (\n\"The model file needs to contain either a 'spectrum' \"\n\"function or a 'signal' function.\"\n)\nlog.error(error)\nraise SystemExit\nfor par in optional:\nif not hasattr(model, par):\nsetattr(model, par, optional_default[par])\nmessage = f\"[bold]{par}[/] not found in the model file, it will be set to [bold]{optional_default[par]}[/].\\n\"\nlog.info(message, extra={\"markup\": True})\n# check priors\n# check that parameters name match the variable of the spectrum function\ntry:\nargs = inspect.getfullargspec(model.spectrum)[0]\nargs.remove(\"f\")\nsignal_type = \"spectrum\"\nexcept AttributeError:\nargs = inspect.getfullargspec(model.signal)[0]\nargs.remove(\"toas\")\nsignal_type = \"signal\"\nif \"pos\" in args:\nargs.remove(\"pos\")\nif list(model.parameters.keys()) != args:\nerror = (\n\"In the model file, the keys of the 'parameter' dictionary need to \"\nf\"match the parameters of the {signal_type} function.\\n\"\nf\"You supplied:\\nmodel parameters = {list(model.parameters.keys())}\\n\"\nf\"{signal_type} parameters = {args}\"\n)\nlog.error(error)\nraise SystemExit\n# check spectrum/signal function\nx0 = {}\nfor name, par in model.parameters.items():\ntry:\nx0[name] = par.sample()  # type: ignore\nexcept AttributeError:\nx0[name] = par.value  # type: ignore\nexcept TypeError:\nx0[name] = par(name).sample()\nif hasattr(model, \"spectrum\"):\nif mode == \"enterprise\":\nT = model_utils.get_tspan(psrs)\nelse:\nT = 3 * 10**7\nN_f = max(red_components, gwb_components)\nf_tab = np.linspace(1 / T, N_f / T, N_f)\ntry:\nspectrum_tab = model.spectrum(f=f_tab, **x0)\nexcept AttributeError:\nerror = (\n\"I tried to evaluate the spectrum function on the array of \"\n\"frequency components you selected and for random values of \"\n\"the parameter contained in the prior range but it failed. \"\n\"Please, check that the spectrum function can take a numpy \"\n\"list of frequencies as argument, and that it is well defined \"\n\"within the entire prior volume.\"\n)\nlog.error(error)\nraise SystemExit from None\nif np.shape(spectrum_tab) != np.shape(f_tab):\nerror = (\n\"The output of the spectrum function needs to have the same \"\n\"dimensions of the frequency list passed as argument.\\n\"\nf\"{np.shape(spectrum_tab)=} != {np.shape(f_tab)=}.\"\n)\nlog.error(error)\nraise SystemExit\nelif hasattr(model, \"signal\") and mode == \"ceffyl\":\nerror = (\"You cannot use Ceffyl mode for deterministic signals.\")\nlog.error(error)\nraise SystemExit\nelse:\ntmin = np.min([p.toas.min() for p in psrs])\ntmax = np.max([p.toas.max() for p in psrs])\ntoas_tab = np.linspace(tmin, tmax, 10)\ntry:\nsignal_tab = model.signal(toas_tab, **x0)\nexcept AttributeError:\nerror = (\n\"I tried to evaluate the signal function on an array of \"\n\"toas withing the observing time and for a set of model \"\n\"parameters contained in the prior range but it failed. \"\n\"Please, check that the signal function can take a numpy \"\n\"list of toas as argument, and that it is well defined \"\n\"within the entire prior volume.\"\n)\nlog.error(error)\nraise SystemExit from None\nif np.shape(signal_tab) != np.shape(toas_tab):\nerror = (\n\"The output of the signal function needs to have the same \"\n\"dimensions of the toas list passed as argument.\\n\"\nf\"{np.shape(signal_tab)=} != {np.shape(toas_tab)=}.\"\n)\nlog.error(error)\nraise SystemExit\n</code></pre>"},{"location":"reference/ptarcade/models_utils/","title":"models_utils","text":"<p>Module providing physical constants and useful cosmological functions.</p> <p>All the constants are expressed in GeV, unless differently stated. The values are taken from the Particle Data Group (PDG).</p> ATTRIBUTE DESCRIPTION <code>G</code> <p>Newton constant (GeV\\(^{-2}\\))</p> <p> TYPE: <code>np.float64</code> </p> <code>M_pl</code> <p>Reduced Planck mass (GeV)</p> <p> TYPE: <code>np.float64</code> </p> <code>T_0</code> <p>Present day temperature of the Universe (GeV)</p> <p> TYPE: <code>np.float64</code> </p> <code>z_eq</code> <p>Redshift of matter-radiation equality</p> <p> TYPE: <code>int</code> </p> <code>T_eq</code> <p>Temperature of matter-radiation equality (GeV)</p> <p> TYPE: <code>np.float64</code> </p> <code>h</code> <p>Reduced Hubble parameter</p> <p> TYPE: <code>float</code> </p> <code>H_0</code> <p>Hubble constant (GeV)</p> <p> TYPE: <code>np.float64</code> </p> <code>H_0_Hz</code> <p>Hubble constant (Hz)</p> <p> TYPE: <code>np.float64</code> </p> <code>omega_v</code> <p>Dark energy density today (Planck 2018)</p> <p> TYPE: <code>float</code> </p> <code>omega_m</code> <p>Matter density today (Planck 2018)</p> <p> TYPE: <code>float</code> </p> <code>omega_r</code> <p>Radiation density today (Planck 2018)</p> <p> TYPE: <code>float</code> </p> <code>A_s</code> <p>Planck 2018 amplitude of primordial scalar power spectrum</p> <p> TYPE: <code>np.float64</code> </p> <code>f_cmb</code> <p>CMB pivot scale (Hz)</p> <p> TYPE: <code>float</code> </p> <code>gev_to_hz</code> <p>Conversion from GeV to Hz</p> <p> TYPE: <code>np.float64</code> </p> <code>g_rho_0</code> <p>Relativistic degrees of freedom today</p> <p> TYPE: <code>np.float64</code> </p> <code>g_s_0</code> <p>Entropic relativistic degrees of freedom today</p> <p> TYPE: <code>np.float64</code> </p> <code>priors_type</code> <p>Type for parameter priors.</p> <p> TYPE: <code>typing.Literal['Uniform', 'Normal', 'TruncNormal', 'LinearExp', 'Constant', 'Gamma']</code> </p>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils-classes","title":"Classes","text":""},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.ParamDict","title":"ParamDict","text":"<p>         Bases: <code>UserDict</code></p> <p>UserDict child class that instantiates common or uncommon parameter priors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from ptarcade.models_utils import ParamDict, prior\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; parameters = ParamDict(\n...     {\n...     \"log10_A_dm\" : prior(\"Uniform\", -9, -4),\n...     \"log10_f_dm\" : prior(\"Uniform\", pmin=-10, pmax=-5.5), # kwargs also work\n...     \"gamma_p\" : prior(\"Uniform\", 0, 2 * np.pi, common=False),\n...     \"gamma_e\" : prior(\"Uniform\", 0, 2 * np.pi),\n...     \"phi_hat_sq_e\" : prior(\"Gamma\", a=1, loc=0, scale=1, common=False),\n...     }\n... )\n&gt;&gt;&gt; pprint(parameters, sort_dicts=False)\n{'log10_A_dm': log10_A_dm:Uniform(pmin=-9, pmax=-4),\n 'log10_f_dm': log10_f_dm:Uniform(pmin=-10, pmax=-5.5),\n 'gamma_p': &lt;class 'enterprise.signals.parameter.Uniform.&lt;locals&gt;.Uniform'&gt;,\n 'gamma_e': gamma_e:Uniform(pmin=0, pmax=6.283185307179586),\n 'phi_hat_sq_e': &lt;class 'ptarcade.models_utils.Gamma.&lt;locals&gt;.Gamma'&gt;}\n</code></pre> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>class ParamDict(UserDict):\n\"\"\"UserDict child class that instantiates common or uncommon parameter priors.\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from ptarcade.models_utils import ParamDict, prior\n    &gt;&gt;&gt; from pprint import pprint\n    &gt;&gt;&gt; parameters = ParamDict(\n    ...     {\n    ...     \"log10_A_dm\" : prior(\"Uniform\", -9, -4),\n    ...     \"log10_f_dm\" : prior(\"Uniform\", pmin=-10, pmax=-5.5), # kwargs also work\n    ...     \"gamma_p\" : prior(\"Uniform\", 0, 2 * np.pi, common=False),\n    ...     \"gamma_e\" : prior(\"Uniform\", 0, 2 * np.pi),\n    ...     \"phi_hat_sq_e\" : prior(\"Gamma\", a=1, loc=0, scale=1, common=False),\n    ...     }\n    ... )\n    &gt;&gt;&gt; pprint(parameters, sort_dicts=False)\n    {'log10_A_dm': log10_A_dm:Uniform(pmin=-9, pmax=-4),\n     'log10_f_dm': log10_f_dm:Uniform(pmin=-10, pmax=-5.5),\n     'gamma_p': &lt;class 'enterprise.signals.parameter.Uniform.&lt;locals&gt;.Uniform'&gt;,\n     'gamma_e': gamma_e:Uniform(pmin=0, pmax=6.283185307179586),\n     'phi_hat_sq_e': &lt;class 'ptarcade.models_utils.Gamma.&lt;locals&gt;.Gamma'&gt;}\n    \"\"\"\ndef __setitem__(self, key: str, prior: parameter.Parameter):\n# The \"or\" here makes it backwards compatible with our old syntax\n# for the parameter dictionaries\nif isinstance(prior, parameter.Parameter ) or getattr(prior, \"common\", False):\nsuper().__setitem__(key, prior(key))\nelse:\nsuper().__setitem__(key, prior)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils-functions","title":"Functions","text":""},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.g_rho","title":"g_rho","text":"<pre><code>g_rho(x: array_like, is_freq: bool = False) -&gt; array_like\n</code></pre> <p>Return the number of relativistic degrees of freedom as a function of T/GeV or f/Hz.</p> PARAMETER DESCRIPTION <code>x</code> <p>The temperature(s) [GeV] or frequency/frequencies [Hz].</p> <p> TYPE: <code>array_like</code> </p> <code>is_freq</code> <p>True if <code>x</code> is a frequency/frequencies, False if temperature(s). Defaults to False.</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dof</code> <p>The relativistic degrees of freedom at <code>x</code>.</p> <p> TYPE: <code>array_like</code> </p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def g_rho(x: array_like, is_freq: bool = False) -&gt; array_like:  # noqa: FBT001, FBT002\n\"\"\"Return the number of relativistic degrees of freedom as a function of T/GeV or f/Hz.\n    Parameters\n    ----------\n    x : array_like\n        The temperature(s) [GeV] or frequency/frequencies [Hz].\n    is_freq : bool, optional\n        True if `x` is a frequency/frequencies, False if temperature(s).\n        Defaults to False.\n    Returns\n    -------\n    dof : array_like\n        The relativistic degrees of freedom at `x`.\n    \"\"\"\nif is_freq:\ndof = np.interp(x, gs[:, 1], gs[:, 3])\nelse:\ndof = np.interp(x, gs[:, 0], gs[:, 3])\nreturn dof\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.g_s","title":"g_s","text":"<pre><code>g_s(x: array_like, is_freq: bool = False) -&gt; array_like\n</code></pre> <p>Return the number of entropic relativistic degrees of freedom as a function of T/GeV or f/Hz.</p> PARAMETER DESCRIPTION <code>x</code> <p>The temperature(s) [GeV] or frequency/frequencies [Hz].</p> <p> TYPE: <code>array_like</code> </p> <code>is_freq</code> <p>True if <code>x</code> is a frequency/frequencies, False if temperature(s). Defaults to False.</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dof</code> <p>The entropic relativistic degrees of freedom at <code>x</code>.</p> <p> TYPE: <code>array_like</code> </p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def g_s(x: array_like, is_freq: bool = False) -&gt; array_like:  # noqa: FBT001, FBT002\n\"\"\"Return the number of entropic relativistic degrees of freedom as a function of T/GeV or f/Hz.\n    Parameters\n    ----------\n    x : array_like\n        The temperature(s) [GeV] or frequency/frequencies [Hz].\n    is_freq : bool, optional\n        True if `x` is a frequency/frequencies, False if temperature(s).\n        Defaults to False.\n    Returns\n    -------\n    dof : array_like\n        The entropic relativistic degrees of freedom at `x`.\n    \"\"\"\nif is_freq:\ndof = np.interp(x, gs[:, 1], gs[:, 2])\nelse:\ndof = np.interp(x, gs[:, 0], gs[:, 2])\nreturn dof\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.__g_s_0","title":"__g_s_0  <code>cached</code>","text":"<pre><code>__g_s_0(T_0: float) -&gt; np.float64\n</code></pre> <p>Calculate the entropic relativistic degrees of freedom today.</p> <p>This function is cached because it only needs to be ran once. It is a function instead of a constant so that if the <code>g_star.dat</code> file changes, this value will update as well.</p> PARAMETER DESCRIPTION <code>T_0</code> <p>The universe's temperature today [GeV].</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The entropic relativistic degrees of freedom today.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>@cache\ndef __g_s_0(T_0: float) -&gt; np.float64:\n\"\"\"Calculate the entropic relativistic degrees of freedom today.\n    This function is cached because it only needs to be ran once. It is a function instead of a constant so that\n    if the `g_star.dat` file changes, this value will update as well.\n    Parameters\n    ----------\n    T_0 : float\n        The universe's temperature today [GeV].\n    Returns\n    -------\n    float\n        The entropic relativistic degrees of freedom today.\n    \"\"\"\nreturn g_s(T_0) # type: ignore\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.__g_rho_0","title":"__g_rho_0  <code>cached</code>","text":"<pre><code>__g_rho_0(T_0: float) -&gt; np.float64\n</code></pre> <p>Calculate the relativistic degrees of freedom today.</p> <p>This function is cached because it only needs to be ran once. It is a function instead of a constant so that if the <code>g_star.dat</code> file changes, this value will update as well.</p> PARAMETER DESCRIPTION <code>T_0</code> <p>The universe's temperature today [GeV].</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The relativistic degrees of freedom today.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>@cache\ndef __g_rho_0(T_0: float) -&gt; np.float64:\n\"\"\"Calculate the relativistic degrees of freedom today.\n    This function is cached because it only needs to be ran once. It is a function instead of a constant so that\n    if the `g_star.dat` file changes, this value will update as well.\n    Parameters\n    ----------\n    T_0 : float\n        The universe's temperature today [GeV].\n    Returns\n    -------\n    float\n        The relativistic degrees of freedom today.\n    \"\"\"\nreturn g_rho(T_0) # type: ignore\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.GammaPrior","title":"GammaPrior","text":"<pre><code>GammaPrior(\nvalue: float, a: float, loc: float, scale: float\n) -&gt; float\n</code></pre> <p>Prior function for Gamma parameters.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of the parameter.</p> <p> TYPE: <code>float</code> </p> <code>a</code> <p>The shape parameter of the Gamma distribution.</p> <p> TYPE: <code>float</code> </p> <code>loc</code> <p>The location parameter of the Gamma distribution.</p> <p> TYPE: <code>float</code> </p> <code>scale</code> <p>The scale parameter of the Gamma distribution.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The probability density of the Gamma distribution at <code>value</code>.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def GammaPrior(value: float, a: float, loc: float, scale: float) -&gt; float:\n\"\"\"Prior function for Gamma parameters.\n    Parameters\n    ----------\n    value : float\n        The value of the parameter.\n    a : float\n        The shape parameter of the Gamma distribution.\n    loc : float\n        The location parameter of the Gamma distribution.\n    scale : float\n        The scale parameter of the Gamma distribution.\n    Returns\n    -------\n    float\n        The probability density of the Gamma distribution at `value`.\n    \"\"\"\nreturn ss.gamma.pdf(value, a, loc, scale)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.GammaSampler","title":"GammaSampler","text":"<pre><code>GammaSampler(\na: float,\nloc: float,\nscale: float,\nsize: int | None = None,\n) -&gt; NDArray\n</code></pre> <p>Sampling function for Gamma parameters.</p> PARAMETER DESCRIPTION <code>a</code> <p>The shape parameter of the Gamma distribution.</p> <p> TYPE: <code>float</code> </p> <code>loc</code> <p>The location parameter of the Gamma distribution.</p> <p> TYPE: <code>float</code> </p> <code>scale</code> <p>The scale parameter of the Gamma distribution.</p> <p> TYPE: <code>float</code> </p> <code>size</code> <p>The number of samples to draw.</p> <p> TYPE: <code>int, optional</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>A NumPy array of size <code>size</code> containing samples from the Gamma distribution.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def GammaSampler(a: float, loc: float, scale: float, size: int | None  = None) -&gt; NDArray:\n\"\"\"Sampling function for Gamma parameters.\n    Parameters\n    ----------\n    a : float\n        The shape parameter of the Gamma distribution.\n    loc : float\n        The location parameter of the Gamma distribution.\n    scale : float\n        The scale parameter of the Gamma distribution.\n    size : int, optional\n        The number of samples to draw.\n    Returns\n    -------\n    NDArray\n        A NumPy array of size `size` containing samples from the Gamma distribution.\n    \"\"\"\nreturn ss.gamma.rvs(a, loc, scale, size=size)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.Gamma","title":"Gamma","text":"<pre><code>Gamma(\na: float,\nloc: float,\nscale: float,\nsize: int | None = None,\n)\n</code></pre> <p>Class factory for Gamma parameters.</p> PARAMETER DESCRIPTION <code>a</code> <p>The shape parameter of the Gamma distribution.</p> <p> TYPE: <code>float</code> </p> <code>loc</code> <p>The location parameter of the Gamma distribution.</p> <p> TYPE: <code>float</code> </p> <code>scale</code> <p>The scale parameter of the Gamma distribution.</p> <p> TYPE: <code>float</code> </p> <code>size</code> <p>The number of samples to draw.</p> <p> TYPE: <code>int, optional</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Gamma</code> <p>Child class of enterprise.signals.parameter.Parameter for Gamma distribution</p> <p> TYPE: <code>parameter.Parameter</code> </p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def Gamma(a: float, loc: float, scale: float, size: int | None = None):\n\"\"\"Class factory for Gamma parameters.\n    Parameters\n    ----------\n    a : float\n        The shape parameter of the Gamma distribution.\n    loc : float\n        The location parameter of the Gamma distribution.\n    scale : float\n        The scale parameter of the Gamma distribution.\n    size : int, optional\n        The number of samples to draw.\n    Returns\n    -------\n    Gamma : parameter.Parameter\n        Child class of [enterprise.signals.parameter.Parameter][] for Gamma distribution\n    \"\"\"\nclass Gamma(parameter.Parameter):\n\"\"\"Child class of enterprise.signals.parameter.Parameter.\"\"\"\n_size = size\n_prior = parameter.Function(GammaPrior, a=a, loc=loc, scale=scale)\n_sampler = staticmethod(GammaSampler)\n_typename = parameter._argrepr(\"Gamma\", a=a, loc=loc, scale=scale)\nreturn Gamma\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.omega2cross","title":"omega2cross","text":"<pre><code>omega2cross(\nomega_hh: Callable[..., NDArray], ceffyl: bool = False\n) -&gt; Callable[..., NDArray]\n</code></pre> <p>Convert GW energy density.</p> <p>Converts the GW energy density as a fraction of the closure density into the cross-power spectral density as a function of the frequency in Hz. This is intended to be used as a decorator on a function that returns the GW energy density as a fraction of the closure density.</p> PARAMETER DESCRIPTION <code>omega_hh</code> <p>The function that returns the GW energy density as a fraction of the closure density.</p> <p> TYPE: <code>Callable[..., NDArray]</code> </p> <p>ceffyl: bool     If set to tru use a version compatible with ceffyl, if set to false a version compatible with      ENTERPRISE</p> RETURNS DESCRIPTION <code>Callable[..., NDArray]</code> <p>A function that returns the cross-power spectral density as a function of the frequency in Hz.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def omega2cross(omega_hh: Callable[..., NDArray], ceffyl : bool = False) -&gt; Callable[..., NDArray]:\n\"\"\"Convert GW energy density.\n    Converts the GW energy density as a fraction of the closure density into the cross-power spectral density\n    as a function of the frequency in Hz. This is intended to be used as a decorator on a function that returns\n    the GW energy density as a fraction of the closure density.\n    Parameters\n    ----------\n    omega_hh : Callable[..., NDArray]\n        The function that returns the GW energy density as a fraction of the closure density.\n    ceffyl: bool\n        If set to tru use a version compatible with ceffyl, if set to false a version compatible with \n        ENTERPRISE\n    Returns\n    -------\n    Callable[..., NDArray]\n        A function that returns the cross-power spectral density as a function of the frequency in Hz.\n    \"\"\"\nif ceffyl:\n@function\ndef cross(f: NDArray, Tspan: float, **kwargs):\n# fraction of the critical density in GWs\nh2_omega = omega_hh(f, **kwargs)\n# characteristic strain spectrum h_c(f)\nhcf = H_0_Hz / h * np.sqrt(3 * h2_omega / 2) / (np.pi * f)\n# cross-power spectral density S(f) (s^3)\nsf = (hcf**2 / (12 * np.pi**2 * f**3)) / Tspan\nreturn sf\nelse:\n@function\ndef cross(f: NDArray, components: int = 2, **kwargs):\ndf = np.diff(np.concatenate((np.array([0]), f[::components])))\n# fraction of the critical density in GWs\nh2_omega = omega_hh(f, **kwargs)\n# characteristic strain spectrum h_c(f)\nhcf = H_0_Hz / h * np.sqrt(3 * h2_omega / 2) / (np.pi * f)\n# cross-power spectral density S(f) (s^3)\nsf = (hcf**2 / (12 * np.pi**2 * f**3)) * np.repeat(df, components)\nreturn sf\nreturn cross\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.prep_data","title":"prep_data","text":"<pre><code>prep_data(\npath: str,\n) -&gt; tuple[list[NDArray], NDArray, NDArray]\n</code></pre> <p>Shape tabulated data into a form that can be handled by <code>interpn</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the tabulated data file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>grids</code> <p>The grids of the tabulated data.</p> <p> TYPE: <code>list[NDArray]</code> </p> <code>omega_grid</code> <p>The omega grid of the tabulated data.</p> <p> TYPE: <code>NDArray</code> </p> <code>par_names</code> <p>The names of the parameters in the tabulated data.</p> <p> TYPE: <code>NDArray</code> </p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def prep_data(path: str) -&gt; tuple[list[NDArray], NDArray, NDArray]:\n\"\"\"Shape tabulated data into a form that can be handled by `interpn`.\n    Parameters\n    ----------\n    path : str\n        Path to the tabulated data file.\n    Returns\n    -------\n    grids : list[NDArray]\n        The grids of the tabulated data.\n    omega_grid : NDArray\n        The omega grid of the tabulated data.\n    par_names : NDArray\n        The names of the parameters in the tabulated data.\n    \"\"\"\npar_names = np.loadtxt(path, max_rows=1, dtype='str')\ndata = np.loadtxt(path, skiprows=1)\nspec_col = np.where(par_names=='spectrum')\nomega_grid = data.T[spec_col][0]\ndata = np.delete(data, spec_col, axis=1)\npar_names = np.delete(par_names, spec_col)\ngrids = [np.unique(row) for row in data.T]\nfor idx, par in enumerate(par_names):\nomega_grid = omega_grid[data[:, -idx -1].argsort(kind=\"mergesort\")]\ndata = data[data[:, -idx -1].argsort(kind=\"mergesort\")]\ngrid_size = [len(x) for x in grids]\nomega_grid = omega_grid.reshape(tuple(grid_size))\nreturn grids, omega_grid, par_names\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.spec_importer","title":"spec_importer","text":"<pre><code>spec_importer(\npath: str,\n) -&gt; Callable[[NDArray, Any], NDArray]\n</code></pre> <p>Import data and create a fast interpolation function.</p> <p>Interpolate the GWB power spectrum from tabulated data. Return a function that interpolates over frequency.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the tabulated data file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Callable[[NDArray, P], NDArray]</code> <p>A callable object that interpolates the GWB power spectrum at a given frequency <code>f</code> and with given parameters <code>kwargs</code>.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def spec_importer(path: str) -&gt; Callable[[NDArray, Any],  NDArray]:\n\"\"\"Import data and create a fast interpolation function.\n    Interpolate the GWB power spectrum from tabulated data. Return a function that interpolates\n    over frequency.\n    Parameters\n    ----------\n    path : str\n        Path to the tabulated data file.\n    Returns\n    -------\n    Callable[[NDArray, P], NDArray]\n        A callable object that interpolates the GWB power spectrum at a given frequency `f` and with given\n        parameters `kwargs`.\n    \"\"\"\ninfo, data = fast_interpolate.load_data(path)\n# info is a list of (name, start, step)\ndef spectrum(f: NDArray, **kwargs: Any) -&gt; NDArray:\n# Construct right information format for interpolation\nreturn fast_interpolate.interp([(start, step, f if name == 'f' else kwargs[name])\nfor (name, start, step) in info],\ndata)\nreturn spectrum # type: ignore\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.freq_at_temp","title":"freq_at_temp","text":"<pre><code>freq_at_temp(T: array_like) -&gt; array_like\n</code></pre> <p>Find frequency today as function of temperature when GW was horizon size.</p> <p>Calculates the GW frequency [Hz] today as a function of the universe temperature [GeV] when the GW was of horizon size.</p> PARAMETER DESCRIPTION <code>T</code> <p>The universe temperature [GeV] at the time when the GW was of horizon size.</p> <p> TYPE: <code>array_like</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>The GW frequency [Hz] today that was of horizon size when the universe was at temperature <code>T</code> [GeV].</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def freq_at_temp(T: array_like) -&gt; array_like:\n\"\"\"Find frequency today as function of temperature when GW was horizon size.\n    Calculates the GW frequency [Hz] today as a function of the universe temperature [GeV]\n    when the GW was of horizon size.\n    Parameters\n    ----------\n    T : array_like\n        The universe temperature [GeV] at the time when the GW was of horizon size.\n    Returns\n    -------\n    NDArray\n        The GW frequency [Hz] today that was of horizon size when the universe was at temperature `T` [GeV].\n    \"\"\"\nf_0 = H_0_Hz / (2 * np.pi)\nT_ratio = T_0 / T # type: ignore\ng_ratio = g_rho_0 / g_rho(T) # type: ignore\ngs_ratio = g_s_0 / g_s(T) # type: ignore\nprefactor = f_0 * (gs_ratio) ** (1 / 3) * T_ratio\nsqr_term = np.sqrt(\nomega_v\n+ (gs_ratio**-1 * T_ratio**-3 * omega_m)\n+ (g_ratio**-1 * T_ratio**-4 * omega_r)\n)\nreturn prefactor * sqr_term\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.temp_at_freq","title":"temp_at_freq","text":"<pre><code>temp_at_freq(f: array_like) -&gt; NDArray\n</code></pre> <p>Get the temperature [GeV] of the universe when a gravitational wave of a certain frequency [Hz] today was of horizon size.</p> PARAMETER DESCRIPTION <code>f</code> <p>The frequency in Hz today.</p> <p> TYPE: <code>array_like</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>The temperature [GeV] when the GW at frequency <code>f</code> [Hz] was of horizon size.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def temp_at_freq(f: array_like) -&gt; NDArray:\n\"\"\"Get the temperature [GeV] of the universe when a gravitational wave of a\n    certain frequency [Hz] today was of horizon size.\n    Parameters\n    ----------\n    f : array_like\n        The frequency in Hz today.\n    Returns\n    -------\n    NDArray\n        The temperature [GeV] when the GW at frequency `f` [Hz] was of horizon size.\n    \"\"\"\nreturn np.interp(f, gs[:, 1], gs[:, 0], left=np.nan, right=np.nan)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.prior","title":"prior","text":"<pre><code>prior(\nname: priors_type, *args: Any, **kwargs: Any\n) -&gt; parameter.Parameter\n</code></pre> <p>Wrap enterprise prior creation.</p> <p>This function wraps the class factories in enterprise.signals.parameter. It functions exactly the same as the original, except that it accepts additional <code>kwargs</code> and sets an additional attribute <code>common</code>. This attribute refers to whether the parameter this prior corresponds to is common to all pulsars. In the original implementation in enterprise, the way that this works is ambiguous. With this function, it is explicit. If the user does not pass <code>common=False</code> as a <code>kwarg</code>, then <code>common</code> defaults to <code>True</code>. This attribute will be used by ptarcade.models_utils.ParamDict objects in the model files.</p> PARAMETER DESCRIPTION <code>name</code> <p>The prior to use.</p> <p> TYPE: <code>priors_type</code> </p> <code>*args</code> <p>Positional arguments passed to the prior factory.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>kwargs passed to the prior factory.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>prior</code> <p>The configured prior.</p> <p> TYPE: <code>parameter.Parameter</code> </p> RAISES DESCRIPTION <code>SystemExit</code> <p>If the prior name passed does not exist within [enterprise.signals.parameter]</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def prior(name: priors_type, *args: Any, **kwargs: Any) -&gt; parameter.Parameter:\n\"\"\"Wrap enterprise prior creation.\n    This function wraps the class factories in [enterprise.signals.parameter][].\n    It functions exactly the same as the original, except that it accepts additional\n    `kwargs` and sets an additional attribute `common`. This attribute refers to\n    whether the parameter this prior corresponds to is common to all pulsars. In the\n    original implementation in enterprise, the way that this works is ambiguous. With\n    this function, it is explicit. If the user does not pass `common=False` as a `kwarg`,\n    then `common` defaults to `True`. This attribute will be used by\n    [ptarcade.models_utils.ParamDict][] objects in the model files.\n    Parameters\n    ----------\n    name : priors_type\n        The prior to use.\n    *args\n        Positional arguments passed to the prior factory.\n    **kwargs\n        kwargs passed to the prior factory.\n    Returns\n    -------\n    prior : parameter.Parameter\n        The configured prior.\n    Raises\n    ------\n    SystemExit\n        If the prior name passed does not exist within [enterprise.signals.parameter]\n    \"\"\"\n# If \"common\" is passed as kwarg, remove it from the kwarg dictionary and store it.\n# If it wasn't passed, set it to True\ncommon = kwargs.pop(\"common\", True)\n# Check if the user passed a correct prior name.\n# If they didn't, print an informative message\ntry:\nprior_factory = getattr(parameter, name)\nexcept AttributeError:\ntry:\nprior_factory = globals()[name]\nexcept KeyError:\nerr = (f\"The 'name' must be a string from the following list {priors_type=}.\\n\"\nf\"You supplied {name=}.\")\nlog.error(err)\nraise SystemExit from None\n# Use enterprise's class factory\nprior_obj = prior_factory(*args, **kwargs)\n# Store the `common` arg for later use\nprior_obj.common = common\nreturn prior_obj\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/","title":"plot_utils","text":"<p>Utilities for plotting.</p> ATTRIBUTE DESCRIPTION <code>colors</code> <p>list of colors used in plotting</p> <p> TYPE: <code>list[str]</code> </p> <code>plt_params</code> <p>Plotting parameters to use in plotting functions</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils-classes","title":"Classes","text":""},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.bcolors","title":"bcolors  <code>dataclass</code>","text":"<p>Class to hold ANSI escape sequences.</p> ATTRIBUTE DESCRIPTION <code>WARNING</code> <p> TYPE: <code>str</code> </p> <code>FAIL</code> <p> TYPE: <code>str</code> </p> <code>ENDC</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>@dataclass(frozen=True)\nclass bcolors:\n\"\"\"Class to hold ANSI escape sequences.\n    Attributes\n    ----------\n    WARNING : str\n    FAIL : str\n    ENDC : str\n    \"\"\"\nWARNING: str = \"\\033[0;33m\"\nFAIL: str = '\\033[0;31m'\nENDC: str = '\\033[0m'\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils-functions","title":"Functions","text":""},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.set_size","title":"set_size","text":"<pre><code>set_size(\nwidth: float,\nfraction: int = 1,\nratio: float | None = None,\nsubplots: tuple[int, int] = (1, 1),\n) -&gt; tuple[float, float]\n</code></pre> <p>Set figure dimensions to avoid scaling in LaTeX.</p> PARAMETER DESCRIPTION <code>width</code> <p>Document textwidth or columnwidth in pts</p> <p> TYPE: <code>float</code> </p> <code>fraction</code> <p>Fraction of the width which you wish the figure to occupy, by default 1</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>1</code> </p> <code>ratio</code> <p>Ratio of the height to width of the figure. If None, the golden ratio (sqrt(5)-1)/2 is used, by default None</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>None</code> </p> <code>subplots</code> <p>The number of rows and columns of subplots in the figure, by default (1, 1)</p> <p> TYPE: <code>tuple[int], optional</code> DEFAULT: <code>(1, 1)</code> </p> RETURNS DESCRIPTION <code>fig_dim</code> <p>Dimensions of figure in inches. The dimensions are calculated based on the parameters, and the height is further adjusted based on the number of subplots.</p> <p> TYPE: <code>tuple</code> </p> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>def set_size(width: float,\nfraction: int = 1,\nratio: float | None = None,\nsubplots: tuple[int, int] = (1, 1)) -&gt; tuple[float, float]:\n\"\"\"Set figure dimensions to avoid scaling in LaTeX.\n    Parameters\n    ----------\n    width : float\n        Document textwidth or columnwidth in pts\n    fraction : float, optional\n        Fraction of the width which you wish the figure to occupy, by default 1\n    ratio : float, optional\n        Ratio of the height to width of the figure. If None, the golden ratio (sqrt(5)-1)/2 is used,\n        by default None\n    subplots : tuple[int], optional\n        The number of rows and columns of subplots in the figure, by default (1, 1)\n    Returns\n    -------\n    fig_dim : tuple\n        Dimensions of figure in inches. The dimensions are calculated based on the parameters, and\n        the height is further adjusted based on the number of subplots.\n    \"\"\"\nfig_width_pt = width * fraction\ninches_per_pt = 1 / 72.27\nfig_width_in = fig_width_pt * inches_per_pt\nif not ratio:\nratio = (5**0.5 - 1) / 2\nfig_height_in = fig_width_in * ratio * (subplots[0] / subplots[1])\nfig_dim = (fig_width_in, fig_height_in)\nreturn fig_dim\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.set_custom_tick_options","title":"set_custom_tick_options","text":"<pre><code>set_custom_tick_options(\nax: plt.axis,\nleft: bool = True,\nright: bool = True,\nbottom: bool = True,\ntop: bool = True,\nlabel_size: int = 8,\nwidth: float = 0.5,\nlength: float = 3.5,\n)\n</code></pre> <p>Sets custom tick options for a matplotlib axis.</p> PARAMETER DESCRIPTION <code>ax</code> <p>The axis to which the tick options will be applied.</p> <p> TYPE: <code>matplotlib.pyplot.axis</code> </p> <code>left</code> <p>If True, left ticks will be visible. Default is True.</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>True</code> </p> <code>right</code> <p>If True, right ticks will be visible. Default is True.</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>True</code> </p> <code>bottom</code> <p>If True, bottom ticks will be visible. Default is True.</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>True</code> </p> <code>top</code> <p>If True, top ticks will be visible. Default is True.</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>True</code> </p> <code>label_size</code> <p>Controls the font size for ticks labels. Default is 8.</p> <p> TYPE: <code>int, optional</code> DEFAULT: <code>8</code> </p> <code>width</code> <p>Sets the width of the ticks. Default is 0.5.</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>0.5</code> </p> <code>length</code> <p>Sets the length of the ticks. Default is 3.5.</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>3.5</code> </p> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>def set_custom_tick_options(\nax: plt.axis,\nleft: bool = True,\nright: bool = True,\nbottom: bool = True,\ntop: bool = True,\nlabel_size: int = 8,\nwidth: float = 0.5,\nlength: float = 3.5,\n):\n\"\"\"\n    Sets custom tick options for a matplotlib axis.\n    Parameters\n    ----------\n    ax : matplotlib.pyplot.axis\n        The axis to which the tick options will be applied.\n    left : bool, optional\n        If True, left ticks will be visible. Default is True.\n    right : bool, optional\n        If True, right ticks will be visible. Default is True.\n    bottom : bool, optional\n        If True, bottom ticks will be visible. Default is True.\n    top : bool, optional\n        If True, top ticks will be visible. Default is True.\n    label_size : int, optional\n        Controls the font size for ticks labels. Default is 8.\n    width : float, optional\n        Sets the width of the ticks. Default is 0.5.\n    length : float, optional\n        Sets the length of the ticks. Default is 3.5.\n    Returns\n    -------\n    None\n    \"\"\"\nax.minorticks_on()\nax.tick_params(\nwhich=\"major\",\ndirection=\"in\",\nlength=length,\nwidth=width,\nbottom=bottom,\ntop=top,\nleft=left,\nright=right,\nlabelsize=label_size,\npad=2,\n)\nax.tick_params(\nwhich=\"minor\",\ndirection=\"in\",\nlength=length / 2,\nwidth=width,\nbottom=bottom,\ntop=top,\nleft=left,\nright=right,\nlabelsize=label_size,\npad=2,\n)\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.plot_chains","title":"plot_chains","text":"<pre><code>plot_chains(\nchain: NDArray,\nparams: list[str],\nparams_name: dict[str, str] = None,\nlabel_size: int = 13,\nsave: bool = False,\nmodel_name: str | None = None,\n) -&gt; None\n</code></pre> <p>Plot the MCMC (Markov chain Monte Carlo) chain for the parameters specified by params.</p> PARAMETER DESCRIPTION <code>chain</code> <p>A numpy array containing the MCMC chain to be plotted. Each row corresponds to a step in the chain, and each column corresponds to a parameter.</p> <p> TYPE: <code>numpy.ndarray</code> </p> <code>params</code> <p>A list with the names of the parameters appearing in the chain.</p> <p> TYPE: <code>list of str</code> </p> <code>params_name</code> <p>A dictionary with keys being the names of the parameters in the params list to be plotted, and values being the formatted parameters name to be shown in the plots. Default is None, which plots all the common parameters + the MCMC parameters without any formatting.</p> <p> TYPE: <code>dict, optional</code> DEFAULT: <code>None</code> </p> <code>label_size</code> <p>Controls the font size for the axis and ticks labels. Default is 13.</p> <p> TYPE: <code>int, optional</code> DEFAULT: <code>13</code> </p> <code>save</code> <p>If set to True, the plot is saved in the folder \"./plots/\". Default is False.</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>False</code> </p> <code>model_name</code> <p>A string with the model name. Used to name the output files. Default is None.</p> <p> TYPE: <code>str, optional</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> RAISES DESCRIPTION <code>Warning</code> <p>If some of the requested parameters do not appear in the parameter list.</p> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>def plot_chains(\nchain: NDArray,\nparams: list[str],\nparams_name: dict[str, str] = None,\nlabel_size: int = 13,\nsave: bool = False,\nmodel_name: str | None = None,\n) -&gt; None:\n\"\"\"\n    Plot the MCMC (Markov chain Monte Carlo) chain for the parameters specified by params.\n    Parameters\n    ----------\n    chain : numpy.ndarray\n        A numpy array containing the MCMC chain to be plotted.\n        Each row corresponds to a step in the chain, and each column corresponds to a parameter.\n    params : list of str\n        A list with the names of the parameters appearing in the chain.\n    params_name : dict, optional\n        A dictionary with keys being the names of the parameters in the params list to be plotted,\n        and values being the formatted parameters name to be shown in the plots.\n        Default is None, which plots all the common parameters + the MCMC parameters without any formatting.\n    label_size : int, optional\n        Controls the font size for the axis and ticks labels. Default is 13.\n    save : bool, optional\n        If set to True, the plot is saved in the folder \"./plots/\". Default is False.\n    model_name : str, optional\n        A string with the model name. Used to name the output files. Default is None.\n    Returns\n    -------\n    None\n    Raises\n    ------\n    Warning\n        If some of the requested parameters do not appear in the parameter list.\n    \"\"\"\nplt.rcParams.update(plt_params)\nparams_dic = {}\nif params_name:\nfor idx, par in enumerate(params):\nif par in params_name.keys():\nformatted_name = params_name[par]\nparams_dic[formatted_name] = idx\nif len(params_dic) != len(params_name):\nlog.warning(\n\"Some of the requested parameters does not appear in the parameter list\"\nf\"You suppplied {params_dic=} but {params_name=}\"\n)\nelse:\nfor idx, par in enumerate(params):\nif \"+\" not in par and \"-\" not in par and \"n_parall\" not in par:\nkey = par.replace(\"_\", \"\\_\")\nkey = rf\"$\\mathrm{{{key}}}$\"\nparams_dic[key] = idx\nn_par = len(params_dic)\nn_row = int(n_par**0.5)\nn_col = int(math.ceil(n_par / float(n_row)))\nfig, axs = plt.subplots(n_row, n_col, figsize=(5 * n_col, 2.5 * n_row), sharex=True)\nif n_par == 1:\naxs = np.array([axs])\nfor idx, (ax, key) in enumerate(zip(axs.reshape(-1), params_dic)):\nax.plot(chain[:, params_dic[key]])\nset_custom_tick_options(ax, label_size=label_size)\nax.set_ylabel(f\"{key}\", fontsize=label_size)\nfor ax in axs[-1]:\nax.set_xlabel(\"$\\mathrm{MCMC\\;sample}$\", fontsize=label_size)\nplt.tight_layout()\nif save:\nif model_name:\nplt.savefig(f\"./plots/{model_name}_chains.pdf\")\nelse:\nprint(\"Please specify a model name to save the chain plot.\")\nplt.show()\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.create_ax_labels","title":"create_ax_labels","text":"<pre><code>create_ax_labels(\npar_names: list[str], labelsize: int = 8\n) -&gt; None\n</code></pre> <p>Format the axes for posterior plots.</p> <p>This function fetches the current figure and all its axes, sets custom tick options and labels for all axes according to the names of the parameters.</p> PARAMETER DESCRIPTION <code>par_names</code> <p>A list of names of the parameters for each of the axes.</p> <p> TYPE: <code>list[str]</code> </p> <code>labelsize</code> <p>The font size of the labels. Default is 8. If there is only one parameter, this value is set to 12.</p> <p> TYPE: <code>int, optional</code> DEFAULT: <code>8</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.create_ax_labels--notes","title":"Notes","text":"<ul> <li>The function assumes that the number of axes in the current figure matches the   number of parameter names provided. If this is not the case, the behavior is undefined.</li> <li>A label with the name 'A' and alpha=0 is set for the y-axis in the case of a single parameter   to prevent padding issues.</li> </ul> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>def create_ax_labels(par_names: list[str], labelsize: int = 8) -&gt; None:\n\"\"\"Format the axes for posterior plots.\n    This function fetches the current figure and all its axes, sets custom tick options\n    and labels for all axes according to the names of the parameters.\n    Parameters\n    ----------\n    par_names : list[str]\n        A list of names of the parameters for each of the axes.\n    labelsize : int, optional\n        The font size of the labels. Default is 8. If there is only one parameter,\n        this value is set to 12.\n    Returns\n    -------\n    None\n    Notes\n    -----\n    - The function assumes that the number of axes in the current figure matches the\n      number of parameter names provided. If this is not the case, the behavior is undefined.\n    - A label with the name 'A' and alpha=0 is set for the y-axis in the case of a single parameter\n      to prevent padding issues.\n    \"\"\"\n# small_font = 5\nN_params = len(par_names)\nf = plt.gcf()\naxs = f.get_axes()\nif N_params == 1:\nlabelsize = 12\nset_custom_tick_options(axs[0], width=0.5, length=5, label_size=labelsize)\naxs[0].set_xlabel(par_names[0], fontsize=labelsize, labelpad=10)\naxs[0].set_ylabel(\"A\", alpha=0)  # here just ot prevent padding issues\nreturn\n# do this loop using combinations_with_replacement from itertools\nfor idx in range(N_params):\nfor idy in range(N_params - idx):\nid = int(N_params * idx + idy - max(idx * (idx - 1) / 2, 0))\nset_custom_tick_options(axs[id], width=0.5, label_size=labelsize)\nif idx == 0 and idy == 0:\nset_custom_tick_options(axs[id], width=0.5, label_size=labelsize)\naxs[id].set_xlabel(par_names[idx], fontsize=labelsize, labelpad=7)\naxs[id].set_ylabel(par_names[N_params - idy - 1], fontsize=labelsize)\nelif idx == N_params - 1:\nset_custom_tick_options(axs[id], left=False, right=False, width=0.5, label_size=labelsize)\naxs[id].set_xlabel(par_names[idx], fontsize=labelsize, labelpad=7)\nelif idy == N_params - idx - 1:\nset_custom_tick_options(axs[id], left=False, right=False, width=0.5, label_size=labelsize)\nelif idx == 0:\nset_custom_tick_options(axs[id], width=0.5, label_size=labelsize)\naxs[id].set_ylabel(par_names[N_params - idy - 1], fontsize=labelsize)\nelif idy == 0:\nset_custom_tick_options(axs[id], width=0.5, label_size=labelsize)\naxs[id].set_xlabel(par_names[idx], fontsize=labelsize, labelpad=7)\nelse:\nset_custom_tick_options(axs[id], width=0.5, label_size=labelsize)\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.level_to_sigma","title":"level_to_sigma","text":"<pre><code>level_to_sigma(level: float) -&gt; float\n</code></pre> <p>Convert confidence level to standard deviation (sigma).</p> <p>This function uses the inverse of the cumulative distribution function (CDF) for a normal distribution to convert a confidence level to the equivalent number of standard deviations (sigma).</p> PARAMETER DESCRIPTION <code>level</code> <p>The confidence level to convert. This should be a fraction between 0 and 1.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The number of standard deviations corresponding to the provided confidence level.</p> RAISES DESCRIPTION <code>SystemExit</code> <p>If the provided level is not between 0 and 1.</p> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>def level_to_sigma(level: float) -&gt; float:\n\"\"\"Convert confidence level to standard deviation (sigma).\n    This function uses the inverse of the cumulative distribution function (CDF) for a\n    normal distribution to convert a confidence level to the equivalent number of\n    standard deviations (sigma).\n    Parameters\n    ----------\n    level : float\n        The confidence level to convert. This should be a fraction between 0 and 1.\n    Returns\n    -------\n    float\n        The number of standard deviations corresponding to the provided confidence level.\n    Raises\n    ------\n    SystemExit\n        If the provided level is not between 0 and 1.\n    \"\"\"\nif 0 &lt; level &lt; 1:\nreturn np.sqrt(-2 * np.log(1-level))\nelse:\nerror = (\"The level value needs to be between 0 and 1.\")\nlog.error(error)\nraise SystemExit\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.plot_bhb_prior","title":"plot_bhb_prior","text":"<pre><code>plot_bhb_prior(\nplot: matplotlib.figure.Figure,\nbhb_prior: str,\nlevels: list[float],\n) -&gt; None\n</code></pre> <p>Plot the prior distribution for SMBHB signal.</p> PARAMETER DESCRIPTION <code>plot</code> <p>The plot object to which the priors will be added. This object should have methods <code>get_axes_for_params(param1, param2)</code> that return the Axes object for the given parameters.</p> <p> TYPE: <code>matplotlib.figure.Figure</code> </p> <code>bhb_prior</code> <p>The specific BHB prior to be used, choices are \"NG15\" and \"IPTA2\".</p> <p> TYPE: <code>str</code> </p> <code>levels</code> <p>A list of threshold levels. The sigma equivalent of these levels will be plotted.</p> <p> TYPE: <code>list of float</code> </p> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>def plot_bhb_prior(plot: matplotlib.figure.Figure, bhb_prior: str, levels: list[float]) -&gt; None:\n\"\"\"Plot the prior distribution for SMBHB signal.\n    Parameters\n    ----------\n    plot : matplotlib.figure.Figure\n        The plot object to which the priors will be added.\n        This object should have methods `get_axes_for_params(param1, param2)` that return the Axes\n        object for the given parameters.\n    bhb_prior : str\n        The specific BHB prior to be used, choices are \"NG15\" and \"IPTA2\".\n    levels : list of float\n        A list of threshold levels. The sigma equivalent of these levels will be plotted.\n    Returns\n    -------\n    None\n    \"\"\"\nsigmas = [level_to_sigma(level) for level in levels]\nif bhb_prior == \"NG15\":\nmu = np.array([-15.61492963, 4.70709637])\ncov = np.array([[0.27871359, -0.00263617], [-0.00263617, 0.12415383]])\nelif bhb_prior == \"IPTA2\":\nmu = np.array([-15.02928454, 4.14290127])\ncov = np.array([[0.06869369, 0.00017051], [0.00017051, 0.04681747]])\nA_0, gamma_0 = mu\neig = np.linalg.eig(np.linalg.inv(cov))\na, b = eig[0]\nR_rot = eig[1]\nt = np.linspace(0, 2 * np.pi, 100)\nEll = -np.array([(a) ** (-1 / 2) * np.cos(t), (b) ** (-1 / 2) * np.sin(t)])\nEll_rot = np.zeros((len(sigmas), 2, Ell.shape[1]))\nfor idx, sigma in enumerate(sigmas):\nEll_rot[idx, :, :] = np.dot(R_rot, sigma * Ell)\nlw = 0.5\nax_0 = plot.get_axes_for_params(\"gw-bhb-0\")\nax_1 = plot.get_axes_for_params(\"gw-bhb-1\")\nif ax_0 and ax_1:\nA_pts = np.arange(-17, -13, 0.001)\ng_pts = np.arange(2, 6, 0.001)\nax_0.plot(A_pts, norm.pdf(A_pts, mu[0], cov[0, 0] ** (1 / 2)), color=\"black\", linestyle=\"dashed\", linewidth=lw)\nax_1.plot(g_pts, norm.pdf(g_pts, mu[1], cov[1, 1] ** (1 / 2)), color=\"black\", linestyle=\"dashed\", linewidth=lw)\nfor idx in range(len(sigmas)):\nax = plot.get_axes_for_params(\"gw-bhb-0\", \"gw-bhb-1\")\nif ax:\nax.plot(\nA_0 + Ell_rot[idx, 0, :],\ngamma_0 + Ell_rot[idx, 1, :],\ncolor=\"black\",\nlinestyle=\"dashed\",\nlinewidth=lw,\nalpha=0.9,\n)\nax = plot.get_axes_for_params(\"gw-bhb-1\", \"gw-bhb-0\")\nif ax:\nax.plot(\ngamma_0 + Ell_rot[idx, 1, :],\nA_0 + Ell_rot[idx, 0, :],\n\"black\",\nlinestyle=\"dashed\",\nlinewidth=lw,\nalpha=0.9,\n)\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.corner_plot_settings","title":"corner_plot_settings","text":"<pre><code>corner_plot_settings(\nlevels: list[float] | None,\nsamples: list[MCSamples],\none_column: bool,\nlegend_size: int = 12,\nfig_width_pt: float | None = None,\n) -&gt; plots.GetDistPlotSettings\n</code></pre> <p>Configure the settings for corner plots.</p> PARAMETER DESCRIPTION <code>levels</code> <p>The list of confidence levels for which the HPI should be computed. Each value in the list should be between 0 and 1. Default is None.</p> <p> TYPE: <code>list[float], optional</code> </p> <code>samples</code> <p>A list of instances of the MCSamples class, each containing multivariate Monte Carlo samples on which the function is operating.</p> <p> TYPE: <code>list[MCSamples]</code> </p> <code>one_column</code> <p>Whether to set the figure width for a one-column format. If False, a wider format is used.</p> <p> TYPE: <code>bool</code> </p> <code>legend_size</code> <p>Sets the font size of the legend captions. Default is 12.</p> <p> TYPE: <code>int, optional</code> DEFAULT: <code>12</code> </p> <code>fig_width_pt</code> <p>If provided, the figure width in points. This parameter can be used to override the default figure widths for one- or two-column formats. Default is None.</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>plots.GetDistPlotSettings</code> <p>An instance of the GetDistPlotSettings class, with the corner plot settings configured as specified.</p> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>def corner_plot_settings(\nlevels: list[float] | None,\nsamples: list[MCSamples],\none_column: bool,\nlegend_size: int = 12,\nfig_width_pt: float | None = None,\n) -&gt; plots.GetDistPlotSettings:\n\"\"\"Configure the settings for corner plots.\n    Parameters\n    ----------\n    levels : list[float], optional\n        The list of confidence levels for which the HPI should be computed.\n        Each value in the list should be between 0 and 1. Default is None.\n    samples : list[MCSamples]\n        A list of instances of the MCSamples class, each containing\n        multivariate Monte Carlo samples on which the function is operating.\n    one_column : bool\n        Whether to set the figure width for a one-column format. If False,\n        a wider format is used.\n    legend_size : int, optional\n        Sets the font size of the legend captions.\n        Default is 12.\n    fig_width_pt : float, optional\n        If provided, the figure width in points. This parameter can be used\n        to override the default figure widths for one- or two-column formats.\n        Default is None.\n    Returns\n    -------\n    plots.GetDistPlotSettings\n        An instance of the GetDistPlotSettings class, with the corner plot\n        settings configured as specified.\n    \"\"\"\nsets = plots.GetDistPlotSettings()\nsets.prob_y_ticks = False\nsets.figure_legend_loc = \"upper right\"\nsets.norm_1d_density = \"integral\"\nsets.alpha_filled_add = 0.8\nsets.legend_fontsize = legend_size\nsets.linewidth = 2.35\nif fig_width_pt:\nsets.fig_width_inch = set_size(fig_width_pt, ratio=1)[0]\nelif one_column:\nsets.fig_width_inch = set_size(246, ratio=1)[0]\nelse:\nsets.fig_width_inch = set_size(510, ratio=1, fraction=0.65)[0]\nif levels is not None:\nsets.num_plot_contours = len(levels)\nfor sample in samples:\nsample.updateSettings({\"contours\": levels})\nreturn sets\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.oned_plot_settings","title":"oned_plot_settings","text":"<pre><code>oned_plot_settings(\nlegend_size: int = 9,\n) -&gt; plots.GetDistPlotSettings\n</code></pre> <p>Configure the settings for one-dimensional (1D) plots.</p> PARAMETER DESCRIPTION <code>legend_size</code> <p>The size for the legend font.</p> <p> TYPE: <code>int, optional</code> DEFAULT: <code>9</code> </p> RETURNS DESCRIPTION <code>plots.GetDistPlotSettings</code> <p>An instance of the GetDistPlotSettings class, with the 1D plot settings configured as specified.</p> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>def oned_plot_settings(legend_size: int = 9) -&gt; plots.GetDistPlotSettings:\n\"\"\"Configure the settings for one-dimensional (1D) plots.\n    Parameters\n    ----------\n    legend_size : int, optional\n        The size for the legend font.\n    Returns\n    -------\n    plots.GetDistPlotSettings\n        An instance of the GetDistPlotSettings class, with the 1D plot\n        settings configured as specified.\n    \"\"\"\nsets = plots.GetDistPlotSettings()\nsets.legend_fontsize = legend_size\nsets.prob_y_ticks = False\nsets.linewidth = 1.1\nsets.figure_legend_loc = \"upper right\"\nsets.norm_1d_density = \"integral\"\nsets.line_styles = colors\nreturn sets\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.plot_k_bounds","title":"plot_k_bounds","text":"<pre><code>plot_k_bounds(\nplot: plots.GetDistPlotter.triangle_plot,\nsamples: list[MCSamples],\nk_levels: list[NDArray],\n) -&gt; None\n</code></pre> <p>Add the k-ratio bounds to an existing plot.</p> PARAMETER DESCRIPTION <code>plot</code> <p>The plot to which the k-ratio bounds should be added.</p> <p> TYPE: <code>plots.GetDistPlotter.triangle_plot</code> </p> <code>samples</code> <p>A list of instances of the MCSamples class, each containing multivariate Monte Carlo samples on which the function is operating.</p> <p> TYPE: <code>list[MCSamples]</code> </p> <code>k_levels</code> <p>A list of 1D or 2D arrays representing the K-ratio bounds for each sample. Each array should contain the parameter names and corresponding K-ratio bound.</p> <p> TYPE: <code>list[array_like]</code> </p> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>def plot_k_bounds(\nplot: plots.GetDistPlotter.triangle_plot,\nsamples: list[MCSamples],\nk_levels: list[NDArray],\n) -&gt; None:\n\"\"\"Add the k-ratio bounds to an existing plot.\n    Parameters\n    ----------\n    plot : plots.GetDistPlotter.triangle_plot\n        The plot to which the k-ratio bounds should be added.\n    samples : list[MCSamples]\n        A list of instances of the MCSamples class, each containing\n        multivariate Monte Carlo samples on which the function is operating.\n    k_levels : list[array_like]\n        A list of 1D or 2D arrays representing the K-ratio bounds for\n        each sample. Each array should contain the parameter names and\n        corresponding K-ratio bound.\n    Returns\n    -------\n    None\n    \"\"\"\nfor idx, sample in enumerate(samples):\nif k_levels[idx]:\nfor x in k_levels[idx][0]:\nif x[-1]:\npar = x[0]\np0 = float(x[-1])\nif len(k_levels[idx][0]) == 1:\nplt.plot(\n[p0, p0], [0, 10], color=colors[idx], alpha=0.8, lw=0.8)\nelse:\nax = plot.get_axes_for_params(par)\nax.plot([p0, p0], [0, 10], color=colors[idx], alpha=0.8, lw=0.8)\nfor x in k_levels[idx][1]:\npar_1 = x[0]\npar_2 = x[1]\nlevel = float(x[-1])\npar_1, par_2 = plot.get_param_array(sample, [par_1, par_2])\nax = plot.get_axes_for_params(par_1, par_2)\ndensity = plot.sample_analyser.get_density_grid(\nsample,\npar_1,\npar_2,\nconts=plot.settings.num_plot_contours,\nlikes=plot.settings.shade_meanlikes)\nlevels = sorted(np.append([density.P.max() + 1], level))\ncs = ax.contourf(\ndensity.x,\ndensity.y,\ndensity.P,\nlevels,\ncolors=\"#ffffff00\",\nalpha=0.14,\nextend=\"both\")\ncs.cmap.set_over(\"#ffffff00\")\ncs.cmap.set_under(\"gray\")\ncs.changed()\nlevels = sorted(np.append([density.P.max() + 1], level))\nax.contour(\ndensity.x,\ndensity.y,\ndensity.P,\nlevels=[level],\ncolors=\"grey\",\nlinewidths=0.5,\nalpha=1)\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.plot_hpi","title":"plot_hpi","text":"<pre><code>plot_hpi(\nplot: plots.GetDistPlotter.triangle_plot,\nsamples: list[MCSamples],\nhpi_points: list[array_like],\n) -&gt; None\n</code></pre> <p>Add the highest posterior interval (HPI) to an existing plot.</p> PARAMETER DESCRIPTION <code>plot</code> <p>The plot to which the HPI should be added.</p> <p> TYPE: <code>plots.GetDistPlotter.triangle_plot</code> </p> <code>samples</code> <p>A list of instances of the MCSamples class, each containing multivariate Monte Carlo samples on which the function is operating.</p> <p> TYPE: <code>list[MCSamples]</code> </p> <code>hpi_points</code> <p>A list of arrays representing the HPI for each sample. Each array should contain the parameter name and corresponding HPI.</p> <p> TYPE: <code>list[array_like]</code> </p> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>def plot_hpi(\nplot: plots.GetDistPlotter.triangle_plot,\nsamples: list[MCSamples],\nhpi_points: list[array_like],\n) -&gt; None:\n\"\"\"Add the highest posterior interval (HPI) to an existing plot.\n    Parameters\n    ----------\n    plot : plots.GetDistPlotter.triangle_plot\n        The plot to which the HPI should be added.\n    samples : list[MCSamples]\n        A list of instances of the MCSamples class, each containing\n        multivariate Monte Carlo samples on which the function is operating.\n    hpi_points : list[array_like]\n        A list of arrays representing the HPI for each sample. Each array\n        should contain the parameter name and corresponding HPI.\n    Returns\n    -------\n    None\n    \"\"\"\nlw=0.6\nif len(samples) == 1:\nc_adjust = 1\nelse:\nc_adjust = 0\nfor idx, sample in enumerate(samples):\nhpi = hpi_points[idx]\nfor x in hpi:\nfor level in x[1]:\npar = x[0]\nx1 = level[0]\nx2 = level[1]\ndensity = MCSamples.get1DDensity(sample, par)\nif len(hpi) == 1:\nf = plt.gcf()\nax = f.get_axes()[0]\nelse:\nax = plot.get_axes_for_params(par)\nif x1:\np1 = density(x1)[0]\nax.plot([x1, x1], [0, p1], ls = 'dashed', color = colors[idx+c_adjust], lw=lw)\nif x2:\np2 = density(x2)[0]\nax.plot([x2, x2], [0, p2], ls = 'dashed', color = colors[idx+c_adjust], lw=lw)\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.print_stats","title":"print_stats","text":"<pre><code>print_stats(\nk_levels: list[array_like],\nhpi_points: list[array_like],\nbayes_est: list[dict],\nmax_pos: list[dict],\nlevels: list[float],\n) -&gt; None\n</code></pre> <p>Print the statistical summary for each sample.</p> PARAMETER DESCRIPTION <code>k_levels</code> <p>A list of arrays representing the K-ratio bounds for each sample. Each array should contain the parameter name and corresponding K-ratio bound.</p> <p> TYPE: <code>list[array_like]</code> </p> <code>hpi_points</code> <p>A list of arrays representing the highest posterior interval (HPI) for each sample. Each array should contain the parameter name and corresponding HPI.</p> <p> TYPE: <code>list[array_like]</code> </p> <code>bayes_est</code> <p>A list of dictionaries, each containing the Bayes estimator for each parameter in the sample.</p> <p> TYPE: <code>list[dict]</code> </p> <code>max_pos</code> <p>A list of dictionaries, each containing the maximum posterior value for each parameter in the sample.</p> <p> TYPE: <code>list[dict]</code> </p> <code>levels</code> <p>The list of confidence levels for which the HPI should be computed. Each value in the list should be between 0 and 1.</p> <p> TYPE: <code>list[float]</code> </p> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>def print_stats(\nk_levels: list[array_like],\nhpi_points: list[array_like],\nbayes_est: list[dict],\nmax_pos:list[dict],\nlevels:list[float],\n) -&gt; None:\n\"\"\"Print the statistical summary for each sample.\n    Parameters\n    ----------\n    k_levels : list[array_like]\n        A list of arrays representing the K-ratio bounds for each sample. Each array\n        should contain the parameter name and corresponding K-ratio bound.\n    hpi_points : list[array_like]\n        A list of arrays representing the highest posterior interval (HPI) for each sample.\n        Each array should contain the parameter name and corresponding HPI.\n    bayes_est : list[dict]\n        A list of dictionaries, each containing the Bayes estimator for each parameter in the sample.\n    max_pos : list[dict]\n        A list of dictionaries, each containing the maximum posterior value for each parameter in the sample.\n    levels : list[float]\n        The list of confidence levels for which the HPI should be computed. Each value\n        in the list should be between 0 and 1.\n    Returns\n    -------\n    None\n    \"\"\"\nfor idx in np.arange(len(k_levels)):\nprint(f'----- Stats for sample #{idx}-----')\nif k_levels[idx] and any(x != [] for x in k_levels[idx]):\nk_level = k_levels[idx][0]\nfor par, level in k_level:\nif level:\nprint(f'k-ratio limit = is reached for {par} = {level}')\nelse:\nprint(f'k-ratio limit is not reached for {par}')\nelse:\nprint(f'No 1D k-bounds available for this sample\\n')\nhpi = hpi_points[idx]\nfor x in hpi:\nfor idy, level in enumerate(x[1]):\npar = x[0]\nx1 = level[0]\nx2 = level[1]\nif x1:\nprint(f'Lower {100*levels[idy]}%-HPDI limit is reached for {par} = {10**x1}')\nelse:\nprint(f'Lower {100*levels[idy]}%-HPDI limit is reached for {par} does not exist')\nif x2:\nprint(f'Upper {100*levels[idy]}%-HPDI limit is reached for {par} = {10**x2}')\nelse:\nprint(f'Upper {100*levels[idy]}%-HPDI limit is reached for {par} does not exist')\nfor par, val in bayes_est[idx].items():\nprint(f'The Bayes estimator for {par} is {val[0]} +- {val[1]}')\nfor par, val in max_pos[idx].items():\nprint(f'The maximum posterior value for {par} is {val}')\nprint('\\n')\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plot_utils/#ptarcade.plot_utils.plot_posteriors","title":"plot_posteriors","text":"<pre><code>plot_posteriors(\nchains: list[array_like],\nparams: list[list[str]],\npar_to_plot: list[list[str]] | None = None,\npar_names: list[list[str]] | None = None,\nmodel_id: list[int] | None = None,\nsamples_name: list[str] | None = None,\nhpi_levels: list[float] = [0.68, 0.95],\nk_ratio: list[float] | None = None,\nbf: list[float] | None = None,\nranges: dict[str, array_like] = {},\nlevels: list[float] | None = None,\nbhb_prior: str | bool = False,\none_column: bool = False,\nfig_width_pt: float | None = None,\nlabelsize: float = 8,\nlegend_size: float = 12,\nverbose: bool = False,\nsave: bool = False,\nmodel_name: str | None = None,\n) -&gt; tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]\n</code></pre> <p>Plot posterior distributions for the chosen parameters in the chains.</p> PARAMETER DESCRIPTION <code>chains</code> <p>list of array_like's. Contains all the chains to be plotted.</p> <p> TYPE: <code>list[array_like]</code> </p> <code>params</code> <p>list of lists[str]. Contains the name of the parameters appearing in the chains.</p> <p> TYPE: <code>list[list[str]]</code> </p> <code>par_to_plot</code> <p>list of lists[str]. Contains the parameter to plot from each chain.</p> <p> TYPE: <code>list[list[str]], optional</code> DEFAULT: <code>None</code> </p> <code>par_names</code> <p>Contains the LaTeX formatted names for the plotted parameters of each model. If not specified the name in the par files will be used.</p> <p> TYPE: <code>lists[list[str]], optional</code> DEFAULT: <code>None</code> </p> <code>model_id</code> <p>Assuming that the data are generated using hypermodels, specifies the model for which to plot the posteriors (default is None and in this case nmodel is taken to be 0).</p> <p> TYPE: <code>list[int], optional</code> DEFAULT: <code>None</code> </p> <code>samples_name</code> <p>Contains the name of the models associated to each chain, and it's used to create the legend. If not specified, the labels in the legend will be Sample 1, Sample 2, etc.</p> <p> TYPE: <code>list[str], optional</code> DEFAULT: <code>None</code> </p> <code>hpi_levels</code> <p>The list of confidence levels for which the highest posterior interval (HPI) should be computed. Each value in the list should be between 0 and 1.</p> <p> TYPE: <code>list[float], optional</code> DEFAULT: <code>[0.68, 0.95]</code> </p> <code>k_ratio</code> <p>The list of K-ratio bounds for each chain. Each value in the list should be between 0 and 1.</p> <p> TYPE: <code>list[float], optional</code> DEFAULT: <code>None</code> </p> <code>bf</code> <p>Bayes factor for each chain, used to calculate K-ratio bounds.</p> <p> TYPE: <code>list[float], optional</code> DEFAULT: <code>None</code> </p> <code>ranges</code> <p>The parameter ranges to display on the plot. Keys should be parameter names, and values should be tuples or lists specifying the lower and upper bounds of the range.</p> <p> TYPE: <code>dict, optional</code> DEFAULT: <code>{}</code> </p> <code>levels</code> <p>The list of confidence levels for which the contour should be computed. Each value in the list should be between 0 and 1.</p> <p> TYPE: <code>list[float], optional</code> DEFAULT: <code>None</code> </p> <code>bhb_prior</code> <p>String indicating the bhb prior to plot (possible choiches are NG15 and IPTA2.</p> <p> TYPE: <code>str, optional</code> DEFAULT: <code>False</code> </p> <code>one_column</code> <p>Whether to display the plot in one column format.</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>False</code> </p> <code>fig_width_pt</code> <p>The width of the figure in points.</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>None</code> </p> <code>labelsize</code> <p>The fontsize for the labels on the plot.</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>8</code> </p> <code>labelsize</code> <p>The fontsize for the labels on the plot.</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>8</code> </p> <code>verbose</code> <p>If set to True, the function will print statistical summaries of the data.</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>False</code> </p> <code>save</code> <p>If set to True, the function will save the plot to a PDF file.</p> <p> TYPE: <code>bool, optional</code> DEFAULT: <code>False</code> </p> <code>model_name</code> <p>Model name used to name the output files. If not specified the plot will be saved as 'corner.pdf'.</p> <p> TYPE: <code>str, optional</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>fig</code> <p>The figure containing the plot.</p> <p> TYPE: <code>matplotlib.figure.Figure</code> </p> <code>axs</code> <p>The axes of the figure.</p> <p> TYPE: <code>list[matplotlib.axes.Axes]</code> </p> Source code in <code>src/ptarcade/plot_utils.py</code> <pre><code>def plot_posteriors(\nchains: list[array_like],\nparams: list[list[str]],\npar_to_plot: list[list[str]] | None =None,\npar_names: list[list[str]] | None  =None,\nmodel_id: list[int] | None =None,\nsamples_name: list[str] | None =None,\nhpi_levels: list[float]=[0.68, 0.95],\nk_ratio: list[float] | None =None,\nbf: list[float] | None =None,\nranges: dict[str, array_like] ={},\nlevels: list[float] | None =None,\nbhb_prior: str | bool =False,\none_column: bool=False,\nfig_width_pt: float| None =None,\nlabelsize: float=8,\nlegend_size: float=12,\nverbose: bool=False,\nsave:bool=False,\nmodel_name: str | None=None) -&gt; tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]:\n\"\"\"\n    Plot posterior distributions for the chosen parameters in the chains.\n    Parameters\n    ----------\n    chains : list[array_like]\n        list of array_like's. Contains all the chains to be plotted.\n    params : list[list[str]]\n        list of lists[str]. Contains the name of the parameters appearing in the chains.\n    par_to_plot : list[list[str]], optional\n        list of lists[str]. Contains the parameter to plot from each chain.\n    par_names : lists[list[str]], optional\n        Contains the LaTeX formatted names for the plotted parameters of each model.\n        If not specified the name in the par files will be used.\n    model_id : list[int], optional\n        Assuming that the data are generated using hypermodels, specifies the model for\n        which to plot the posteriors (default is None and in this case nmodel is taken to be 0).\n    samples_name : list[str], optional\n        Contains the name of the models associated to each chain, and it's used to\n        create the legend. If not specified, the labels in the legend will be Sample 1, Sample 2, etc.\n    hpi_levels : list[float], optional\n        The list of confidence levels for which the highest posterior interval (HPI)\n        should be computed. Each value in the list should be between 0 and 1.\n    k_ratio : list[float], optional\n        The list of K-ratio bounds for each chain. Each value in the list should be between 0 and 1.\n    bf : list[float], optional\n        Bayes factor for each chain, used to calculate K-ratio bounds.\n    ranges : dict, optional\n        The parameter ranges to display on the plot. Keys should be parameter names, and values should be tuples\n        or lists specifying the lower and upper bounds of the range.\n    levels : list[float], optional\n        The list of confidence levels for which the contour should be computed. Each value\n        in the list should be between 0 and 1.\n    bhb_prior : str, optional\n        String indicating the bhb prior to plot (possible choiches are NG15 and IPTA2.\n    one_column : bool, optional\n        Whether to display the plot in one column format.\n    fig_width_pt : float, optional\n        The width of the figure in points.\n    labelsize : float, optional\n        The fontsize for the labels on the plot.\n    labelsize : float, optional\n        The fontsize for the labels on the plot.\n    verbose : bool, optional\n        If set to True, the function will print statistical summaries of the data.\n    save : bool, optional\n        If set to True, the function will save the plot to a PDF file.\n    model_name : str, optional\n        Model name used to name the output files. If not specified the plot will be\n        saved as 'corner.pdf'.\n    Returns\n    -------\n    fig : matplotlib.figure.Figure\n        The figure containing the plot.\n    axs : list[matplotlib.axes.Axes]\n        The axes of the figure.\n    \"\"\"\nplt.rcParams.update(plt_params)\nN_chains = len(chains)\npriors = params\nparams = [np.array(list(par.keys())) for par in params]\nif par_to_plot is None:\npar_to_plot = [None] * N_chains\nif model_id is None:\nmodel_id = [None] * N_chains\nif k_ratio is None:\nk_ratio = [None] * N_chains\nif bf is None:\nbf = [\nutils.compute_bf(chain, params[idx])[0] for idx, chain in enumerate(chains) if k_ratio[idx]]\nif not samples_name:\nsamples_name = [f\"Sample {idx+1}\" for idx in range(N_chains)]\nsamples = []\npar_union = []\nk_levels = [[]] * N_chains\nhpi_points = [[]] * N_chains\nbayes_est = [[]] * N_chains\nmax_pos = [[]] * N_chains\nfor idx, chain in enumerate(chains):\nfiltered = utils.chain_filter(\nchain, params[idx], model_id[idx], par_to_plot[idx]\n)\nfiltered_priors = {\nk.replace(\"_\", \"-\"): v\nfor k, v in priors[idx].items()\nif k.replace(\"_\", \"-\") in filtered[1] and v is not None\n}\nsamples.append(\nMCSamples(\nsamples=filtered[0],\nnames=filtered[1],\nranges=filtered_priors,\nignore_rows=1,\n)\n)\nif k_ratio[idx] and bf[idx]:\nk_levels[idx] = utils.get_k_levels(\nsample=samples[-1],\npars=filtered[1],\npriors=filtered_priors,\nbf=bf[idx],\nk_ratio=k_ratio[idx])\nelse:\nk_levels[idx] = None\nif hpi_levels:\nhpi_points[idx] = utils.get_c_levels(\nsample=samples[-1], pars=filtered[1], levels=hpi_levels)\nif verbose:\nbayes_est[idx] = utils.get_bayes_est(samples[-1], filtered[1])\nmax_pos[idx] = utils.get_max_pos(\nfiltered[1], bayes_est[idx], samples[-1], filtered_priors)\npar_union += [par for par in filtered[1] if par not in par_union]\nif len(par_union) &gt; 1:\nif not levels:\nlevels = [0.68, 0.95]\nsets = corner_plot_settings(levels, samples, one_column, legend_size, fig_width_pt)\ng = plots.get_subplot_plotter(settings=sets)\ng.triangle_plot(\nsamples,\nfilled=True,\nparams=par_union,\nlegend_labels=samples_name,\nsharey=True,\ndiag1d_kwargs={\"normalized\": True},\nparam_limits=ranges)\nif bhb_prior:\nplot_bhb_prior(g, bhb_prior, levels)\nelif len(par_union) == 1:\nsets = oned_plot_settings()\nif fig_width_pt:\nsize = set_size(fig_width_pt, ratio=1)[0]\nelif one_column:\nsize = set_size(246, ratio=1)[0]\nelse:\nsize = set_size(510, ratio=1)[0]\ng = plots.get_single_plotter(settings=sets, ratio=1, width_inch=size)\ng.plot_1d(samples, par_union[0], normalized=True)\ng.add_legend(samples_name, legend_loc=\"best\")\nif any(k_ratio):\nplot_k_bounds(g, samples, k_levels)\nif hpi_levels:\nplot_hpi(g, samples, hpi_points)\nif par_names is None:\npar_names_union = par_union\nelse:\npar_names_union = []\nfor names in par_names:\npar_names_union += [name for name in names if name not in par_names_union]\ncreate_ax_labels(par_names_union, labelsize=labelsize)\ng.fig.align_labels()\nif save and model_name:\nplt.savefig(f\"./plots/{model_name}_posteriors.pdf\", bbox_inches=\"tight\")\nelif save:\nplt.savefig(\"./plots/posteriors.pdf\", bbox_inches=\"tight\")\nif verbose:\nprint_stats(k_levels, hpi_points, bayes_est, max_pos, hpi_levels)\nf = plt.gcf()\naxs = f.get_axes()\nreturn f, axs\n</code></pre>"},{"location":"reference/ptarcade/pta_importer/","title":"pta_importer","text":"<p>Import PTA data.</p>"},{"location":"reference/ptarcade/pta_importer/#ptarcade.pta_importer-functions","title":"Functions","text":""},{"location":"reference/ptarcade/pta_importer/#ptarcade.pta_importer.get_ephem_conv","title":"get_ephem_conv","text":"<pre><code>get_ephem_conv(par_file: str) -&gt; str\n</code></pre> <p>Get the ephemeris convention used in par files.</p> PARAMETER DESCRIPTION <code>par_file</code> <p>Path to the par file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ephem</code> <p>The ephemeris convention used in the par file.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/ptarcade/pta_importer.py</code> <pre><code>def get_ephem_conv(par_file: str) -&gt; str:\n\"\"\"Get the ephemeris convention used in par files.\n    Parameters\n    ----------\n    par_file : str\n        Path to the par file.\n    Returns\n    -------\n    ephem : str\n        The ephemeris convention used in the par file.\n    \"\"\"\nf = open(par_file)\nlines = f.readlines()\nfor line in lines:\nline = line.split() # type: ignore\nif line[0] == \"EPHEM\":\nephem = line[-1]\nf.close()\nreturn ephem\n</code></pre>"},{"location":"reference/ptarcade/pta_importer/#ptarcade.pta_importer.get_pulsars","title":"get_pulsars","text":"<pre><code>get_pulsars(\npta_data: str, filters: list[str] | None = None\n) -&gt; list[Pulsar]\n</code></pre> <p>Get Pulsar data.</p> <p>If <code>pta_data</code> is a file, attempt to load it as a pickle. If it is a directory, read in the par and tim files within.</p> PARAMETER DESCRIPTION <code>pta_data</code> <p>Filename for pickle or directory containing par and tim files.</p> <p> TYPE: <code>str</code> </p> <code>filters</code> <p>Selective filter for par and tim files.</p> <p> TYPE: <code>list[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>psrs</code> <p>List containing pulsar data from <code>pta_data</code>.</p> <p> TYPE: <code>list[Pulsar]</code> </p> RAISES DESCRIPTION <code>SystemExit</code> <p>If <code>pta_data</code> is not a file or directory.</p> Source code in <code>src/ptarcade/pta_importer.py</code> <pre><code>def get_pulsars(pta_data: str, filters: list[str] | None = None) -&gt; list[Pulsar]:\n\"\"\"Get Pulsar data.\n    If `pta_data` is a file, attempt to load it as a pickle. If it is a\n    directory, read in the par and tim files within.\n    Parameters\n    ----------\n    pta_data : str\n        Filename for pickle or directory containing par and tim files.\n    filters : list[str]\n        Selective filter for par and tim files.\n    Returns\n    -------\n    psrs : list[Pulsar]\n        List containing pulsar data from `pta_data`.\n    Raises\n    ------\n    SystemExit\n        If `pta_data` is not a file or directory.\n    \"\"\"\nif os.path.isfile(pta_data):\nwith get_readable_fileobj(pta_data, \"binary\") as handle:\npsrs = pickle.load(handle)\nreturn psrs\nelif os.path.isdir(pta_data):\nparfiles = sorted(glob.glob(os.path.join(pta_data, \"*.par\")))\ntimfiles = sorted(glob.glob(os.path.join(pta_data, \"*.tim\")))\n# filter\nif filters is not None:\nparfiles = [x for x in parfiles if x.split(\"/\")[-1].split(\".\")[0] in filters]\ntimfiles = [x for x in timfiles if x.split(\"/\")[-1].split(\".\")[0] in filters]\n# TODO Need to check that all tim and par files have matches!\n# load the pulsars into enterprise\npsrs = []\nfor p, t in zip(parfiles, timfiles):\nephemeris = get_ephem_conv(p)\npsr = Pulsar(p, t, ephem=ephemeris)\npsrs.append(psr)\nreturn psrs\nelse:\nerr = f\"'pta_data' is not correct. Must be path or file.\\nCurrent value is {pta_data=}.\"\nlog.error(err)\nraise SystemExit\n</code></pre>"},{"location":"reference/ptarcade/pta_importer/#ptarcade.pta_importer.get_wn","title":"get_wn","text":"<pre><code>get_wn(wn_data: str | None) -&gt; dict | None\n</code></pre> <p>Get whitenoise data.</p> PARAMETER DESCRIPTION <code>wn_data</code> <p>File or directory containing whitenoise data.</p> <p> TYPE: <code>str, optional</code> </p> RETURNS DESCRIPTION <code>dict | None</code> <p>If <code>wn_data</code> isn't <code>None</code>, then the whitenoise data is returned as a <code>dict</code></p> Source code in <code>src/ptarcade/pta_importer.py</code> <pre><code>def get_wn(wn_data: str | None) -&gt; dict | None :\n\"\"\"Get whitenoise data.\n    Parameters\n    ----------\n    wn_data : str, optional\n        File or directory containing whitenoise data.\n    Returns\n    -------\n    dict | None\n        If `wn_data` isn't `None`, then the whitenoise data is returned as a\n        `dict`\n    \"\"\"\nparams = {}\nif wn_data is None:\nreturn None\nelif os.path.isfile(wn_data):\nwith open(wn_data) as fp:\nparams.update(json.load(fp))\nreturn params\nelif os.path.isdir(wn_data):\nfor filename in os.listdir(wn_data):\nwith open(os.path.join(wn_data, filename)) as f:\ndata = json.load(f)\nfor key, value in data.items():\nparams.update({key: value})\nreturn params\nelse:\nerr = f\"'wn_data' is not correct. Must be path, file, or None.\\nCurrent value is {wn_data=}.\"\nlog.error(err)\nraise SystemExit\n</code></pre>"},{"location":"reference/ptarcade/pta_importer/#ptarcade.pta_importer.pta_data_importer","title":"pta_data_importer","text":"<pre><code>pta_data_importer(\npta_data: str | dict,\n) -&gt; tuple[list[Pulsar], dict | None, array_like | None]\n</code></pre> <p>Import PTA pulsars objects, white noise parameters, and empirical distributions.</p> PARAMETER DESCRIPTION <code>pta_data</code> <ul> <li>If string, must be one of [\"NG15\", \"NG12\", \"IPTA2\"].</li> <li>If dict, must have keys [\"psrs_data\", \"noise_data\", \"emp_dist\"]</li> </ul> <p> TYPE: <code>str | dict</code> </p> RETURNS DESCRIPTION <code>psrs</code> <p>List of Pulsar objects</p> <p> TYPE: <code>list[Pulsar]</code> </p> <code>params</code> <p>Dictionary containing noise data</p> <p> TYPE: <code>dict | None</code> </p> <code>emp_dist</code> <p>The empirical distribution to use for sampling</p> <p> TYPE: <code>array_like | None</code> </p> RAISES DESCRIPTION <code>SystemExit</code> <p>If <code>pta_data</code> is not str or dict.</p> Source code in <code>src/ptarcade/pta_importer.py</code> <pre><code>def pta_data_importer(pta_data: str | dict) -&gt; tuple[list[Pulsar], dict | None, array_like | None]:\n\"\"\"Import PTA pulsars objects, white noise parameters, and empirical distributions.\n    Parameters\n    ----------\n    pta_data : str | dict\n        * If string, must be one of [\"NG15\", \"NG12\", \"IPTA2\"].\n        * If dict, must have keys [\"psrs_data\", \"noise_data\", \"emp_dist\"]\n    Returns\n    -------\n    psrs : list[Pulsar]\n        List of Pulsar objects\n    params : dict | None\n        Dictionary containing noise data\n    emp_dist : array_like | None\n        The empirical distribution to use for sampling\n    Raises\n    ------\n    SystemExit\n        If `pta_data` is not str or dict.\n    \"\"\"\nif pta_data == \"NG15\":\n# This returns a path in the astropy cache that points to these files, otherwise\n# it downloads them there and returns the path\nng15_dic = {\n\"psrs_data\": download_file(\n\"https://zenodo.org/record/8102748/files/ng15_psrs_v1p1.pkl.gz?download=1\",\nshow_progress=True,\ncache=True,\npkgname=\"ptarcade\",\n),\n\"noise_data\": download_file(\n\"https://zenodo.org/record/8102748/files/ng15_wn_v1p1.json?download=1\",\nshow_progress=True,\ncache=True,\npkgname=\"ptarcade\",\n),\n\"emp_dist\": download_file(\n\"https://zenodo.org/record/8102748/files/ng15_emp_v1p1.pkl?download=1\",\nshow_progress=True,\ncache=True,\npkgname=\"ptarcade\",\n),\n}\npsrs = get_pulsars(ng15_dic[\"psrs_data\"])\nparams = get_wn(ng15_dic[\"noise_data\"])\nemp_dist = ng15_dic[\"emp_dist\"]\nelif pta_data == \"NG12\":\nng12_dic = {\n\"psrs_data\": download_file(\n\"https://zenodo.org/record/8092873/files/ng12_psrs_v4.pkl.gz?download=1\",\ncache=True,\npkgname=\"ptarcade\",\n),\n\"noise_data\": download_file(\n\"https://zenodo.org/record/8092873/files/ng12_wn_v4.json?download=1\",\ncache=True,\npkgname=\"ptarcade\",\n),\n\"emp_dist\": None,\n}\npsrs = get_pulsars(ng12_dic[\"psrs_data\"])\nparams = get_wn(ng12_dic[\"noise_data\"])\nemp_dist = ng12_dic[\"emp_dist\"]\nelif pta_data == \"IPTA2\":\nipta2_dic = {\n\"psrs_data\": download_file(\n\"https://zenodo.org/record/8092873/files/ipta2_psrs_de438.pkl.gz?download=1\",\ncache=True,\npkgname=\"ptarcade\",\n),\n\"noise_data\": download_file(\n\"https://zenodo.org/record/8092873/files/ipta2_wn_de438.json?download=1\",\ncache=True,\npkgname=\"ptarcade\",\n),\n\"emp_dist\": None,\n}\npsrs = get_pulsars(ipta2_dic[\"psrs_data\"])\nparams = get_wn(ipta2_dic[\"noise_data\"])\nemp_dist = ipta2_dic[\"emp_dist\"]\nelif isinstance(pta_data, dict):\npsrs = get_pulsars(pta_data[\"psrs_data\"])\nparams = get_wn(pta_data[\"noise_data\"])\nemp_dist = pta_data[\"emp_dist\"]\nelse:\nerr = f\"'pta_data' is not correct\\n.Current value is {pta_data=}.\"\nlog.error(err)\nraise SystemExit\nreturn psrs, params, emp_dist\n</code></pre>"},{"location":"reference/ptarcade/sampler/","title":"sampler","text":"<p>Module for sampling using PTMCMCSampler and enterprise_extensions.</p>"},{"location":"reference/ptarcade/sampler/#ptarcade.sampler-classes","title":"Classes","text":""},{"location":"reference/ptarcade/sampler/#ptarcade.sampler-functions","title":"Functions","text":""},{"location":"reference/ptarcade/sampler/#ptarcade.sampler.cpu_model","title":"cpu_model","text":"<pre><code>cpu_model() -&gt; str\n</code></pre> <p>Get CPU info.</p> Source code in <code>src/ptarcade/sampler.py</code> <pre><code>def cpu_model() -&gt; str:\n\"\"\"Get CPU info.\"\"\"\ntry:\nimport cpuinfo\nreturn cpuinfo.get_cpu_info()[\"brand_raw\"]\nexcept ModuleNotFoundError:\nreturn \"unknown CPU (for better info install py-cpuinfo)\"\n</code></pre>"},{"location":"reference/ptarcade/sampler/#ptarcade.sampler.get_user_args","title":"get_user_args","text":"<pre><code>get_user_args() -&gt; (\ntuple[dict[str, ModuleType], dict[str, Any]]\n)\n</code></pre> <p>Get CLI arguments</p> RETURNS DESCRIPTION <code>inputs</code> <p>Dictionary of loaded user-supplied modules.</p> <p> TYPE: <code>dict[str, ModuleType]</code> </p> <code>input_options</code> <p>Dictionary of user-supplied input options.</p> <p> TYPE: <code>dict[str, Any]</code> </p> RAISES DESCRIPTION <code>SystemExit</code> <p>If CLI input is missing required args.</p> Source code in <code>src/ptarcade/sampler.py</code> <pre><code>def get_user_args() -&gt; tuple[dict[str, ModuleType], dict[str, Any]] :\n\"\"\"Get CLI arguments\n    Returns\n    -------\n    inputs : dict[str, ModuleType]\n        Dictionary of loaded user-supplied modules.\n    input_options : dict[str, Any]\n        Dictionary of user-supplied input options.\n    Raises\n    ------\n    SystemExit\n        If CLI input is missing required args.\n    \"\"\"\n# parse command line inputs\ninput_options, cmd_input_okay = input_handler.get_cmdline_arguments()\nif not cmd_input_okay:\nerror = (f\"Model file must be present\\n\"\n\"\\t- This is added with the -[blue bold]m[/] input flags. Add -[blue bold]h[/] (--[blue bold]help[/]) flags for more help.\\n\")\nlog.error(error, extra={\"markup\":True})\nraise SystemExit\ninputs = input_handler.load_inputs(input_options)\ninput_handler.check_config(inputs['config'])\nif not hasattr(inputs[\"model\"], \"group\"):\npars_dic = inputs[\"model\"].parameters\ngroup = [par for par in pars_dic.keys() if pars_dic[par].common]\nsetattr(inputs[\"model\"], \"group\", group)\ninputs[\"model\"].parameters = ParamDict(inputs[\"model\"].parameters)\nreturn inputs, input_options\n</code></pre>"},{"location":"reference/ptarcade/sampler/#ptarcade.sampler.get_user_pta_data","title":"get_user_pta_data","text":"<pre><code>get_user_pta_data(\ninputs: dict[str, Any]\n) -&gt; tuple[list[Pulsar], dict | None, array_like | None]\n</code></pre> <p>Import user-specified PTA data.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>User supplied modules</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>psrs</code> <p>List of Pulsar objects</p> <p> TYPE: <code>list[Pulsar]</code> </p> <code>noise_params</code> <p>Dictionary containing noise data</p> <p> TYPE: <code>dict | None</code> </p> <code>emp_dist</code> <p>The empirical distribution to use for sampling</p> <p> TYPE: <code>array_like | None</code> </p> Source code in <code>src/ptarcade/sampler.py</code> <pre><code>def get_user_pta_data(inputs: dict[str, Any]) -&gt; tuple[list[Pulsar], dict | None, array_like | None ]:\n\"\"\"Import user-specified PTA data.\n    Parameters\n    ----------\n    inputs : dict[str, Any]\n        User supplied modules\n    Returns\n    -------\n    psrs : list[Pulsar]\n        List of Pulsar objects\n    noise_params : dict | None\n        Dictionary containing noise data\n    emp_dist : array_like | None\n        The empirical distribution to use for sampling\n    \"\"\"\n# import pta data\npsrs, noise_params, emp_dist = pta_importer.pta_data_importer(inputs['config'].pta_data)\nreturn psrs, noise_params, emp_dist\n</code></pre>"},{"location":"reference/ptarcade/sampler/#ptarcade.sampler.initialize_pta","title":"initialize_pta","text":"<pre><code>initialize_pta(\ninputs: dict[str, Any],\npsrs: list[Pulsar] | None,\nnoise_params: dict | None,\n) -&gt; dict[int, PTA]\n</code></pre> <p>Initialize the PTA with the user input</p> PARAMETER DESCRIPTION <code>psrs</code> <p>list of pulsar objects</p> <p> TYPE: <code>list[Pulsar]</code> </p> <code>inputs</code> <p>User specified modules</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>noise_params</code> <p>User specified noise params</p> <p> TYPE: <code>dict, optional</code> </p> RETURNS DESCRIPTION <code>dict[int, PTA]</code> <p>Dictionary of enterprise.signals.signal_base.PTA objects configured with user inputs</p> Source code in <code>src/ptarcade/sampler.py</code> <pre><code>def initialize_pta(inputs: dict[str, Any], psrs: list[Pulsar] | None, noise_params : dict | None ) -&gt; dict[int, PTA]:\n\"\"\"Initialize the PTA with the user input\n    Parameters\n    ----------\n    psrs : list[Pulsar]\n        list of pulsar objects\n    inputs : dict[str, Any]\n        User specified modules\n    noise_params : dict, optional\n        User specified noise params\n    Returns\n    -------\n    dict[int, PTA]\n        Dictionary of [enterprise.signals.signal_base.PTA][] objects configured with user inputs\n    \"\"\"\ninput_handler.check_model(\nmodel=inputs['model'],\npsrs=psrs,\nred_components=inputs['config'].red_components,\ngwb_components=inputs['config'].gwb_components,\nmode=inputs[\"config\"].mode)\nif inputs[\"config\"].mode == \"enterprise\":\npta = {}\npta[0] = signal_builder.ent_builder(\npsrs=psrs,\nmodel=inputs['model'],\nnoisedict=noise_params,\npta_dataset=inputs['config'].pta_data,\nbhb_th_prior=inputs['config'].bhb_th_prior,\ngamma_bhb=inputs['config'].gamma_bhb,\nA_bhb_logmin=inputs['config'].A_bhb_logmin,\nA_bhb_logmax=inputs['config'].A_bhb_logmax,\ncorr=inputs['config'].corr,\nred_components=inputs[\"config\"].red_components,\ngwb_components=inputs[\"config\"].gwb_components)\nif inputs[\"config\"].mod_sel:\npta[1] = pta[0]\npta[0] = signal_builder.ent_builder(\npsrs=psrs,\nmodel=None,\nnoisedict=noise_params,\npta_dataset=inputs['config'].pta_data,\nbhb_th_prior=inputs['config'].bhb_th_prior,\ngamma_bhb=inputs['config'].gamma_bhb,\nA_bhb_logmin=inputs['config'].A_bhb_logmin,\nA_bhb_logmax=inputs['config'].A_bhb_logmax,\ncorr=inputs['config'].corr,\nred_components=inputs[\"config\"].red_components,\ngwb_components=inputs[\"config\"].gwb_components)\nelif inputs[\"config\"].mode == \"ceffyl\":\npta = signal_builder.ceffyl_builder(inputs)\nreturn pta\n</code></pre>"},{"location":"reference/ptarcade/sampler/#ptarcade.sampler.setup_sampler","title":"setup_sampler","text":"<pre><code>setup_sampler(\ninputs: dict[str, ModuleType],\ninput_options: dict[str, Any],\npta: dict[int, PTA] | None,\nemp_dist: array_like | None,\n) -&gt; tuple[PTSampler, NDArray]\n</code></pre> <p>Setup the PTMCMC sampler</p> PARAMETER DESCRIPTION <code>inputs</code> <p>Dictionary of loaded user-supplied modules.</p> <p> TYPE: <code>dict[str, ModuleType]</code> </p> <code>input_options</code> <p>Dictionary of user-supplied input options.</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>pta</code> <p>Dictionary of enterprise.signals.signal_base.PTA objects configured with user inputs</p> <p> TYPE: <code>dict[int, PTA]</code> </p> <code>emp_dist</code> <p>The empirical distribution to use for sampling</p> <p> TYPE: <code>array_like, optional</code> </p> RETURNS DESCRIPTION <code>sampler</code> <p>Configured PTMCMCSampler.PTSampler</p> <p> TYPE: <code>PTMCMCSampler.PTSampler</code> </p> <code>x0</code> <p>Initial sample.</p> <p> TYPE: <code>NDArray</code> </p> Source code in <code>src/ptarcade/sampler.py</code> <pre><code>def setup_sampler(\ninputs: dict[str, ModuleType],\ninput_options: dict[str, Any],\npta: dict[int, PTA] | None,\nemp_dist: array_like | None,\n) -&gt; tuple[PTSampler, NDArray]:\n\"\"\"Setup the PTMCMC sampler\n    Parameters\n    ----------\n    inputs : dict[str, ModuleType]\n        Dictionary of loaded user-supplied modules.\n    input_options : dict[str, Any]\n        Dictionary of user-supplied input options.\n    pta : dict[int, PTA]\n        Dictionary of [enterprise.signals.signal_base.PTA][] objects configured with user inputs\n    emp_dist : array_like, optional\n        The empirical distribution to use for sampling\n    Returns\n    -------\n    sampler : PTMCMCSampler.PTSampler\n        Configured [PTMCMCSampler.PTSampler][]\n    x0 : NDArray\n        Initial sample.\n    \"\"\"\nout_dir = os.path.join(\ninputs[\"config\"].out_dir, inputs[\"model\"].name, f'chain_{input_options[\"n\"]}')\nif not inputs[\"config\"].resume and os.path.exists(out_dir):\nshutil.rmtree(out_dir)\nif inputs['config'].mode == \"enterprise\":\nsuper_model = hypermodel.HyperModel(pta)\ngroups = signal_builder.unique_sampling_groups(super_model)\nif inputs[\"model\"].group:\nidx_params = [super_model.param_names.index(pp) for pp in inputs[\"model\"].group]\n[groups.append(idx_params) for _ in range(5)] # type: ignore\n# add nmodel index to group structure\ngroups.extend([[len(super_model.param_names)-1]])\nsampler = super_model.setup_sampler(\nresume=inputs[\"config\"].resume,\noutdir=out_dir,\nsample_nmodel=inputs[\"config\"].mod_sel,\ngroups=groups,\nempirical_distr=emp_dist)\nx0 = super_model.initial_sample()\nsuper_model.get_lnlikelihood(x0) # Cache now to make timing more accurate\nelif inputs[\"config\"].mode == \"ceffyl\":\nsampler = Sampler.setup_sampler(pta,\noutdir=out_dir,\nlogL=pta.ln_likelihood,\nlogp=pta.ln_prior)\nx0 = pta.initial_samples()\nreturn sampler, x0\n</code></pre>"},{"location":"reference/ptarcade/sampler/#ptarcade.sampler.do_sample","title":"do_sample","text":"<pre><code>do_sample(\ninputs: dict[str, Any], sampler: PTSampler, x0: NDArray\n) -&gt; None\n</code></pre> <p>Run the configured sampler.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>The user specified modules.</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>sampler</code> <p>The configured PTMCMCSampler.PTSampler.</p> <p> TYPE: <code>PTMCMCSampler.PTSampler</code> </p> <p>x0 : NDArray     The inital sample.</p> Source code in <code>src/ptarcade/sampler.py</code> <pre><code>def do_sample(inputs: dict[str, Any], sampler: PTSampler, x0: NDArray) -&gt; None:\n\"\"\"Run the configured sampler.\n    Parameters\n    ----------\n    inputs : dict[str, Any]\n        The user specified modules.\n    sampler : PTMCMCSampler.PTSampler\n        The configured [PTMCMCSampler.PTSampler][].\n    x0 : NDArray\n        The inital sample.\n    \"\"\"\nN_samples = inputs[\"config\"].N_samples\nconsole.print(f\"[bold green]Starting to sample {N_samples} samples\\n\")\nwith warnings.catch_warnings():\nwarnings.filterwarnings(\n\"ignore\",\ncategory=RuntimeWarning,\nmessage=\"invalid value encountered in scalar subtract\",\nmodule=\"PTMCMCSampler\",\nlineno=567,\n)\nwarnings.filterwarnings(\n\"ignore\",\ncategory=RuntimeWarning,\nmessage=\"All-NaN axis encountered\",\nmodule=\"PTMCMCSampler\",\nlineno=464,\n)\nwarnings.filterwarnings(\n\"ignore\",\ncategory=RuntimeWarning,\nmessage=\"divide by zero encountered in log\",\nmodule=\"enterprise.signals.parameter\",\nlineno=62,\n)\nsampler.sample(\nx0,\nN_samples,\nSCAMweight=inputs[\"config\"].scam_weight,\nAMweight=inputs[\"config\"].am_weight,\nDEweight=inputs[\"config\"].de_weight,\n)\nconsole.print()\nconsole.print(Panel.fit(\"[bold green]Done sampling[/]\", border_style=\"green\"))\nconsole.print()\n</code></pre>"},{"location":"reference/ptarcade/sampler/#ptarcade.sampler.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Read user inputs, set up sampler and models, and run sampler.</p> Source code in <code>src/ptarcade/sampler.py</code> <pre><code>def main():\n\"\"\"Read user inputs, set up sampler and models, and run sampler.\"\"\"\nconsole.print(Panel.fit('[bold green]Starting to run[/]', border_style=\"green\"))\nconsole.print()\ntable = rich.table.Table(title=\"Node Information\", title_justify=\"left\",box=rich.box.ROUNDED)\ntable.add_column(\"Node\", style=\"cyan\", no_wrap=True)\ntable.add_column(\"CPU\", style=\"magenta\")\ntable.add_row(platform.node(), cpu_model())\nconsole.print(table)\nconsole.print()\nstart_cpu = time.process_time()\nstart_real = time.perf_counter()\ninputs, input_options = get_user_args()\npsrs = None\nnoise_params = None\nemp_dist = None\nif inputs[\"config\"].mode == \"enterprise\":\nwith console.status(\"Loading Pulsars and noise data...\", spinner=\"bouncingBall\"):\n# import pta data\npsrs, noise_params, emp_dist = get_user_pta_data(inputs)\nconsole.print(f\"[bold green]Done loading [blue]{len(psrs)}[/] Pulsars and noise data :heavy_check_mark:\\n\")\nwith console.status(\"Initializing PTA...\", spinner=\"bouncingBall\"):\npta = initialize_pta(inputs, psrs, noise_params)\nconsole.print(\"[bold green]Done initializing PTA :heavy_check_mark:\\n\")\nwith console.status(\"Initializing Sampler...\", spinner=\"bouncingBall\"):\nsampler, x0 = setup_sampler(inputs, input_options, pta, emp_dist)\nconsole.print(\"[bold green]Done initializing Sampler :heavy_check_mark:\\n\")\nconsole.print(\"Done with all initializtions.\\nSetup times (including first sample) {:.2f} seconds real, {:.2f} seconds CPU\\n\".format(\ntime.perf_counter()-start_real, time.process_time()-start_cpu));\nstart_cpu = time.process_time()\nstart_real = time.perf_counter()\ndo_sample(inputs, sampler, x0)\nreal_time = time.perf_counter()-start_real\ncpu_time = time.process_time()-start_cpu\nN_samples = inputs[\"config\"].N_samples\nsummary_table = rich.table.Table(title=\"Run Summary\", title_justify=\"left\", box=rich.box.ROUNDED)\nsummary_table.add_column(\"Time (real)\", style=\"cyan\")\nsummary_table.add_column(\"Time (real)/sample\", style=\"cyan\")\nsummary_table.add_column(\"Time (CPU)\", style=\"magenta\")\nsummary_table.add_column(\"Time (CPU)/sample\", style=\"magenta\")\nsummary_table.add_row(f\"{real_time:.2f}\", f\"{real_time/N_samples:.4f}\", f\"{cpu_time:.2f}\", f\"{cpu_time/N_samples:.4f}\")\nconsole.print(summary_table)\n</code></pre>"},{"location":"reference/ptarcade/signal_builder/","title":"signal_builder","text":"<p>Module for building PTA signals.</p>"},{"location":"reference/ptarcade/signal_builder/#ptarcade.signal_builder-functions","title":"Functions","text":""},{"location":"reference/ptarcade/signal_builder/#ptarcade.signal_builder.unique_sampling_groups","title":"unique_sampling_groups","text":"<pre><code>unique_sampling_groups(\nsuper_model: hypermodel.Hypermodel,\n) -&gt; list[list[int]]\n</code></pre> <p>Fix the hypermodel group structure.</p> PARAMETER DESCRIPTION <code>super_model</code> <p>The configured hypermodel from enterprise_extensions</p> <p> TYPE: <code>enterprise_extensions.hypermodel.Hypermodel</code> </p> RETURNS DESCRIPTION <code>unique_groups</code> <p>Nested list of lists with unique indices for parameters.</p> <p> TYPE: <code>list[list[int]]</code> </p> Source code in <code>src/ptarcade/signal_builder.py</code> <pre><code>def unique_sampling_groups(super_model: hypermodel.Hypermodel) -&gt; list[list[int]]:\n\"\"\"Fix the hypermodel group structure.\n    Parameters\n    ----------\n    super_model : enterprise_extensions.hypermodel.Hypermodel\n        The configured hypermodel from [enterprise_extensions][]\n    Returns\n    -------\n    unique_groups : list[list[int]]\n        Nested list of lists with unique indices for parameters.\n    \"\"\"\nunique_groups = []\nfor p in super_model.models.values():\ngroups = get_parameter_groups(p)\nfor group in groups:\ncheck_group = []\nfor idx in group:\nparam_name = p.param_names[idx]\ncheck_group.append(super_model.param_names.index(param_name))\nif check_group not in unique_groups:\nunique_groups.append(check_group)\nreturn unique_groups\n</code></pre>"},{"location":"reference/ptarcade/signal_builder/#ptarcade.signal_builder.powerlaw2","title":"powerlaw2","text":"<pre><code>powerlaw2(\nf: NDArray, log10_Agamma: NDArray, components: int = 2\n) -&gt; NDArray\n</code></pre> <p>Modified powerlaw function.</p> <p>Defines a modified  powerlaw function that takes as input an array containing the values of the amplitude and spectral index.</p> PARAMETER DESCRIPTION <code>f</code> <p>Frequency array.</p> <p> TYPE: <code>NDArray</code> </p> <code>log10_Agamma</code> <p>Two component NDArray of [Log10(amplitude), spectral index].</p> <p> TYPE: <code>NDArray</code> </p> <code>components</code> <p>Number of components for each frequency.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>The modified powerlaw.</p> Source code in <code>src/ptarcade/signal_builder.py</code> <pre><code>@parameter.function\ndef powerlaw2(f: NDArray, log10_Agamma: NDArray, components: int = 2) -&gt; NDArray:\n\"\"\"Modified powerlaw function.\n    Defines a modified  powerlaw function that takes as input an\n    array containing the values of the amplitude and spectral index.\n    Parameters\n    ----------\n    f : NDArray\n        Frequency array.\n    log10_Agamma : NDArray\n        Two component NDArray of [Log10(amplitude), spectral index].\n    components : int\n        Number of components for each frequency.\n    Returns\n    -------\n    NDArray\n        The modified powerlaw.\n    \"\"\"\ndf = np.diff(np.concatenate((np.array([0]), f[::components])))\nreturn (\n(10 ** log10_Agamma[0]) ** 2\n/ 12.0\n/ np.pi**2\n* const.fyr ** (log10_Agamma[1] - 3)\n* f ** (-log10_Agamma[1])\n* np.repeat(df, components)\n)\n</code></pre>"},{"location":"reference/ptarcade/signal_builder/#ptarcade.signal_builder.powerlaw","title":"powerlaw","text":"<pre><code>powerlaw(f, Tspan, log10_A, gamma)\n</code></pre> <p>Modified powerlaw function.</p> <p>Powerlaw function modified to work with ceffyl.</p> PARAMETER DESCRIPTION <code>f</code> <p>Frequency array.</p> <p> TYPE: <code>NDArray</code> </p> <code>Tspan</code> <p>Observation time.</p> <p> </p> <code>log10_A</code> <p>Log10(amplitude)</p> <p> TYPE: <code>float</code> </p> <code>gamma</code> <p>Spectral index</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>The modified powerlaw.</p> Source code in <code>src/ptarcade/signal_builder.py</code> <pre><code>@parameter.function\ndef powerlaw(f, Tspan, log10_A, gamma):\n\"\"\"Modified powerlaw function.\n    Powerlaw function modified to work with ceffyl.\n    Parameters\n    ----------\n    f : NDArray\n        Frequency array.\n    Tspan: fload\n        Observation time.\n    log10_A : float\n        Log10(amplitude)\n    gamma : float\n        Spectral index\n    Returns\n    -------\n    NDArray\n        The modified powerlaw.\n    \"\"\"\nreturn (\n(10**log10_A) ** 2 / 12.0 / np.pi**2 * const.fyr ** (gamma - 3) * f ** (-gamma) / Tspan  # divide by Tspan here\n)\n</code></pre>"},{"location":"reference/ptarcade/signal_builder/#ptarcade.signal_builder.powerlaw2_ceffyl","title":"powerlaw2_ceffyl","text":"<pre><code>powerlaw2_ceffyl(\nf: NDArray,\nTspan: float,\ngw_bhb: NDArray,\ncomponents: int = 2,\n) -&gt; NDArray\n</code></pre> <p>Modified powerlaw function.</p> <p>Defines a modified powerlaw function that takes as input an array containing the values of the amplitude and spectral index. This version is compatible with ceffyl.</p> PARAMETER DESCRIPTION <code>f</code> <p>Frequency array.</p> <p> TYPE: <code>NDArray</code> </p> <code>Tspan</code> <p>Observation time.</p> <p> TYPE: <code>float</code> </p> <code>gw_bhb</code> <p>Two component NDArray of [Log10(amplitude), spectral index].</p> <p> TYPE: <code>NDArray</code> </p> <code>components</code> <p>Count by this number in <code>f</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>The modified powerlaw.</p> Source code in <code>src/ptarcade/signal_builder.py</code> <pre><code>@parameter.function\ndef powerlaw2_ceffyl(f: NDArray, Tspan: float, gw_bhb: NDArray, components: int = 2) -&gt; NDArray:\n\"\"\"Modified powerlaw function.\n    Defines a modified powerlaw function that takes as input an\n    array containing the values of the amplitude and spectral index.\n    This version is compatible with ceffyl.\n    Parameters\n    ----------\n    f : NDArray\n        Frequency array.\n    Tspan: fload\n        Observation time.\n    gw_bhb : NDArray\n        Two component NDArray of [Log10(amplitude), spectral index].\n    components : int\n        Count by this number in `f`.\n    Returns\n    -------\n    NDArray\n        The modified powerlaw.\n    \"\"\"\nreturn (\n(10 ** gw_bhb[0]) ** 2\n/ 12.0\n/ np.pi**2\n* const.fyr ** (gw_bhb[1] - 3)\n* f ** (-gw_bhb[1])\n/ Tspan\n)\n</code></pre>"},{"location":"reference/ptarcade/signal_builder/#ptarcade.signal_builder.tnequad_conv","title":"tnequad_conv","text":"<pre><code>tnequad_conv(noisedict: dict) -&gt; bool\n</code></pre> <p>Check equad defintion.</p> <p>Checks if the TempoNest definition of equad is used in the white noise dictionary.</p> PARAMETER DESCRIPTION <code>noisedict</code> <p>Dictionary containing noise terms.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>tnequad</code> <p>Whether TempoNest equad is used.</p> <p> TYPE: <code>bool</code> </p> RAISES DESCRIPTION <code>SystemExit</code> <p>If the equad convention is not consistent.</p> Source code in <code>src/ptarcade/signal_builder.py</code> <pre><code>def tnequad_conv(noisedict: dict) -&gt; bool:\n\"\"\"Check equad defintion.\n    Checks if the TempoNest definition of equad is used in the white noise dictionary.\n    Parameters\n    ----------\n    noisedict : dict\n        Dictionary containing noise terms.\n    Returns\n    -------\n    tnequad : bool\n        Whether TempoNest equad is used.\n    Raises\n    ------\n    SystemExit\n        If the equad convention is not consistent.\n    \"\"\"\nt2equad = False\ntnequad = False\nfor x in noisedict:\nif \"tnequad\" in x:\ntnequad = True\nelif \"t2equad\" in x:\nt2equad = True\nif t2equad and tnequad:\nerr = \"ERROR: The convention for equad is not consistent across the PTA data.\"\nraise SystemExit(err)\nreturn tnequad\n</code></pre>"},{"location":"reference/ptarcade/signal_builder/#ptarcade.signal_builder.ent_builder","title":"ent_builder","text":"<pre><code>ent_builder(\npsrs: list[Pulsar],\nmodel: ModuleType | None = None,\nnoisedict: dict | None = None,\npta_dataset: str | None = None,\nbhb_th_prior: bool = False,\ngamma_bhb: float | None = None,\nA_bhb_logmin: float | None = None,\nA_bhb_logmax: float | None = None,\ncorr: bool = False,\nred_components: int = 30,\ngwb_components: int = 14,\n) -&gt; signal_base.PTA\n</code></pre> <p>Reads in list of enterprise Pulsar instances and returns a PTA object instantiated with user-supplied options.</p> PARAMETER DESCRIPTION <code>psrs</code> <p>List of enterprise Pulsar instances.</p> <p> TYPE: <code>list[Pulsar]</code> </p> <code>model</code> <p>Object containing the parameters of the exotic signal. Defaults to None.</p> <p> TYPE: <code>ModuleType</code> DEFAULT: <code>None</code> </p> <code>noisedict</code> <p>Dictionary of pulsar noise properties. Defaults to None]</p> <p> TYPE: <code>dict, optional</code> DEFAULT: <code>None</code> </p> <code>pta_dataset</code> <p>PTADataset object containing the data for the PTA. Defaults to None.</p> <p> TYPE: <code>str, optional</code> DEFAULT: <code>None</code> </p> <code>bhb_th_prior</code> <p>If set to True the prior for the bhb signal will be derived by fitting a 2D Gaussian to the distribution of A and gamma in the holodeck library astro-02-gw. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>gamma_bhb</code> <p>Fixed common bhb process spectral index value. If set to None we vary the spectral index over the range [0, 7]. Defaults to None.</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>None</code> </p> <code>A_bhb_logmin</code> <p>specifies lower prior on the log amplitude of the bhb common process. If set to None, -18 is used. Defaults to Non</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>None</code> </p> <code>A_bhb_logmax</code> <p>specifies upper prior on the log amplitude of the bhb common process. If set to None, -14 is used if gamma_bhb = 13/3, -11 is used otherwise. Defaults to None.</p> <p> TYPE: <code>float, optional</code> DEFAULT: <code>None</code> </p> <code>corr</code> <p>if set to True HD correlations are assumed for GWBs. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>red_components</code> <p>number of frequency components for the intrinsic red noise. Defaults to 30.</p> <p> TYPE: <code>int</code> DEFAULT: <code>30</code> </p> <code>gwb_components</code> <p>number of frequency components for the common processes. Defaults to 14</p> <p> TYPE: <code>int</code> DEFAULT: <code>14</code> </p> RETURNS DESCRIPTION <code>signal_base.PTA</code> <p>PTA object instantiated with user-supplied options.</p> Source code in <code>src/ptarcade/signal_builder.py</code> <pre><code>def ent_builder(\npsrs: list[Pulsar],\nmodel: ModuleType | None = None,\nnoisedict: dict | None = None,\npta_dataset: str | None = None,\nbhb_th_prior: bool = False,\ngamma_bhb: float | None = None,\nA_bhb_logmin: float | None = None,\nA_bhb_logmax: float | None = None,\ncorr: bool = False,\nred_components: int = 30,\ngwb_components: int = 14,\n) -&gt; signal_base.PTA:\n\"\"\"\n    Reads in list of enterprise Pulsar instances and returns a PTA\n    object instantiated with user-supplied options.\n    Parameters\n    ----------\n    psrs : list[Pulsar]\n        List of enterprise Pulsar instances.\n    model : ModuleType\n        Object containing the parameters of the exotic\n        signal. Defaults to None.\n    noisedict : dict, optional\n        Dictionary of pulsar noise properties. Defaults to None]\n    pta_dataset : str, optional\n        PTADataset object containing the data for the PTA. Defaults to None.\n    bhb_th_prior : bool\n        If set to True the prior for the bhb signal will be\n        derived by fitting a 2D Gaussian to the distribution of A and gamma\n        in the holodeck library astro-02-gw. Defaults to False.\n    gamma_bhb : float, optional\n        Fixed common bhb process spectral index value. If set to\n        None we vary the spectral index over the range [0, 7]. Defaults to None.\n    A_bhb_logmin : float, optional\n        specifies lower prior on the log amplitude of the bhb\n        common process. If set to None, -18 is used. Defaults to Non\n    A_bhb_logmax : float, optional\n        specifies upper prior on the log amplitude of the bhb\n        common process. If set to None, -14 is used if gamma_bhb = 13/3, -11 is\n        used otherwise. Defaults to None.\n    corr : bool\n        if set to True HD correlations are assumed for GWBs. Defaults to False.\n    red_components : int\n        number of frequency components for the intrinsic\n        red noise. Defaults to 30.\n    gwb_components : int\n        number of frequency components for the common processes. Defaults to 14\n    Returns\n    -------\n    signal_base.PTA\n        PTA object instantiated with user-supplied options.\n    \"\"\"\n# timing model\ntm = gp_signals.MarginalizingTimingModel(use_svd=True)\ns = tm\n# find the maximum time span to set the GW frequency sampling\nTspan = model_utils.get_tspan(psrs)\n# add pulsar intrinsic red noise\ns += red_noise_block(psd=\"powerlaw\", prior=\"log-uniform\", Tspan=Tspan, components=red_components)\n# add common red noise\nif model is None or model.smbhb:\nif corr:\norf = \"hd\"\nelse:\norf = None\nif bhb_th_prior and (pta_dataset == \"NG15\" or pta_dataset == \"IPTA2\"):\nmu, sigma = bhb_priors[pta_dataset]            \nif model is None:\nlog10_Agamma_gw = parameter.Normal(mu=mu, sigma=sigma, size=2)(\"gw_bhb\")\nelif model.smbhb:\nlog10_Agamma_gw = parameter.Normal(mu=mu, sigma=sigma, size=2)(\"gw_bhb_np\")\npowerlaw_gw = powerlaw2(log10_Agamma=log10_Agamma_gw)\nif orf == \"hd\":\ns += gp_signals.FourierBasisCommonGP(\nspectrum=powerlaw_gw, orf=utils.hd_orf(), components=gwb_components, Tspan=Tspan, name=\"gw_bhb\"\n)\nelse:\ns += gp_signals.FourierBasisGP(\nspectrum=powerlaw_gw, components=gwb_components, Tspan=Tspan, name=\"gw_bhb\"\n)\nelif bhb_th_prior and pta_dataset != \"NG15\" and pta_dataset != \"IPTA2\":\nprint(\n\"WARNING: Theory motivated priors for the SMBHB singal parameters are available only for NG15 and IPTA2. Reverting back to log uniform prior for A and uniform prior for gamma.\\n\"\n)\ns += common_red_noise_block(\npsd='powerlaw',\nprior='log-uniform',\nTspan=Tspan,\ncomponents=gwb_components,\norf=orf,\nname = 'gw_bhb')\nelse:\ns += common_red_noise_block(\npsd=\"powerlaw\",\nprior=\"log-uniform\",\nTspan=Tspan,\ncomponents=gwb_components,\ngamma_val=gamma_bhb,\norf=orf,\nname=\"gw_bhb\",\nlogmin=A_bhb_logmin,\nlogmax=A_bhb_logmax,\n)\n# add DM variations\ndm_var = [hasattr(psr, \"dmx\") for psr in psrs]  # check if dmx parameters are present in pulsars objects\nif all(dm_var):\npass\nelif not any(dm_var):\ns += dm_noise_block(gp_kernel=\"diag\", psd=\"powerlaw\", prior=\"log-uniform\", components=30, gamma_val=None)\nelse:\nsys.exit(\"ERROR: The convention for DM variation is not consistent across the PTA data.\")\n# add new-physics signal\nif model:\nif hasattr(model, \"signal\"):\nsignal = function(model.signal)\nsignal = signal(**model.parameters)\nnp_signal = deterministic_signals.Deterministic(signal, name=model.name)\ns += np_signal\nelif hasattr(model, \"spectrum\"):\nspectrum = aux.omega2cross(model.spectrum)\ncpl_np = spectrum(**model.parameters)\nif corr:\norf = utils.hd_orf()\nnp_gwb = gp_signals.FourierBasisCommonGP(\nspectrum=cpl_np, orf=orf, components=gwb_components, Tspan=Tspan, name=model.name\n)\nelse:\nnp_gwb = gp_signals.FourierBasisGP(\nspectrum=cpl_np, components=gwb_components, Tspan=Tspan, name=model.name\n)\ns += np_gwb\n# add white-noise, and act on psr objects\nmodels = []\nif noisedict is None:\nwhite_vary = True\ntnequad = False\nelse:\nwhite_vary = False\ntnequad = tnequad_conv(noisedict)\nfor p in psrs:\nif \"NANOGrav\" in p.flags[\"pta\"]:\ns2 = s + white_noise_block(vary=white_vary, inc_ecorr=True, tnequad=tnequad, select=\"backend\")\nif \"1713\" in p.name and not any(dm_var):\ns3 = s2 + chrom.dm_exponential_dip(tmin=54500, tmax=55000, idx=2, sign=False, name=\"dmexp_1\")\nif p.toas.max() / const.day &gt; 57850:\ns3 += chrom.dm_exponential_dip(tmin=57300, tmax=57850, idx=2, sign=False, name=\"dmexp_2\")\nmodels.append(s3(p))\nelse:\nmodels.append(s2(p))\nelse:\ns4 = s + white_noise_block(vary=white_vary, inc_ecorr=False, tnequad=tnequad, select=\"backend\")\nif \"1713\" in p.name and not any(dm_var):\ns5 = s4 + chrom.dm_exponential_dip(tmin=54500, tmax=55000, idx=2, sign=False, name=\"dmexp_1\")\nif p.toas.max() / const.day &gt; 57850:\ns5 += chrom.dm_exponential_dip(tmin=57300, tmax=57850, idx=2, sign=False, name=\"dmexp_2\")\nmodels.append(s5(p))\nelse:\nmodels.append(s4(p))\n# set up PTA\npta = signal_base.PTA(models)\n# set white noise parameters\nif noisedict is not None:\npta.set_default_params(noisedict)\nreturn pta\n</code></pre>"},{"location":"reference/ptarcade/data/__init__/","title":"init","text":""},{"location":"reference/ptarcade/data/default_config/","title":"default_config","text":""},{"location":"utils/","title":"Index","text":"<p>PTArcade is shipped with three utility modules aimed at facilitating  the creation of model files, as well as loading and analyzing the MCMC chains produced by PTArcade. </p> <p>Detailed documentation for the content of these modules can be found in  the Reference section. In the next sections, we merely give a high-level overview of these utility modules.</p>"},{"location":"utils/chain_utils/","title":"Chains utilities","text":"<p>The <code>chains_utils</code> module contains several functions  that can be used to analyze the MCMC chains produced by PTArcade. On this page, we just highlight some of its functionalities. A more detailed discussion of  this module can be found in its reference page.</p> <code>import_chains</code> <p>This function can be used to load chains and model parameters of a PTArcade  run. Just type</p> <pre><code>import ptarcade.chains_utils as utils\nparams, chain = utils.import_chains('path_to_chains_folder')\n</code></pre> <p>The <code>import_chains</code> function is  particularly useful when you have multiple chains for the same model that  you want to merge. In this case, <code>import_chains</code> will do that for you by merging all the chains that are located inside the path that you pass to it. By default, <code>import_chains</code> will also remove the first 25% of each chain before merging. If you want to change the amount of burn-in, you can do so via the <code>burn_frac</code> argument. </p> <p>Finally, notice that by default, <code>import_chains</code> will only load the part of the chains corresponding to user-specified parameters, the likelihood, the posterior, and the hypermodel index. If you also want to load red noise and eventual DM parameters, you can do that by setting <code>quick_import = False</code>. </p> <code>compute_bf</code> <p>This function can be used to compute Bayes factors from runs where <code>mod_sel = True</code> in the configuration file. You can do this as follows:</p> <pre><code>import ptarcade.chains_utils as utils\nparams, chain = utils.import_chains('path_to_chains_folder')\nbf, bf_err = utils.compute_bf(chain, params)\n</code></pre> <p>This will give an estimate for the Bayes factor for the comparison of the user-specified signal against the SMBHB signal and the associated error.  By default, the Bayes factor is calculated by dividing the number of points in the chain that fall in the hypermodel bin of the user-specified signal by the number of points falling in the bin of the reference SMBHB model. For a  more precise estimate of the Bayes factor and associated error,  you can set <code>bootstrap=True</code>. In this case, the Bayes factor and its standard deviation will be derived by using bootstrapping methods.</p>"},{"location":"utils/model_utils/","title":"Model Utilities","text":"<p>The objects contained in the models_utils module can be used to facilitate the creation of model files.</p> <p>A detailed discussion of this module can be found in the  reference section. Here, we highlight some of its most useful functionalities.</p> <ul> <li> <p>Several handy constants expressed in natural units are  pre-defined in models_utils. A complete list can be found  here.</p> </li> <li> <p>The effective number of relativistic degrees of freedom contributing to  the Universe's energy and entropy densities is parametrized in the functions <code>g_rho</code> and  <code>g_s</code>. These functions, derived by  interpolating the tabulated data in Saikawa et al., can be evaluated both as a functions of  temperature (in GeV), or as a functions of frequency (in Hz). In the latter case, they  will return the value of these functions at the time of the cosmological  evolution when GWs with comoving wavenumber \\(k=2\\pi a_0 f\\) re-entered the  horizon. (1)</p> <ol> <li>Here \\(a_0\\) denotes the value of the cosmological scale factor today.  In our convention, \\(a_0=1\\).</li> </ol> </li> <li> <p>The function <code>spec_importer</code> allows the user to define the spectrum of a stochastic signal by using tabulated data. This is useful if the spectrum you are interested in is only evaluated numerically without a closed analytical expression for the stochastic signal amplitude \\(h^2 \\Omega_{\\textrm{GW}}\\). <code>spec_importer</code> expects the path to an HDF5 file containing the spectrum as a function of frequency and eventual other parameters. It returns a callable function of the frequency \\(f\\) and any other relevant parameters. In the example below, we interpolate a spectrum parametrized by frequency and one additional parameter \\(p\\).</p> <p><pre><code>import os\nfrom ptarcade.models_utils import spec_importer\npath = \"/This/Is/A/Path/to/the/HDF5/File/spectrum.h5\"\nlog_spectrum = spec_importer(path)\ndef spectrum(f, p):\nreturn 10**log_spectrum(np.log10(f), p = p)\n</code></pre> In this example, the HDF5 file was generated from a plain-text file with the following formatting: <pre><code>p    f          spectrum\n-1   -10.000000 -19.000000\n-1    -9.950000 -18.900000\n-1    -9.900000 -18.800000\n...\n-0.9 -10.000000 -19.100000\n-0.9  -9.950000 -19.000000\n-0.9  -9.900000 -18.900000\n...\n</code></pre> PTArcade provides <code>fast_interpolate.reformat</code> to convert such plain-text files to an HDF5 file that <code>fast_interpolate.interp</code> will use to quickly interpolate tabulated data. The plain-text files must meet the following requirements:</p> <ul> <li>The file has a header with at least spectrum and f present</li> <li>Each column is evenly spaced</li> <li>The f column must be last if spectrum is not. If spectrum is last, f must be the second-to-last column. </li> </ul> <p><code>fast_interpolate.reformat</code> will convert the supplied plain-text file to an HDF5 file at a specified destination with the the following HDF5 datasets:</p> <ul> <li><code>parameter_names</code> - this dataset contains the parameter names from the header other than spectrum </li> <li><code>spectrum</code> - this dataset contains the spectrum data from the original file</li> <li>There will be one additional dataset for each parameter other than spectrum. These datasets will contain two values: the minimum value the parameter can take and the step size. The example file above would generate such datasets for f and p. Assuming the HDF5 file has been read into memory as data, then you would have the following: <pre><code>print(data[\"p\"])\n[-1.0, 0.1]\nprint(data[\"f\"]\n[-10.0, 0.05]\n</code></pre></li> </ul> </li> </ul>"},{"location":"utils/plot_utils/","title":"Plot utilities","text":"<p>The <code>plot_utils</code> module contains functions that can be used to plot the MCMC chains produced by PTArcade. On this page, we give some examples of the module functionalities. A more detailed discussion can be found on its reference page.</p> <code>plot_chains</code> <p>This function can be used to produce trace plots of the chains. For example, let's say that you have a set of chains in <code>./out/model/</code>. You can produce their trace plots as follows:</p> <p><pre><code>from ptarcade import chains_utils as c_utils\nfrom ptarcade import plot_utils as p_utils\nparams, chain = c_utils.import_chains('./chains/np_model/')\np_utils.plot_chains(chain, params)\n</code></pre> This will produce the following:</p> <p></p> <p>By default, <code>plot_chains</code> will only produce trace plots for the user-specified parameters which are common across pulsars, together with the trace plots for the MCMC parameters (likelihood, posterior, and hypermodel index). If you want to produce trace plots for a different subset of the  parameters, you can do it by using the <code>params_name</code> argument. </p> <code>plot_posteriors</code> <p>This function can be used to produce posterior plots from MCMC chains:</p> <p><pre><code>from ptarcade import chains_utils as c_utils\nfrom ptarcade import plot_utils as p_utils\nparams, chain = c_utils.import_chains('./chains/np_model/')\np_utils.plot_posteriors([chain], [params])\n</code></pre> This will produce the plot below</p> <p></p>"}]}