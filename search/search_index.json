{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PTArcade","text":"<p>PTArcade provides an interface to the ENTERPRISE analysis suite and allows for simple implementation of new-physics searches in PTA data. </p> <p>The user can specify a new physics signal (either deterministic or stochastic), and the code will output Monte Carlo chains that can be used to reconstruct the model's parameter posterior distributions. </p> <p>The following illustrates how to get started with PTArcade and some basic functionalities. More informations can be found at this link.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"inputs/","title":"Input","text":"<p>All the input files required for the code to run are stored in <code>/inputs</code>. There are two types of input files required by the code: PTA data (such as timing measurements, pulsar noise parameters, etc...) provided by one of the IPTA collaborations, and info files that contain the user specified parameters (like the new-physics signal, the number of sample points, ...)</p>"},{"location":"inputs/#pulsar-data","title":"Pulsar Data","text":"<p>The essential pulsar data needed by the code to run are the <code>.tim</code> and <code>.par</code> files which need to be stored in the <code>inputs/pta_data</code> directory. </p> <p>Additional pulsar data can be used by the code (as previously, if used they need to be stored in <code>inputs/pta_data</code>). Specifically:</p> <ul> <li>White noise parameters</li> <li>Prior distributions </li> </ul> <p>PTA data for NANOGrav 12.5 and 15 years data releases, together with the ones for IPTA DR2 can be found at this link. Just download them an place them inside the <code>inputs/pta_data</code> directory. </p>"},{"location":"inputs/#user-specified-inputs","title":"User-specified inputs","text":"<p>These input files allow the user to specify the new-physics signal, and the <code>enterprise</code> parameters to use in the analaysis. These files are just python files, so any modifications to these can call other python modules/libraries, or create arrays of values algorithmically.</p>"},{"location":"inputs/#model-info-inputsmodelsmodel_info_file_namepy","title":"Model info: <code>inputs/models/(model_info_file_name).py</code>","text":"<p>Specifies the new-physics signal, and it needs to be stored in <code>/inputs/models</code>. For deterministic signals, they must include a <code>signal(toas, ...)</code> function, which specifies the signal shape as a function of the time of arrivals, <code>toas</code>, and any other model parameter. For stochastic signals, the model file must include a <code>spectrum(f,...)</code> function that specifies the cross-power spectral density of the gravitational background. </p> <p>In addition to this, for both deterministic and stochastic signals, the model file needs to include the prior of the model parameters. </p> <p>In the model file it is also possible to specify:</p> <ul> <li>The name of the model through the variable <code>name</code></li> <li>Whether or not the SMBHB signal should be added to the new physics signal by setting the variable <code>smbhb</code> to <code>True</code> or <code>False</code></li> <li>Whether or not spatial correlation should be used in the analysis by setting the variable <code>corr</code> to <code>True</code> or <code>False</code></li> <li>Groups of parameters that should be sampled together by adding their name to the list <code>group</code></li> </ul>"},{"location":"inputs/#numericsenterprise-info-inputsnumericsnumerics_info_file_namepy","title":"Numerics/enterprise info: <code>inputs/numerics/(numerics_info_file_name).py</code>","text":"<p>The numerics info allow to specify enterprise parameters for the run:</p> <ul> <li><code>pta_data</code> string that specifies the set of PTA data to use in the analysis. The user can choose among NG15 (NANOGrav 15yr data), NG12 (NANOGrav 12.5yr data), IPTA2 (IPTA DR2 data,). PTA data which are not present in the above list can also be used by passing as <code>pta_data</code> a dictionary containing the following informations<ul> <li><code>pta_data['psrs_data']</code>: string with the name of the pickle file containing the pulsar objects, or name of the folder containing the <code>.tim</code> and <code>.par</code> files</li> <li><code>pta_data['noise_data']</code>: string with the name of the folder or <code>.json</code> file containing the white noise parameters (optional, if the user does not want to use pre-derived white noise parameter this parameter can be set to <code>None</code> (object not string). In this case the code will assume flat priors for the white noise parameters and sample them in the mcmc run.)</li> <li><code>pta_data['emp_dist']</code>: string with the name of the empirical distribution file. If the user do not want to use empirical distributions, this value can be set to <code>None</code> (object not string). All the files specified in the key values of this dictionary need to be stored in <code>inputs/pta_data</code>.</li> </ul> </li> <li><code>mod_sel</code> boolean variable that specifies whether or not the model should be compared with the SMBHB signal</li> <li><code>out_dir</code> name of the directory where to save the output files</li> <li><code>N_samples</code> number of Monte Carlo trials </li> <li><code>red_components</code> number of frequency components for the pulsar intrinsic red noise </li> <li><code>gwb_components</code> number of frequency components for all the stochastic common processes </li> <li><code>A_bhb_logmin</code> lower limit for the prior of the bhb signal amplitude. If set to None -18 is used</li> <li><code>A_bhb_logmin</code> upper limit for the prior of the bhb signal amplitude. If set to None -14 is used</li> <li><code>gamma_bhb</code> spectral index for the bhb singal. If set to None it's varied between [0, 7].</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>The dependencies required to run PTArcade can be installed following either one of the following procedures</p>"},{"location":"installation/#conda-installation","title":"conda installation","text":"<p>1) Install <code>(mini)conda</code>, an environment management system for python, from here 2) Exectue  <pre><code>conda env create -f environment.yml\nconda activate non-bhb-search\n</code></pre></p>"},{"location":"installation/#pip-installation","title":"pip installation","text":""},{"location":"installation/#singularity-environment","title":"singularity environment","text":"<p>A singularity environment with all the necessary dependencies already installed can be downloaded by typing  <pre><code>singularity pull oras://ghcr.io/andrea-mitridate/non-bhb-search:latest\n</code></pre></p>"},{"location":"outputs/","title":"Output","text":"<p>The output is stored in the <code>numeric_info.out_dir/model_info.name/chain#</code>, and it consists of the usual ENTERPRISE output. </p>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#auxiliary-functionsconstants","title":"Auxiliary functions/constants","text":"<p>The <code>models_utils</code> module containts auxiliary functions and constatns that can help in the definition of the new-physics signal. Here is a brief summary of the content of this module.</p>"},{"location":"overview/#physical-constants","title":"Physical constants","text":"<p>... under construction ...</p>"},{"location":"overview/#auxiliary-functions-under-construction","title":"Auxiliary functions (under construction)","text":"<ul> <li> <p><code>g_rho</code> is a function takes as argument float <code>T</code> representing the Universe temperature in GeV and return the number of relativistic degrees of freedom.</p> </li> <li> <p><code>g_s</code> is a function takes as argument float <code>T</code> representing the Universe temperature in GeV and return the number of entropic relativistic degrees of freedom.</p> </li> <li> <p><code>Gamma</code> implementation of a gamma distribution </p> </li> <li> <p><code>omega2cross</code> is a function that takes as input the spectrum of a GWB expressed \\(h^2\\Omega(f,\\ldots)\\) and return a cross-power spectral density funtion \\(S(f,\\ldots)\\)</p> </li> <li> <p><code>spec_importer</code> takes the path to some tabulated expression for the gravitational wave spectrum and returns an interpolated function for it. The data need to be tab separated, and each column in the file needs to start with the name of the variable containted in that column. The column containing the frequency needs to be called <code>f</code> and the one containing the value of the GWB spectrum needs to be called <code>spectrum</code>.</p> </li> </ul>"},{"location":"usage/","title":"Usage","text":"<pre><code>python sampler.py -m (model info file).py -n (numeri info file).py -c (chain number)\n</code></pre> <p>enterprise.pulsar</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>ptarcade<ul> <li>chains_utils</li> <li>data<ul> <li>full_run</li> </ul> </li> <li>fast_interpolate</li> <li>input_handler</li> <li>models_utils</li> <li>plotting_utils</li> <li>pta_importer</li> <li>sampler</li> <li>signal_builder</li> </ul> </li> </ul>"},{"location":"reference/ptarcade/__init__/","title":"init","text":""},{"location":"reference/ptarcade/__init__/#ptarcade-attributes","title":"Attributes","text":""},{"location":"reference/ptarcade/__init__/#ptarcade.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = version('ptarcade')\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/","title":"chains_utils","text":"<p>Placeholder</p>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils-functions","title":"Functions","text":""},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.params_loader","title":"params_loader","text":"<pre><code>params_loader(file)\n</code></pre> <p>Loads a parameter file and returns a dictionary of the parameters with their respective values or None.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <p>The path to the prior.txt file.</p> required <p>Returns:</p> Type Description <code>dic</code> <p>A dictionary with the parameters prior ranges.</p>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.params_loader--notes","title":"Notes","text":"Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def params_loader(file):\n'''\n    Loads a parameter file and returns a dictionary of the parameters with their respective values or None.\n    Parameters\n    ----------\n    file (str): \n        The path to the prior.txt file.\n    Returns\n    -------\n    dic\n        A dictionary with the parameters prior ranges.\n    Notes\n    -----\n    '''\nparams = {}\nwith open(file) as f:\nfor line in f:\nif ':' not in line:\ncontinue\nkey = line.split(\":\")[0]\nif \"Uniform\" in line:\nmin = float(re.search('pmin=(.*?),', line).group(1))\nmax = float(re.search('pmax=(.*?)\\\\)', line).group(1))\nparams[key] = (min, max)\nelif \"Normal\" in line:\ndim = len(re.search('\\\\[(.*?)\\\\]', line).group(1).split())\nfor i in range(dim):\nparams[f\"{key}_{i}\"] = None\nelse:\nparams[key] = None\nreturn params\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.import_chains","title":"import_chains","text":"<pre><code>import_chains(\nchains_dir,\nburn_frac=1 / 4,\nquick_import=True,\nchain_ext=\".txt\",\n)\n</code></pre> <p>Import the chains and their parameter file.</p> <p>Parameters:</p> Name Type Description Default <code>chains_dir</code> <code>str</code> <p>Name of the directory containing the chains.</p> required <code>burn_frac</code> <code>float, optional</code> <p>Fraction of the chain that is removed from the head (default is \u00bc).</p> <code>1 / 4</code> <code>quick_import</code> <code>bool, optional</code> <p>Flag to skip importing the rednoise portion of chains (default is True).</p> <code>True</code> <code>chain_ext</code> <code>str, optional</code> <p>The file extension of the chain files. Compressed files can be used (default is \".txt\").</p> <code>'.txt'</code> <p>Returns:</p> Name Type Description <code>params</code> <code>dict</code> <p>Dictionary containing the parameter names and their values.</p> <code>mrgd_chain</code> <code>numpy.ndarray</code> <p>Numpy array containing the merged chains without the burn-in region.</p> <p>Raises:</p> Type Description <code>sys.exit : Exception</code> <p>Raised when the chains have different parameters.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def import_chains(chains_dir, burn_frac=1/4, quick_import=True, chain_ext=\".txt\"):\n\"\"\"\n    Import the chains and their parameter file.\n    Parameters\n    ----------\n    chains_dir : str\n        Name of the directory containing the chains.\n    burn_frac : float, optional\n        Fraction of the chain that is removed from the head (default is 1/4).\n    quick_import : bool, optional\n        Flag to skip importing the rednoise portion of chains (default is True).\n    chain_ext : str, optional\n        The file extension of the chain files. Compressed files can be used (default is \".txt\").\n    Returns\n    -------\n    params : dict\n        Dictionary containing the parameter names and their values.\n    mrgd_chain : numpy.ndarray\n        Numpy array containing the merged chains without the burn-in region.\n    Raises\n    ------\n    sys.exit : Exception\n        Raised when the chains have different parameters.\n    \"\"\"\n# get all the chain directories \ndirectories = [x for x in os.listdir(chains_dir) if not x.startswith(\".\")]\n# get the parameter lits and check that all the chains have the same parameters\nparams = params_loader(os.path.join(chains_dir, directories[0], 'priors.txt'))\nfor chain in directories:\ntemp_par = params_loader(os.path.join(chains_dir, chain, 'priors.txt'))\nif temp_par != params:\nsys.exit(\" ERROR: chains have differnt parameters.\")\n# add name for sampler parameters \nparams.update({\n'nmodel' : None,\n'log_posterior' : None,\n'log_likelihood' : None,\n'acceptance_rate' : None,\n'n_parall' : None\n})\n# import and merge all the chains removing the burn-in\nname_list = list(params.keys())\nif quick_import:\n# Search reversed list for first occurence of \"red_noise\"\n# Return the index (remember, the list is reversed!)\n# The use of `next` and a generator makes it so that we don't have to\n# search the whole list, we stop when we get the first match\nred_noise_ind = next((i for i in enumerate(name_list[::-1]) if \"red_noise\" in i[1]))[0]\n# Slice the list so that we begin directly after the index found above\nusecols = name_list[-1*red_noise_ind:]\nparams = {name: params[name] for name in usecols}\nelse:\nusecols = name_list\ndtypes = {name: float for name in usecols}\n# import and merge all the chains removing the burn-in\nprint(\"Starting import from\", chains_dir)\nstart_time = time.time()\nif chain_ext==\".feather\":\ntable_list = []\nfor dir in directories:\ntable = pf.read_table(os.path.join(chains_dir, dir, 'chain_1' + chain_ext), columns=usecols)\ntable_list.append(table.slice(offset=int(table.num_rows * burn_frac)).drop_null())\nmrgd_chain = pa.concat_tables(table_list).to_pandas()\nelif chain_ext==\".parquet\":\ntable_list = []\nfor dir in directories:\ntable = pq.read_table(os.path.join(chains_dir, dir, 'chain_1' + chain_ext), columns=usecols)\ntable_list.append(table.slice(offset=int(table.num_rows * burn_frac)).drop_null())\nmrgd_chain = pa.concat_tables(table_list).to_pandas()\nelse:\nmrgd_chain = pd.concat((pd.read_csv(\nos.path.join(chains_dir, dir, 'chain_1' + chain_ext),\nsep='\\t',\nnames=name_list,\ndtype=dtypes,\nusecols=usecols).iloc[lambda x: int(len(x) * burn_frac) &lt;= x.index]\nfor dir in directories),\nignore_index=True,\nsort=False)\nmrgd_chain = mrgd_chain.dropna()\nmrgd_chain = mrgd_chain.to_numpy(dtype=float)\nprint(f\"Finished importing   {chains_dir} in {time.time() - start_time:.2f}s\")\nreturn params, mrgd_chain\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.chain_filter","title":"chain_filter","text":"<pre><code>chain_filter(chain, params, model_id, par_to_plot)\n</code></pre> <p>This function filters the rows in the provided chain according to the specified model and parameters. It selects rows that correspond to the specified model ID and parameters to plot their posteriors.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>numpy.ndarray</code> <p>The Markov Chain Monte Carlo (MCMC) chain to be filtered. This should be a multi-dimensional array where each row represents a state in the chain, and each column represents a parameter.</p> required <p>params : list of str     The names of the parameters in the chain. This should be a list of strings with the same length as the number     of columns in the chain.</p> <p>model_id : int or None     The ID of the model to filter the chain for. This should be either 0 or 1. If None, the function will select     rows for model 0.</p> <p>par_to_plot : list of str or None     The names of the parameters to filter the chain for. If None, the function will select all parameters except     'nmodel', 'log_posterior', 'log_likelihood', 'acceptance_rate', and 'n_parall', and parameters containing '+' or '-'.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the filtered chain and the list of filtered parameters:</p> <ul> <li> <p>chain: numpy.ndarray The filtered chain, containing only rows corresponding to the specified model ID and parameters.</p> </li> <li> <p>filtered_par: list of str The list of filtered parameter names.</p> </li> </ul> <p>Raises:</p> Type Description <code>SystemExit</code> <p>If the provided model_id is not an integer equal to 0 or 1.</p>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.chain_filter--notes","title":"Notes","text":"<p>This function filters the chain in-place, meaning that the original chain will be modified.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def chain_filter(chain, params, model_id, par_to_plot):\n\"\"\"\n    This function filters the rows in the provided chain according to the specified model and parameters. It selects\n    rows that correspond to the specified model ID and parameters to plot their posteriors.\n    Parameters\n    ----------\n    chain : numpy.ndarray\n        The Markov Chain Monte Carlo (MCMC) chain to be filtered. This should be a multi-dimensional array where each\n        row represents a state in the chain, and each column represents a parameter.\n    params : list of str\n        The names of the parameters in the chain. This should be a list of strings with the same length as the number\n        of columns in the chain.\n    model_id : int or None\n        The ID of the model to filter the chain for. This should be either 0 or 1. If None, the function will select\n        rows for model 0.\n    par_to_plot : list of str or None\n        The names of the parameters to filter the chain for. If None, the function will select all parameters except\n        'nmodel', 'log_posterior', 'log_likelihood', 'acceptance_rate', and 'n_parall', and parameters containing '+' or '-'.\n    Returns\n    -------\n    tuple\n        A tuple containing the filtered chain and the list of filtered parameters:\n        - chain: numpy.ndarray\n            The filtered chain, containing only rows corresponding to the specified model ID and parameters.\n        - filtered_par: list of str\n            The list of filtered parameter names.\n    Raises\n    ------\n    SystemExit\n        If the provided model_id is not an integer equal to 0 or 1.\n    Notes\n    -----\n    This function filters the chain in-place, meaning that the original chain will be modified.\n    \"\"\"\nnmodel_idx = list(params).index('nmodel')\nif model_id is None:\nprint(\"No model ID specified, posteriors are plotted for model 0\")\nfilter_model = chain[:, nmodel_idx] &lt; 0.5\nelif model_id == 0:\nfilter_model = chain[:, nmodel_idx] &lt; 0.5\nelif model_id == 1:\nfilter_model = chain[:, nmodel_idx] &gt; 0.5\nelse:\nsys.exit(\" ERROR: model_idx can only be an integer equal to 0 or 1\")\nchain = chain[filter_model]\nif par_to_plot:\nfilter_par = [list(params).index(x) for x in par_to_plot if x in params]\nelse:\nfilter_par = [list(params).index(x)\nfor x in params \nif x\nnot in [\n\"nmodel\",\n\"log_posterior\",\n\"log_likelihood\",\n\"acceptance_rate\",\n\"n_parall\"]\nand '+' not in x\nand '-' not in x]\nfiltered_par = [par.replace('_','-') for par in params[filter_par]]\nfiltered_par = [par.replace('np-', '') if 'gw-bhb-np' in par else par for par in filtered_par]\nreturn chain[:, filter_par], filtered_par\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.calc_df","title":"calc_df","text":"<pre><code>calc_df(chain)\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.calc_df--input","title":"Input","text":"<p>chain: input dropout chain, with shape assumed to be n_bootstrap x n_samples</p>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.calc_df--output","title":"Output","text":"<p>bayes_facs: dropout bayes factor, with shape n_bootstrap</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def calc_df(chain,):\n\"\"\"\n    Input\n    ============\n    chain: input dropout chain, with shape assumed to be n_bootstrap x n_samples\n    Output\n    ============\n    bayes_facs: dropout bayes factor, with shape n_bootstrap\n    \"\"\"\nbayes_facs = np.full(chain.shape[0], 0.0)\nfor ii, arr in enumerate(chain):\nbayes_facs[ii] = model_utils.odds_ratio(arr)[0]\nreturn bayes_facs\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.bf_bootstrap","title":"bf_bootstrap","text":"<pre><code>bf_bootstrap(chain, burn = 0)\n</code></pre> <p>This function computes the mean and variance of the bayes factor after bootstrapping  for a given chain.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>numpy.ndarray</code> <p>The Markov Chain Monte Carlo (MCMC) chain to be analyzed. This should be a multi-dimensional array where each row  represents a state in the chain, and each column represents a parameter.</p> required <p>burn : int, optional     The burn-in period to be discarded from the start of the chain. This should be a non-negative integer.      If not provided, no burn-in period will be discarded.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the mean and variance of the bootstrapped bayes factors:</p> <ul> <li> <p>mean: float The mean of the bootstrapped degrees of freedom distribution.</p> </li> <li> <p>var: float The variance of the bootstrapped degrees of freedom distribution.</p> </li> </ul>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.bf_bootstrap--notes","title":"Notes","text":"<p>This function uses the 'acor' library to compute the autocorrelation time of the chain, which is then used to thin the chain.  The thinned chain is then bootstrapped using the 'bootstrap' function with the 'calc_df' user statistic, to obtain a distribution  of degrees of freedom. The mean and variance of this distribution are then computed.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def bf_bootstrap(chain, burn=0):\n\"\"\"\n    This function computes the mean and variance of the bayes factor after bootstrapping \n    for a given chain.\n    Parameters\n    ----------\n    chain : numpy.ndarray\n        The Markov Chain Monte Carlo (MCMC) chain to be analyzed. This should be a multi-dimensional array where each row \n        represents a state in the chain, and each column represents a parameter.\n    burn : int, optional\n        The burn-in period to be discarded from the start of the chain. This should be a non-negative integer. \n        If not provided, no burn-in period will be discarded.\n    Returns\n    -------\n    tuple\n        A tuple containing the mean and variance of the bootstrapped bayes factors:\n        - mean: float\n            The mean of the bootstrapped degrees of freedom distribution.\n        - var: float\n            The variance of the bootstrapped degrees of freedom distribution.\n    Notes\n    -----\n    This function uses the 'acor' library to compute the autocorrelation time of the chain, which is then used to thin the chain. \n    The thinned chain is then bootstrapped using the 'bootstrap' function with the 'calc_df' user statistic, to obtain a distribution \n    of degrees of freedom. The mean and variance of this distribution are then computed.\n    \"\"\"\ncorr_len = int(acor.acor(chain[burn:,-1])[0])\ntest = chain[burn::corr_len]\ndf_dist_bs = bootstrap(test[:,0], n_bootstraps = 50000, user_statistic = calc_df)\nmean = np.mean(df_dist_bs)\nvar = np.var(df_dist_bs)\nreturn mean, var\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.compute_bf","title":"compute_bf","text":"<pre><code>compute_bf(chain, params, bootstrap = False)\n</code></pre> <p>Computes the Bayes factor and estimate its uncertainty.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>numpy.ndarray</code> <p>The Markov Chain Monte Carlo (MCMC) chain to be analyzed. This should be a multi-dimensional array where each row represents  a state in the chain, and each column represents a parameter. The 'nmodel' and 'log_posterior' columns should be used to specify the model index and the log of the posterior probabilities.</p> required <p>params : list of str     The names of the parameters in the chain. This should be a list of strings with the same length as the number of columns in the chain.      It is expected to contain 'nmodel' and 'log_posterior', which will be used to filter the chain based on the model index and compute the Bayes factor.</p> <p>bootstrap : bool, optional     A flag indicating whether to compute the Bayes factor using a bootstrap method. If True, the Bayes factor will be computed      using the 'get_bf' function. The bootsrap calculation is significantly slower.     Defaults to False.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the following elements:</p> <ul> <li> <p>bf: float The computed Bayes factor. This gives the evidence for model 0 over model 1. A higher value provides stronger evidence for model 0.</p> </li> <li> <p>unc: float The computed uncertainty of the Bayes factor.</p> </li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If 'nmodel' or 'log_posterior' is not found in the 'params' list.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def compute_bf(chain, params, bootstrap=False):\n\"\"\"\n    Computes the Bayes factor and estimate its uncertainty.\n    Parameters\n    ----------\n    chain : numpy.ndarray\n        The Markov Chain Monte Carlo (MCMC) chain to be analyzed. This should be a multi-dimensional array where each row represents \n        a state in the chain, and each column represents a parameter. The 'nmodel' and 'log_posterior' columns should be used to specify the model index and the log of the posterior probabilities.\n    params : list of str\n        The names of the parameters in the chain. This should be a list of strings with the same length as the number of columns in the chain. \n        It is expected to contain 'nmodel' and 'log_posterior', which will be used to filter the chain based on the model index and compute the Bayes factor.\n    bootstrap : bool, optional\n        A flag indicating whether to compute the Bayes factor using a bootstrap method. If True, the Bayes factor will be computed \n        using the 'get_bf' function. The bootsrap calculation is significantly slower.\n        Defaults to False.\n    Returns\n    -------\n    tuple\n        A tuple containing the following elements:\n        - bf: float\n            The computed Bayes factor. This gives the evidence for model 0 over model 1. A higher value provides stronger evidence for model 0.\n        - unc: float\n            The computed uncertainty of the Bayes factor.\n    Raises\n    ------\n    ValueError\n        If 'nmodel' or 'log_posterior' is not found in the 'params' list.\n    \"\"\"\nnmodel_idx = list(params).index('nmodel')\nposterior_idx = list(params).index('log_posterior')\nif bootstrap:\ndata = chain[:,[nmodel_idx, posterior_idx]]\nbf, unc = bf_bootstrap(data)\nelse:\nbf, unc = model_utils.odds_ratio(chain[:, nmodel_idx], models=[0,1])\nreturn bf, unc\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.bisection","title":"bisection","text":"<pre><code>bisection(f, a, b, tol)\n</code></pre> <p>This function implements the bisection method for root finding of a real-valued function. It recursively divides  the interval [a, b] into two subintervals until the absolute value of f evaluated at the midpoint is less than  the specified tolerance, at which point it returns the midpoint as an approximation of the root.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>function</code> <p>The function for which the root is to be found. It must be real-valued and continuous on the interval [a, b].</p> required <p>a : float     The left endpoint of the interval in which the root is sought. It must be less than b.</p> <p>b : float     The right endpoint of the interval in which the root is sought. It must be greater than a.</p> <p>tol : float     The tolerance for the root approximation. The function will return when the absolute value of f evaluated at      the midpoint is less than tol. It must be greater than 0.</p> <p>Returns:</p> Type Description <code>float or None</code> <p>The midpoint of the final subinterval if a root is found; None otherwise. The root approximation m is guaranteed  to satisfy |f(m)| &lt; tol if the function converges.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a is not less than b, or if tol is not greater than 0.</p>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.bisection--notes","title":"Notes","text":"<p>This is a recursive implementation of the bisection method. The bisection method assumes that the function f changes  sign over the interval [a, b], which implies that a root exists in this interval by the Intermediate Value Theorem.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def bisection(f, a, b, tol): \n\"\"\"\n    This function implements the bisection method for root finding of a real-valued function. It recursively divides \n    the interval [a, b] into two subintervals until the absolute value of f evaluated at the midpoint is less than \n    the specified tolerance, at which point it returns the midpoint as an approximation of the root.\n    Parameters\n    ----------\n    f : function\n        The function for which the root is to be found. It must be real-valued and continuous on the interval [a, b].\n    a : float\n        The left endpoint of the interval in which the root is sought. It must be less than b.\n    b : float\n        The right endpoint of the interval in which the root is sought. It must be greater than a.\n    tol : float\n        The tolerance for the root approximation. The function will return when the absolute value of f evaluated at \n        the midpoint is less than tol. It must be greater than 0.\n    Returns\n    -------\n    float or None\n        The midpoint of the final subinterval if a root is found; None otherwise. The root approximation m is guaranteed \n        to satisfy |f(m)| &lt; tol if the function converges.\n    Raises\n    ------\n    ValueError\n        If a is not less than b, or if tol is not greater than 0.\n    Notes\n    -----\n    This is a recursive implementation of the bisection method. The bisection method assumes that the function f changes \n    sign over the interval [a, b], which implies that a root exists in this interval by the Intermediate Value Theorem.\n    \"\"\"\nif np.sign(f(a)) == np.sign(f(b)):\nreturn None\nm = (a + b)/2\nif np.abs(f(m)) &lt; tol:\nreturn m\nelif np.sign(f(a)) == np.sign(f(m)):\nreturn bisection(f, m, b, tol)\nelif np.sign(f(b)) == np.sign(f(m)):\nreturn bisection(f, a, m, tol)\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.k_ratio_aux_1D","title":"k_ratio_aux_1D","text":"<pre><code>k_ratio_aux_1D(sample, bf, par, par_range, k_ratio)\n</code></pre> <p>Returns the bound value for a given k-ratio in a 1D posterior density plot.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>MCSamples</code> <p>An instance of the MCSamples class, containing the multivariate  Monte Carlo samples on which the function is operating.</p> required <code>bf</code> <code>float</code> <p>The Bayes factor for the exotic + SMBHB vs. SMBHB model.  Represents the strength of evidence in favour of the exotic model.</p> required <code>par</code> <code>str</code> <p>The name of the parameter for which the k-ratio bound should be computed.</p> required <code>par_range</code> <code>list of float</code> <p>The lower and upper prior limits for the parameter. It is represented as a list where  the first element is the lower limit and the second element is the upper limit.</p> required <code>k_ratio</code> <code>float</code> <p>The fraction of plateau height at which the height level is determined. This is used  to compute the height_KB, which represents the height at which the bound is computed.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The computed k-ratio bound value. This is the value of the parameter at which the  1D posterior density crosses the height_KB. </p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the integration or the bisection search fails due to numerical issues or  if the specified parameter range does not contain a valid root.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def k_ratio_aux_1D(\nsample, \nbf, \npar,\npar_range,\nk_ratio):\n\"\"\"\n    Returns the bound value for a given k-ratio in a 1D posterior density plot.\n    Parameters\n    ----------\n    sample : MCSamples\n        An instance of the MCSamples class, containing the multivariate \n        Monte Carlo samples on which the function is operating.\n    bf : float\n        The Bayes factor for the exotic + SMBHB vs. SMBHB model. \n        Represents the strength of evidence in favour of the exotic model.\n    par : str\n        The name of the parameter for which the k-ratio bound should be computed.\n    par_range : list of float\n        The lower and upper prior limits for the parameter. It is represented as a list where \n        the first element is the lower limit and the second element is the upper limit.\n    k_ratio : float\n        The fraction of plateau height at which the height level is determined. This is used \n        to compute the height_KB, which represents the height at which the bound is computed.\n    Returns\n    -------\n    float\n        The computed k-ratio bound value. This is the value of the parameter at which the \n        1D posterior density crosses the height_KB. \n    Raises\n    ------\n    ValueError\n        If the integration or the bisection search fails due to numerical issues or \n        if the specified parameter range does not contain a valid root.\n    \"\"\"\ndensity1D = MCSamples.get1DDensity(sample, par)\nnorm = integrate.quad(density1D, par_range[0], par_range[1], full_output=1)[0]\nprior = 1/(par_range[1]-par_range[0])\nheight_KB = k_ratio*prior/bf*norm\nk_val = bisection(f = (lambda x: density1D(x)-height_KB), a = par_range[0], b = par_range[1], tol = 10**(-8))\nreturn k_val\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.k_ratio_aux_2D","title":"k_ratio_aux_2D","text":"<pre><code>k_ratio_aux_2D(\nsample,\nbf,\npar_1,\npar_2,\npar_range_1,\npar_range_2,\nk_ratio,\n)\n</code></pre> <p>Returns the height level corresponding to the given k-ratio in a 2D posterior density plot.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>MCSamples</code> <p>An instance of the MCSamples class, containing the multivariate  Monte Carlo samples on which the function is operating.</p> required <code>bf</code> <code>float</code> <p>The Bayes factor for the exotic + SMBHB vs. SMBHB model.  Represents the strength of evidence in favour of the exotic model.</p> required <code>par_1</code> <code>str</code> <p>The names of the two parameters for which the k-ratio bound should be computed.</p> required <code>par_2</code> <code>str</code> <p>The names of the two parameters for which the k-ratio bound should be computed.</p> required <code>par_range_1</code> <code>list of float</code> <p>The lower and upper prior limits for the parameters. Each is represented as a list  where the first element is the lower limit and the second element is the upper limit.</p> required <code>par_range_2</code> <code>list of float</code> <p>The lower and upper prior limits for the parameters. Each is represented as a list  where the first element is the lower limit and the second element is the upper limit.</p> required <code>k_ratio</code> <code>float</code> <p>The fraction of plateau height at which the height level is determined. This is used  to compute the height_KB, which represents the height at which the bound is computed.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The computed height level in the 2D posterior density plot. This is the height at which  the density equals the computed height_KB.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the double integration fails due to numerical issues.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def k_ratio_aux_2D(\nsample, \nbf, \npar_1, \npar_2, \npar_range_1, \npar_range_2, \nk_ratio):\n\"\"\"\n    Returns the height level corresponding to the given k-ratio in a 2D posterior density plot.\n    Parameters\n    ----------\n    sample : MCSamples\n        An instance of the MCSamples class, containing the multivariate \n        Monte Carlo samples on which the function is operating.\n    bf : float\n        The Bayes factor for the exotic + SMBHB vs. SMBHB model. \n        Represents the strength of evidence in favour of the exotic model.\n    par_1, par_2 : str\n        The names of the two parameters for which the k-ratio bound should be computed.\n    par_range_1, par_range_2 : list of float\n        The lower and upper prior limits for the parameters. Each is represented as a list \n        where the first element is the lower limit and the second element is the upper limit.\n    k_ratio : float\n        The fraction of plateau height at which the height level is determined. This is used \n        to compute the height_KB, which represents the height at which the bound is computed.\n    Returns\n    -------\n    float\n        The computed height level in the 2D posterior density plot. This is the height at which \n        the density equals the computed height_KB.\n    Raises\n    ------\n    ValueError\n        If the double integration fails due to numerical issues.\n    \"\"\"\ndensity2D = MCSamples.get2DDensity(sample, par_1, par_2)\nwith warnings.catch_warnings():\nwarnings.simplefilter(\"ignore\")\nnorm = integrate.dblquad(density2D, par_range_2[0], par_range_2[1], par_range_1[0], par_range_1[1])[0]#Calculate prior value at each point\nprior = 1/(par_range_2[1]-par_range_2[0]) * 1/(par_range_1[1]-par_range_1[0])\nheight_KB = k_ratio*prior/bf*norm\nreturn height_KB\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.get_k_levels","title":"get_k_levels","text":"<pre><code>get_k_levels(sample, pars, priors, bf, k_ratio)\n</code></pre> <p>Computes and returns the 1D and 2D k-ratio bounds for a given set of parameters.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>MCSamples</code> <p>An instance of the MCSamples class, containing the multivariate  Monte Carlo samples on which the function is operating.</p> required <code>pars</code> <code>list of str</code> <p>The list of all parameters for which the k-ratio bounds should be computed.  The parameters 'gw-bhb-0' and 'gw-bhb-1' are excluded from this computation.</p> required <code>priors</code> <code>dict</code> <p>A dictionary containing the lower and upper prior limits for each parameter.  Each key-value pair in the dictionary corresponds to a parameter and its limits,  respectively.</p> required <code>bf</code> <code>float</code> <p>The Bayes factor for the exotic + SMBHB vs. SMBHB model.  Represents the strength of evidence in favour of the exotic model.</p> required <code>k_ratio</code> <code>float</code> <p>The fraction of plateau height at which the height level is determined.</p> required <p>Returns:</p> Type Description <code>np.ndarray, np.ndarray</code> <p>Two numpy arrays representing the 1D and 2D k-ratio bounds, respectively.  Each element in the arrays is a list where the first elements are the parameter names  and the last element is the computed k-ratio bound.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def get_k_levels(sample, pars, priors, bf, k_ratio):\n\"\"\"\n    Computes and returns the 1D and 2D k-ratio bounds for a given set of parameters.\n    Parameters\n    ----------\n    sample : MCSamples\n        An instance of the MCSamples class, containing the multivariate \n        Monte Carlo samples on which the function is operating.\n    pars : list of str\n        The list of all parameters for which the k-ratio bounds should be computed. \n        The parameters 'gw-bhb-0' and 'gw-bhb-1' are excluded from this computation.\n    priors : dict\n        A dictionary containing the lower and upper prior limits for each parameter. \n        Each key-value pair in the dictionary corresponds to a parameter and its limits, \n        respectively.\n    bf : float\n        The Bayes factor for the exotic + SMBHB vs. SMBHB model. \n        Represents the strength of evidence in favour of the exotic model.\n    k_ratio : float\n        The fraction of plateau height at which the height level is determined.\n    Returns\n    -------\n    np.ndarray, np.ndarray\n        Two numpy arrays representing the 1D and 2D k-ratio bounds, respectively. \n        Each element in the arrays is a list where the first elements are the parameter names \n        and the last element is the computed k-ratio bound.\n    \"\"\"\nnp_pars = [p for p in pars if p not in [\"gw-bhb-0\", \"gw-bhb-1\"]]\nlevels_2d = []\nfor par_1, par_2 in combinations(np_pars, r=2):\nlevels_2d.append(\n[par_1,\npar_2,\nk_ratio_aux_2D(\nsample=sample,\nbf=bf,\npar_1=par_1,\npar_2=par_2,\npar_range_1=priors[par_1],\npar_range_2=priors[par_2],\nk_ratio=k_ratio)])\nlevels_1d = []\nfor par in np_pars:\nlevels_1d.append(\n[par,\nk_ratio_aux_1D(\nsample = sample,\nbf = bf,\npar = par,\npar_range = priors[par],\nk_ratio = k_ratio)])\nreturn np.array(levels_1d), np.array(levels_2d)\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.get_bayes_est","title":"get_bayes_est","text":"<pre><code>get_bayes_est(samples, params)\n</code></pre> <p>Computes and returns the Bayesian estimates for a given set of parameters  based on a sample of data.</p> <p>Parameters:</p> Name Type Description Default <code>samples</code> <code>MCSamples</code> <p>An instance of the MCSamples class, containing the multivariate  Monte Carlo samples on which the function is operating.</p> required <code>params</code> <code>list of str</code> <p>The list of parameters for which the Bayesian estimates should be computed.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representing the Bayesian estimates for each parameter.  Each key-value pair in the dictionary corresponds to a parameter and its  Bayesian estimate, respectively. Each estimate is represented as a tuple,  where the first element is the mean and the second element is the standard  deviation.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def get_bayes_est(samples, params):\n\"\"\"\n    Computes and returns the Bayesian estimates for a given set of parameters \n    based on a sample of data.\n    Parameters\n    ----------\n    samples : MCSamples\n        An instance of the MCSamples class, containing the multivariate \n        Monte Carlo samples on which the function is operating.\n    params : list of str\n        The list of parameters for which the Bayesian estimates should be computed.\n    Returns\n    -------\n    dict\n        A dictionary representing the Bayesian estimates for each parameter. \n        Each key-value pair in the dictionary corresponds to a parameter and its \n        Bayesian estimate, respectively. Each estimate is represented as a tuple, \n        where the first element is the mean and the second element is the standard \n        deviation.\n    \"\"\"\nx = list(samples.setMeans())\nxerr = list(np.sqrt(samples.getVars()))\nx = zip(x, xerr)\nx = dict(zip(params, x))\nreturn x\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.get_max_pos","title":"get_max_pos","text":"<pre><code>get_max_pos(params, bayes_est, sample, priors, spc = 10)\n</code></pre> <p>Computes and returns the maximum posterior position for a given set of parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>list of str</code> <p>The list of parameters for which the maximum posterior position should be computed.</p> required <code>bayes_est</code> <code>dict</code> <p>A dictionary containing the Bayesian estimates for each parameter.  Each key-value pair in the dictionary corresponds to a parameter and its  Bayesian estimate, respectively. Each estimate is represented as a tuple,  where the first element is the mean and the second element is the standard  deviation.</p> required <code>sample</code> <code>MCSamples</code> <p>An instance of the MCSamples class, containing the multivariate  Monte Carlo samples on which the function is operating.</p> required <code>priors</code> <code>dict</code> <p>A dictionary containing the lower and upper prior limits for each parameter.  Each key-value pair in the dictionary corresponds to a parameter and its limits,  respectively.</p> required <code>spc</code> <code>int, optional</code> <p>The number of equally spaced points to be considered within the bounds of  each parameter when searching for the maximum posterior position. Default is 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representing the maximum posterior positions for each parameter.  Each key-value pair in the dictionary corresponds to a parameter and its  maximum posterior position, respectively.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def get_max_pos(params, bayes_est, sample, priors, spc=10):\n\"\"\"\n    Computes and returns the maximum posterior position for a given set of parameters.\n    Parameters\n    ----------\n    params : list of str\n        The list of parameters for which the maximum posterior position should be computed.\n    bayes_est : dict\n        A dictionary containing the Bayesian estimates for each parameter. \n        Each key-value pair in the dictionary corresponds to a parameter and its \n        Bayesian estimate, respectively. Each estimate is represented as a tuple, \n        where the first element is the mean and the second element is the standard \n        deviation.\n    sample : MCSamples\n        An instance of the MCSamples class, containing the multivariate \n        Monte Carlo samples on which the function is operating.\n    priors : dict\n        A dictionary containing the lower and upper prior limits for each parameter. \n        Each key-value pair in the dictionary corresponds to a parameter and its limits, \n        respectively.\n    spc : int, optional\n        The number of equally spaced points to be considered within the bounds of \n        each parameter when searching for the maximum posterior position. Default is 10.\n    Returns\n    -------\n    dict\n        A dictionary representing the maximum posterior positions for each parameter. \n        Each key-value pair in the dictionary corresponds to a parameter and its \n        maximum posterior position, respectively.\n    \"\"\"\nout = {}\nfor par in params:\nbounds = priors.get(par)\ndensity =  MCSamples.get1DDensity(sample, par, normalized=False)\nmind = lambda x: -density(x)[0]\nif not bounds:\nx = minimize(mind, np.array(bayes_est.get(par)[0]))\nx0 = x.x\nd0 = mind(x0)\nelse:\nini = np.linspace(bounds[0], bounds[1], spc)\nini = [val for val in ini]\nini.append(bayes_est.get(par)[0])\nx = []\nfor i in range(len(ini)):\nx1 = minimize(mind, ini[i])\nx.append(x1.x)\nbnds = Bounds(bounds[0], bounds[1])\nx2 = minimize(mind, ini[i], bounds=bnds)\nx.append(x2.x)\nd0 = 0\nx0 = 0\nfor val in x:\nif(mind(val)&lt;d0):\nx0 = val\nd0 = mind(val)\nout[par] = x0[0]\nreturn out\n</code></pre>"},{"location":"reference/ptarcade/chains_utils/#ptarcade.chains_utils.get_c_levels","title":"get_c_levels","text":"<pre><code>get_c_levels(sample, pars, levels)\n</code></pre> <p>Computes and returns the highest posterior interval (HPI) for a given set of parameters  and confidence levels.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>MCSamples</code> <p>An instance of the MCSamples class, containing the multivariate  Monte Carlo samples on which the function is operating.</p> required <code>pars</code> <code>list of str</code> <p>The list of parameters for which the HPI should be computed.</p> required <code>levels</code> <code>list of float</code> <p>The list of confidence levels for which the HPI should be computed.  Each value in the list should be between 0 and 1.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>A numpy array representing the HPI for each parameter and each confidence level.  Each element in the array is a list, where the first element is a parameter name and  the second element is a list of HPIs for each confidence level.</p> Source code in <code>src/ptarcade/chains_utils.py</code> <pre><code>def get_c_levels(sample, pars, levels):\n\"\"\"\n    Computes and returns the highest posterior interval (HPI) for a given set of parameters \n    and confidence levels.\n    Parameters\n    ----------\n    sample : MCSamples\n        An instance of the MCSamples class, containing the multivariate \n        Monte Carlo samples on which the function is operating.\n    pars : list of str\n        The list of parameters for which the HPI should be computed.\n    levels : list of float\n        The list of confidence levels for which the HPI should be computed. \n        Each value in the list should be between 0 and 1.\n    Returns\n    -------\n    np.ndarray\n        A numpy array representing the HPI for each parameter and each confidence level. \n        Each element in the array is a list, where the first element is a parameter name and \n        the second element is a list of HPIs for each confidence level.\n    \"\"\"\nhpi = []\nfor par in pars: \ndensity = MCSamples.get1DDensity(sample, par)\npoints = [[]] * len(levels)\nfor idx, level in enumerate(levels):\nx = density.getLimits(level)\nif not x[-1] and not x[-2]:\npoints[idx] = [x[0], x[1]]\nelif not x[-1]:\npoints[idx] = [False, x[1]]\nelif not x[-2]:\npoints[idx] = [x[0], False]\nelse:\npoints[idx] = [False, False]\nhpi.append([par, points])\nreturn np.array(hpi, dtype='object')\n</code></pre>"},{"location":"reference/ptarcade/fast_interpolate/","title":"fast_interpolate","text":""},{"location":"reference/ptarcade/fast_interpolate/#ptarcade.fast_interpolate-functions","title":"Functions","text":""},{"location":"reference/ptarcade/fast_interpolate/#ptarcade.fast_interpolate.load_data","title":"load_data","text":"<pre><code>load_data(file)\n</code></pre> Source code in <code>src/ptarcade/fast_interpolate.py</code> <pre><code>def load_data(file):\nwith h5py.File(file) as h5:\ninfo = [(par, h5[par][0], h5[par][1]) for par in h5['parameter_names'].asstr()]\nspectrum = np.array(h5['spectrum'])\nreturn (info, spectrum)\n</code></pre>"},{"location":"reference/ptarcade/fast_interpolate/#ptarcade.fast_interpolate.interp","title":"interp","text":"<pre><code>interp(info, data)\n</code></pre> Source code in <code>src/ptarcade/fast_interpolate.py</code> <pre><code>def interp(info, data):\nif len(info) == 0:       # Nothing to do: just return element\nreturn data\nx0, dx, x = info[0]\n(fract, index) = np.modf((x - x0) / dx)\nindex = index.astype(int)\n# Call ourselves to interpolate over remaining variables if any\n# then combine results linearly\nreturn (interp(info[1:], data[index]) * (1-fract)\n+ interp(info[1:], data[index+1]) * fract)\n</code></pre>"},{"location":"reference/ptarcade/fast_interpolate/#ptarcade.fast_interpolate.reformat","title":"reformat","text":"<pre><code>reformat(infile, outfile)\n</code></pre> Source code in <code>src/ptarcade/fast_interpolate.py</code> <pre><code>def reformat(infile, outfile):\npar_names = np.loadtxt(infile, max_rows=1, dtype='str') # Parameter names\ndata = np.loadtxt(infile, skiprows=1)\nspec_col = np.where(par_names=='spectrum')[0] # Index of spectrum\nspectrum = data.T[spec_col]              # List of data\ndata = np.delete(data, spec_col, axis=1)      # Remove data\npar_names = np.delete(par_names, spec_col)    # and 'spectrum'\nshape = np.zeros(len(par_names))              # This will be shape of data array\nwith h5py.File(outfile,'w') as out:\nout.create_dataset(\"parameter_names\", data=par_names.tolist())\nfor idx, par in enumerate(par_names):\nif par == 'f' and idx != len(par_names)-1:\nraise Exception(\"f field should have been last\") # Otherwise interp can't do multiple probes\nvalues = np.sort(np.unique(data.T[idx]))\ndataset = out.create_dataset(par, data=[values[0], values[1]-values[0]]) # Start and step\nshape[idx] = len(values)\nout.create_dataset(\"spectrum\", data=spectrum, shape=shape) # Reshape and write\n</code></pre>"},{"location":"reference/ptarcade/input_handler/","title":"input_handler","text":""},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler-classes","title":"Classes","text":""},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.bcolors","title":"bcolors","text":"Source code in <code>src/ptarcade/input_handler.py</code> <pre><code>class bcolors:\nHEADER = '\\033[95m'\nOKBLUE = '\\033[94m'\nOKCYAN = '\\033[96m'\nOKGREEN = '\\033[92m'\nWARNING = \"\\033[0;33m\"\nFAIL = '\\033[0;31m'\nENDC = '\\033[0m'\nBOLD = '\\033[1m'\nUNDERLINE = '\\033[4m'\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.bcolors-attributes","title":"Attributes","text":""},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.bcolors.HEADER","title":"HEADER  <code>instance-attribute</code> <code>class-attribute</code>","text":"<pre><code>HEADER = '\\x1b[95m'\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.bcolors.OKBLUE","title":"OKBLUE  <code>instance-attribute</code> <code>class-attribute</code>","text":"<pre><code>OKBLUE = '\\x1b[94m'\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.bcolors.OKCYAN","title":"OKCYAN  <code>instance-attribute</code> <code>class-attribute</code>","text":"<pre><code>OKCYAN = '\\x1b[96m'\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.bcolors.OKGREEN","title":"OKGREEN  <code>instance-attribute</code> <code>class-attribute</code>","text":"<pre><code>OKGREEN = '\\x1b[92m'\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.bcolors.WARNING","title":"WARNING  <code>instance-attribute</code> <code>class-attribute</code>","text":"<pre><code>WARNING = '\\x1b[0;33m'\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.bcolors.FAIL","title":"FAIL  <code>instance-attribute</code> <code>class-attribute</code>","text":"<pre><code>FAIL = '\\x1b[0;31m'\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.bcolors.ENDC","title":"ENDC  <code>instance-attribute</code> <code>class-attribute</code>","text":"<pre><code>ENDC = '\\x1b[0m'\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.bcolors.BOLD","title":"BOLD  <code>instance-attribute</code> <code>class-attribute</code>","text":"<pre><code>BOLD = '\\x1b[1m'\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.bcolors.UNDERLINE","title":"UNDERLINE  <code>instance-attribute</code> <code>class-attribute</code>","text":"<pre><code>UNDERLINE = '\\x1b[4m'\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler-functions","title":"Functions","text":""},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.import_file","title":"import_file","text":"<pre><code>import_file(full_name, path)\n</code></pre> <p>Import a python module from a path. 3.4+ only. Does not call sys.modules[full_name] = path</p> Source code in <code>src/ptarcade/input_handler.py</code> <pre><code>def import_file(full_name, path):\n\"\"\"\n        Import a python module from a path. 3.4+ only.\n        Does not call sys.modules[full_name] = path\n    \"\"\"\nfrom importlib import util\nspec = util.spec_from_file_location(full_name, path)\nmod = util.module_from_spec(spec)\nspec.loader.exec_module(mod)\nreturn mod\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.get_cmdline_arguments","title":"get_cmdline_arguments","text":"<pre><code>get_cmdline_arguments()\n</code></pre> <p>Returns dictionary of command line arguments supplied to PhonoDark.</p> Source code in <code>src/ptarcade/input_handler.py</code> <pre><code>def get_cmdline_arguments():\n\"\"\"\n        Returns dictionary of command line arguments supplied to PhonoDark.\n    \"\"\"\nparser = optparse.OptionParser()\nparser.add_option('-m', action=\"store\", default=\"\",\nhelp=\"Path to models file. Sets the details of the new physics signal.\")\nparser.add_option('-c', action=\"store\", default=\"\",\nhelp=\"Path to configuration file. Sets details of the monte carlo run.\")\nparser.add_option('-n', action=\"store\", default=\"0\",\nhelp=\"Specifies the number of the chain.\")  \noptions_in, args = parser.parse_args()\noptions = vars(options_in)\ncmd_input_okay = False\nif options['m'] != '' and options['n'] != '' and  options['c'] != '':\ncmd_input_okay = True\nreturn options, cmd_input_okay\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.load_inputs","title":"load_inputs","text":"<pre><code>load_inputs(input_options)\n</code></pre> <p>Load the input parameters from the relevant files.</p> Source code in <code>src/ptarcade/input_handler.py</code> <pre><code>def load_inputs(input_options):\n\"\"\"\n        Load the input parameters from the relevant files.\n    \"\"\"\nmodels_input = input_options['m']\nnum_input = input_options['c']\nmodel_input_mod_name = os.path.splitext(os.path.basename(models_input))[0]\nmodel_mod = import_file(model_input_mod_name, os.path.abspath(models_input))\nnum_input_mod_name = os.path.splitext(os.path.basename(num_input))[0]\nnum_mod = import_file(num_input_mod_name, os.path.abspath(num_input))\nreturn {\n\"model\": model_mod,\n\"config\": num_mod\n}\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.check_config","title":"check_config","text":"<pre><code>check_config(config)\n</code></pre> Source code in <code>src/ptarcade/input_handler.py</code> <pre><code>def check_config(config):\n# checks that all the parameters are present in the config file\nmust = [\"pta_data\", \"N_samples\"]\noptional = [\n\"mod_sel\",\n\"out_dir\",\n\"resume\",\n\"scam_weight\",\n\"am_weight\",\n\"de_weight\",\n\"red_components\",\n\"corr\",\n\"gwb_components\",\n\"bhb_th_prior\",\n\"A_bhb_logmin\",\n\"A_bhb_logmax\",\n\"gamma_bhb\",\n]\noptional_default = {\n\"mod_sel\" : False,\n\"out_dir\" : './chains/',\n\"resume\" : False,\n\"scam_weight\" : 30,\n\"am_weight\" : 15,\n\"de_weight\" : 50,\n\"red_components\" : 30,\n\"corr\" : False,\n\"gwb_components\" : 14,\n\"bhb_th_prior\" : True,\n\"A_bhb_logmin\": None,\n\"A_bhb_logmax\" : None,\n\"gamma_bhb\" : None,\n}\nfor par in must:\nif not hasattr(config, par):\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"{par} not found in the configuration file.\")\nsys.exit(error)\nfor par in optional:\nif not hasattr(config, par):\nsetattr(config, par, optional_default[par])\nmessage = ( f\"\\t{par} not found in the configuration file, \" + \nf\"it will be set to {optional_default[par]}.\\n\")\nprint(message)\n# checks PTA data \nif isinstance(config.pta_data, str):\nif config.pta_data in ['NG15', 'NG12', 'IPTA2']:\npass \nelse:\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"The pta dataset {config.pta_data} is not included in PTArcade. \" +\nf\"Please, choose between 'NG15', 'NG12', 'IPTA2' or load your own data.\")\nsys.exit(error)\nelif isinstance(config.pta_data, dict):\nif list(config.pta_data.keys()) != ['psrs_data', 'noise_data', 'emp_dist']:\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\n\"The keys of the pta_data dictionary in the configuration file \" +\n\"need to be ['psrs_data', 'noise_data', 'emp_dist'].\")\nsys.exit(error)\nelif not os.path.exists(config.pta_data['psrs_data']):\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\n\"The path in pta_data['psrs_data'] does not exist.\")\nsys.exit(error)\nelse:\npass\nelse:\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"The 'pta_data' variable in the configuration file needs to be either a string between \" +\n\"'NG15', 'NG12', 'IPTA2', or a dictionary pointing to a set of PTA data.\" + \n\"For more details see documentation.\")\nsys.exit(error)\n# checks booleans variables\nbools = {'mod_sel' : config.mod_sel,\n'resume' : config.resume,\n'corr' : config.corr,\n'bhb_th_prior' : config.bhb_th_prior}\nfor key, value in bools.items():\nif not isinstance(value, bool):\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"The variable {key} in the configuration file must be a boolean.\")\nsys.exit(error)\n# checks integers \nintegers = {'N_samples' : config.N_samples,\n'scam_weight' : config.scam_weight,\n'am_weight' : config.am_weight,\n'de_weight' :config.de_weight,\n'red_components' :config.red_components,\n'red_gwb_components': config.gwb_components}\nfor key, value in integers.items():\nif not isinstance(value, int):\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"The variable {key} in the configuration file mest be an integer.\")\nsys.exit(error)\n# checks bhb params \nbhb_pars = {'A_bhb_logmin' : config.A_bhb_logmin,\n'A_bhb_logmax' : config.A_bhb_logmax,\n'gamma_bhb' : config.gamma_bhb}\nfor key, value in bhb_pars.items():\nif not isinstance(value, (float,int)) and value is not None:\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"The variable {key} in the configuration file mest be a number (integer or float), or set to None.\")\nsys.exit(error)\nif config.bhb_th_prior and (config.A_bhb_logmin or config.A_bhb_logmax or config.gamma_bhb):\nwarning = (f\"{bcolors.WARNING}WARNING{bcolors.ENDC}:\" +\n\"Since bhb_th_prior is set to True, any value of A_bhb_logmin, \" +\n\"A_bhb_logmax, or gamma_bhb will be ignored.\\n\")\nprint(warning)\nreturn\n</code></pre>"},{"location":"reference/ptarcade/input_handler/#ptarcade.input_handler.check_model","title":"check_model","text":"<pre><code>check_model(model, psrs, red_components, gwb_components)\n</code></pre> Source code in <code>src/ptarcade/input_handler.py</code> <pre><code>def check_model(model, psrs, red_components, gwb_components):\n# checks that all the parameters are present in the config file \noptional = ['name',\n'smbhb']\noptional_default = {'name' : 'np_model',\n'smbhb' : False}\nif not (hasattr(model, 'parameters')):\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"the model file needs to contain a parameter\" +\n\"dictionary.\")\nsys.exit(error)\nif not (hasattr(model, 'signal') or hasattr(model, 'spectrum')):\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"the model file needs to contain either a spectrum\" +\n\"function or a signal function.\")\nsys.exit(error)\nfor par in optional:\nif not hasattr(model, par):\nsetattr(model, par, optional_default[par])\nmessage = ( f\"\\t{par} not found in the model file, \" + \nf\"it will be set to {optional_default[par]}.\\n\")\nprint(message)\n# check priors \n# check that parameters name match the variable of the spectrum function\ntry:\nargs = inspect.getfullargspec(model.spectrum)[0]\nargs.remove('f')\nsignal_type = 'spectrum'\nexcept:\nargs = inspect.getfullargspec(model.signal)[0]\nargs.remove('toas')\nsignal_type = 'signal'\nif 'pos' in args:\nargs.remove('pos')\nif list(model.parameters.keys()) != args:\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"in the model file, the keys of the parameter dictionary need to \" +\nf\"match the parameters of the {signal_type} function.\")\nsys.exit(error)\n# check spectrum/signal function\nx0 = {}\nfor name, par in model.parameters.items():\ntry:\nx0[name] = par.sample()\nexcept:\nx0[name] = par.value\nif hasattr(model, 'spectrum'):\nN_f = max(red_components, gwb_components)\nT = model_utils.get_tspan(psrs)\nf_tab = np.linspace(1 / T, N_f / T, N_f)\ntry:\nspectrum_tab = model.spectrum(f=f_tab, **x0)\nexcept:\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"I tried to evaluate the spectrum function on the array of \" +\nf\"frequency components you selected and for random values of \"+\nf\"the parameter contained in the prior range but it failed. \" +\nf\"Please, check that the spectrum function can take a numpy \" +\nf\"list of frequencies as argument, and that it is well defined \" +\nf\"within the entire prior volume.\")\nsys.exit(error)\nif np.shape(spectrum_tab) != np.shape(f_tab):\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"the output of the spectrum function needs to have the same \" +\nf\"dimensions of the frequency list passed as argument.\")\nsys.exit(error)\nelse:\ntmin = np.min([p.toas.min() for p in psrs])\ntmax = np.max([p.toas.max() for p in psrs])\ntoas_tab = np.linspace(tmin, tmax, 10)\ntry:\nsignal_tab = model.signal(toas_tab, **x0)\nexcept:\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"I tried to evaluate the signal function on an array of \" +\nf\"toas withing the observing time and for a set of model \"+\nf\"parameters contained in the prior range but it failed. \" +\nf\"Please, check that the signal function can take a numpy \" +\nf\"list of toas as argument, and that it is well defined \" +\nf\"within the entire prior volume.\")\nsys.exit(error)\nif np.shape(signal_tab) != np.shape(toas_tab):\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\nf\"the output of the signal function needs to have the same \" +\nf\"dimensions of the toas list passed as argument.\")\nsys.exit(error)\nreturn\n</code></pre>"},{"location":"reference/ptarcade/models_utils/","title":"models_utils","text":""},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils-attributes","title":"Attributes","text":""},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.G","title":"G  <code>module-attribute</code>","text":"<pre><code>G = (\n6.6743\n* 10**-11\n* nat.convert(\nnat.m**3 * nat.kg**-1 * nat.s**-2,\nnat.GeV**-2,\n)\n)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.M_pl","title":"M_pl  <code>module-attribute</code>","text":"<pre><code>M_pl = 8 * np.pi * G ** -1 / 2\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.T_0","title":"T_0  <code>module-attribute</code>","text":"<pre><code>T_0 = 2.7255 * nat.convert(nat.K, nat.GeV)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.z_eq","title":"z_eq  <code>module-attribute</code>","text":"<pre><code>z_eq = 3402\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.T_eq","title":"T_eq  <code>module-attribute</code>","text":"<pre><code>T_eq = T_0 * 1 + z_eq\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.h","title":"h  <code>module-attribute</code>","text":"<pre><code>h = 0.674\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.H_0","title":"H_0  <code>module-attribute</code>","text":"<pre><code>H_0 = (\nh\n* 100\n* nat.convert(\nnat.km * nat.s**-1 * nat.Mpc**-1, nat.GeV\n)\n)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.H_0_Hz","title":"H_0_Hz  <code>module-attribute</code>","text":"<pre><code>H_0_Hz = H_0 * nat.convert(nat.GeV, nat.Hz)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.omega_v","title":"omega_v  <code>module-attribute</code>","text":"<pre><code>omega_v = 0.6847\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.omega_m","title":"omega_m  <code>module-attribute</code>","text":"<pre><code>omega_m = 0.3153\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.omega_r","title":"omega_r  <code>module-attribute</code>","text":"<pre><code>omega_r = 9.2188e-05\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.A_s","title":"A_s  <code>module-attribute</code>","text":"<pre><code>A_s = np.exp(3.044) * 10 ** -10\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.f_cmb","title":"f_cmb  <code>module-attribute</code>","text":"<pre><code>f_cmb = 7.7314e-17\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.gev_to_hz","title":"gev_to_hz  <code>module-attribute</code>","text":"<pre><code>gev_to_hz = nat.convert(nat.GeV, nat.Hz)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.gs","title":"gs  <code>module-attribute</code>","text":"<pre><code>gs = np.loadtxt(\nfiles(\"ptarcade.data\").joinpath(\"g_star.dat\")\n)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.g_rho_0","title":"g_rho_0  <code>module-attribute</code>","text":"<pre><code>g_rho_0 = __g_rho_0(T_0)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.g_s_0","title":"g_s_0  <code>module-attribute</code>","text":"<pre><code>g_s_0 = __g_s_0(T_0)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils-functions","title":"Functions","text":""},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.g_rho","title":"g_rho","text":"<pre><code>g_rho(x, is_freq = False)\n</code></pre> <p>| Returns the number of relativistic degrees of  | freedom as a function of T/GeV or f/Hz.</p> <p>:param x: The temperature(s) [GeV] or frequency/frequencies [Hz] :param is_freq: True if <code>x</code> is a frequency/frequencies, False if temperature(s) :return: the relativistic degrees of freedom at <code>x</code></p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def g_rho(x, is_freq=False):\n\"\"\"\n    | Returns the number of relativistic degrees of \n    | freedom as a function of T/GeV or f/Hz.\n    :param x: The temperature(s) [GeV] or frequency/frequencies [Hz]\n    :param is_freq: True if `x` is a frequency/frequencies, False if temperature(s)\n    :return: the relativistic degrees of freedom at `x`\n    \"\"\"\nif is_freq:\ndof = np.interp(x, gs[:, 1], gs[:, 3])\nelse:\ndof = np.interp(x, gs[:, 0], gs[:, 3])\nreturn dof\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.g_s","title":"g_s","text":"<pre><code>g_s(x, is_freq = False)\n</code></pre> <p>| Returns the number of entropic relativistic degrees of | freedom as a function of T/GeV or f/Hz.</p> <p>:param x: The temperature(s) [GeV] or frequency/frequencies [Hz] :param is_freq: True if <code>x</code> is a frequency/frequencies, False if temperature(s) :return: the entropic relativistic degrees of freedom at <code>x</code></p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def g_s(x, is_freq=False):\n\"\"\"\n    | Returns the number of entropic relativistic degrees of\n    | freedom as a function of T/GeV or f/Hz.\n    :param x: The temperature(s) [GeV] or frequency/frequencies [Hz]\n    :param is_freq: True if `x` is a frequency/frequencies, False if temperature(s)\n    :return: the entropic relativistic degrees of freedom at `x`\n    \"\"\"\nif is_freq:\ndof = np.interp(x, gs[:, 1], gs[:, 2])\nelse:\ndof = np.interp(x, gs[:, 0], gs[:, 2])\nreturn dof\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.__g_s_0","title":"__g_s_0  <code>cached</code>","text":"<pre><code>__g_s_0(T_0)\n</code></pre> <p>Calculate the entropic relativistic degrees of freedom today.</p> <p>This function is cached because it only needs to be ran once. It is a function instead of a constant so that if the g_star.dat file changes, this value will update as well.</p> <p>:param float T_0: The universe's temperature today [GeV]. :return: The entropic relativistic degrees of greedom today. :rtype: float.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>@cache\ndef __g_s_0(T_0):\n\"\"\"Calculate the entropic relativistic degrees of freedom today.\n    This function is cached because it only needs to be ran once. It is a function instead of a constant so that if\n    the g_star.dat file changes, this value will update as well.\n    :param float T_0: The universe's temperature today [GeV].\n    :return: The entropic relativistic degrees of greedom today.\n    :rtype: float.\"\"\"\nreturn g_s(T_0)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.__g_rho_0","title":"__g_rho_0  <code>cached</code>","text":"<pre><code>__g_rho_0(T_0)\n</code></pre> <p>Calculate the relativistic degrees of freedom today.</p> <p>This function is cached because it only needs to be ran once. It is a function instead of a constant so that if the g_star.dat file changes, this value will update as well.</p> <p>:param float T_0: The universe's temperature today [GeV]. :return: The relativistic degrees of greedom today. :rtype: float.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>@cache\ndef __g_rho_0(T_0):\n\"\"\"Calculate the relativistic degrees of freedom today.\n    This function is cached because it only needs to be ran once. It is a function instead of a constant so that if\n    the g_star.dat file changes, this value will update as well.\n    :param float T_0: The universe's temperature today [GeV].\n    :return: The relativistic degrees of greedom today.\n    :rtype: float.\"\"\"\nreturn g_rho(T_0)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.GammaPrior","title":"GammaPrior","text":"<pre><code>GammaPrior(value, a, loc, scale)\n</code></pre> <p>Prior function for Uniform parameters.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def GammaPrior(value, a, loc, scale):\n\"\"\"Prior function for Uniform parameters.\"\"\"\nreturn ss.gamma.pdf(value, a, loc, scale)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.GammaSampler","title":"GammaSampler","text":"<pre><code>GammaSampler(a, loc, scale, size = None)\n</code></pre> <p>Sampling function for Uniform parameters.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def GammaSampler(a, loc, scale, size=None):\n\"\"\"Sampling function for Uniform parameters.\"\"\"\nreturn ss.gamma.rvs(a, loc, scale, size=size)\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.Gamma","title":"Gamma","text":"<pre><code>Gamma(a, loc, scale, size = None)\n</code></pre> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def Gamma(a, loc, scale, size=None):\nclass Gamma(parameter.Parameter):\n_size = size\n_prior = parameter.Function(GammaPrior, a=a, loc=loc, scale=scale)\n_sampler = staticmethod(GammaSampler)\n_typename = parameter._argrepr(\"Gamma\", a=a, loc=loc, scale=scale)\nreturn Gamma\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.omega2cross","title":"omega2cross","text":"<pre><code>omega2cross(omega_hh)\n</code></pre> <p>| Converts the GW energy density as a fraction of the  | closure density into the cross-power spectral density | as a funtion of the frequency in Hz.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def omega2cross(omega_hh):\n\"\"\"\n    | Converts the GW energy density as a fraction of the \n    | closure density into the cross-power spectral density\n    | as a funtion of the frequency in Hz.\n    \"\"\"\n@function\ndef cross(f, components=2, **kwargs):\ndf = np.diff(np.concatenate((np.array([0]), f[::components])))\n# fraction of the critical density in GWs\nh2_omega = omega_hh(f, **kwargs)\n# characteristic strain spectrum h_c(f)\nhcf = H_0_Hz / h * np.sqrt(3 * h2_omega / 2) / (np.pi * f)\n# cross-power spectral density S(f) (s^3)\nsf = (hcf**2 / (12 * np.pi**2 * f**3)) * np.repeat(df, components)\nreturn sf\nreturn cross\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.prep_data","title":"prep_data","text":"<pre><code>prep_data(path)\n</code></pre> <p>Shapes tabulated data in a form that can be handled by interpn.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def prep_data(path):\n\"\"\"\n    Shapes tabulated data in a form that can be handled by interpn.\n    \"\"\"\npar_names = np.loadtxt(path, max_rows=1, dtype='str')\ndata = np.loadtxt(path, skiprows=1)\nspec_col = np.where(par_names=='spectrum')\nomega_grid = data.T[spec_col][0]\ndata = np.delete(data, spec_col, axis=1)\npar_names = np.delete(par_names, spec_col)\ngrids = [np.unique(row) for row in data.T]\nfor idx, par in enumerate(par_names):\nomega_grid = omega_grid[data[:, -idx -1].argsort(kind=\"mergesort\")]\ndata = data[data[:, -idx -1].argsort(kind=\"mergesort\")]\ngrid_size = [len(x) for x in grids]\nomega_grid = omega_grid.reshape(tuple(grid_size))\nreturn grids, omega_grid, par_names \n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.spec_importer","title":"spec_importer","text":"<pre><code>spec_importer(path)\n</code></pre> <p>Interpolate the GWB power spectrum from tabulated data.</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def spec_importer(path):\n\"\"\"\n    Interpolate the GWB power spectrum from tabulated data. \n    \"\"\"\ninfo, data = fast_interpolate.load_data(path)\n# info is a list of (name, start, step)\ndef spectrum(f, **kwargs):\n# Construct right information format for interpolation\nreturn fast_interpolate.interp([(start, step, f if name == 'f' else kwargs[name])\nfor (name, start, step) in info],\ndata)\nreturn spectrum\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.freq_at_temp","title":"freq_at_temp","text":"<pre><code>freq_at_temp(T)\n</code></pre> <p>Calculate GW frequency [Hz] today as function of universe temperature [GeV] when the GW was of horizon size.</p> <p>:param Union[NDArray, float] T: Universe temperature [GeV] at time when GW was of horizon size :return: GW of frequency f [Hz] today that was of horizon size when universe was at temperature <code>T</code> [GeV] :rtype: Union[NDArray, float]</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def freq_at_temp(T):\n\"\"\"Calculate GW frequency [Hz] today as function of universe temperature [GeV]\n    when the GW was of horizon size.\n    :param Union[NDArray, float] T: Universe temperature [GeV] at time when GW was of horizon size\n    :return: GW of frequency f [Hz] today that was of horizon size when universe was at temperature `T` [GeV]\n    :rtype: Union[NDArray, float]\n    \"\"\"\nf_0 = H_0_Hz / (2 * np.pi)\nT_ratio = T_0 / T\ng_ratio = g_rho_0 / g_rho(T)\ngs_ratio = g_s_0 / g_s(T)\nprefactor = f_0 * (gs_ratio) ** (1 / 3) * T_ratio\nsqr_term = np.sqrt(\nomega_v\n+ (gs_ratio**-1 * T_ratio**-3 * omega_m)\n+ (g_ratio**-1 * T_ratio**-4 * omega_r)\n)\nreturn prefactor * sqr_term\n</code></pre>"},{"location":"reference/ptarcade/models_utils/#ptarcade.models_utils.temp_at_freq","title":"temp_at_freq","text":"<pre><code>temp_at_freq(f)\n</code></pre> <p>Get the temperature [GeV] of the universe when a gravitational wave of a certain frequency [Hz] today was of horizon size.</p> <p>:param Union[NDArray, float] f: Frequency in Hz today :return: Temperature [GeV] when GW at frequency <code>f</code> [Hz] was of horizon size :rtype: Union[NDArray, float]</p> Source code in <code>src/ptarcade/models_utils.py</code> <pre><code>def temp_at_freq(f):\n\"\"\"Get the temperature [GeV] of the universe when a gravitational wave of a\n    certain frequency [Hz] today was of horizon size.\n    :param Union[NDArray, float] f: Frequency in Hz today\n    :return: Temperature [GeV] when GW at frequency `f` [Hz] was of horizon size\n    :rtype: Union[NDArray, float]\n    \"\"\"\nreturn np.interp(f, gs[:, 1], gs[:, 0], left=np.nan, right=np.nan)\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/","title":"plotting_utils","text":""},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils-attributes","title":"Attributes","text":""},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.colors","title":"colors  <code>module-attribute</code>","text":"<pre><code>colors = [\n\"#E03424\",\n\"#006FED\",\n\"gray\",\n\"#009966\",\n\"#000866\",\n\"#336600\",\n\"#006633\",\n\"m\",\n\"r\",\n]\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.plt_params","title":"plt_params  <code>module-attribute</code>","text":"<pre><code>plt_params = {'axes.linewidth': 0.5, 'text.usetex': True}\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils-classes","title":"Classes","text":""},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.bcolors","title":"bcolors","text":"Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>class bcolors:\nWARNING = \"\\033[0;33m\"\nFAIL = '\\033[0;31m'\nENDC = '\\033[0m'\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.bcolors-attributes","title":"Attributes","text":""},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.bcolors.WARNING","title":"WARNING  <code>instance-attribute</code> <code>class-attribute</code>","text":"<pre><code>WARNING = '\\x1b[0;33m'\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.bcolors.FAIL","title":"FAIL  <code>instance-attribute</code> <code>class-attribute</code>","text":"<pre><code>FAIL = '\\x1b[0;31m'\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.bcolors.ENDC","title":"ENDC  <code>instance-attribute</code> <code>class-attribute</code>","text":"<pre><code>ENDC = '\\x1b[0m'\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils-functions","title":"Functions","text":""},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.set_size","title":"set_size","text":"<pre><code>set_size(\nwidth, fraction=1, ratio=None, subplots=(1, 1)\n)\n</code></pre> <p>Set figure dimensions to avoid scaling in LaTeX.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Document textwidth or columnwidth in pts</p> required <code>fraction</code> <code>float, optional</code> <p>Fraction of the width which you wish the figure to occupy, by default 1</p> <code>1</code> <code>ratio</code> <code>float, optional</code> <p>Ratio of the height to width of the figure. If None, the golden ratio (sqrt(5)-1)/2 is used, by default None</p> <code>None</code> <code>subplots</code> <code>tuple of int, optional</code> <p>The number of rows and columns of subplots in the figure, by default (1, 1)</p> <code>(1, 1)</code> <p>Returns:</p> Name Type Description <code>fig_dim</code> <code>tuple</code> <p>Dimensions of figure in inches. The dimensions are calculated based on the parameters, and the height is further adjusted based on the number of subplots.</p> Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>def set_size(width, fraction=1, ratio=None, subplots=(1, 1)):\n\"\"\"\n    Set figure dimensions to avoid scaling in LaTeX.\n    Parameters\n    ----------\n    width : float\n        Document textwidth or columnwidth in pts\n    fraction : float, optional\n        Fraction of the width which you wish the figure to occupy, by default 1\n    ratio : float, optional\n        Ratio of the height to width of the figure. If None, the golden ratio (sqrt(5)-1)/2 is used, by default None\n    subplots : tuple of int, optional\n        The number of rows and columns of subplots in the figure, by default (1, 1)\n    Returns\n    -------\n    fig_dim : tuple\n        Dimensions of figure in inches. The dimensions are calculated based on the parameters, and the height is further adjusted based on the number of subplots.\n    \"\"\"\nfig_width_pt = width * fraction\ninches_per_pt = 1 / 72.27\nfig_width_in = fig_width_pt * inches_per_pt\nif not ratio :\nratio = (5**.5 - 1) / 2\nfig_height_in = fig_width_in * ratio * (subplots[0] / subplots[1])\nfig_dim = (fig_width_in, fig_height_in)\nreturn fig_dim\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.set_custom_tick_options","title":"set_custom_tick_options","text":"<pre><code>set_custom_tick_options(\nax,\nleft=True,\nright=True,\nbottom=True,\ntop=True,\nlabel_size=8,\nwidth=0.5,\nlength=3.5,\n)\n</code></pre> <p>Sets custom tick options for a matplotlib axis.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>matplotlib axis</code> <p>The axis to which the tick options will be applied.</p> required <code>left</code> <code>bool, optional</code> <p>If True, left ticks will be visible. Default is True.</p> <code>True</code> <code>right</code> <code>bool, optional</code> <p>If True, right ticks will be visible. Default is True.</p> <code>True</code> <code>bottom</code> <code>bool, optional</code> <p>If True, bottom ticks will be visible. Default is True.</p> <code>True</code> <code>top</code> <code>bool, optional</code> <p>If True, top ticks will be visible. Default is True.</p> <code>True</code> <code>label_size</code> <code>int, optional</code> <p>Controls the font size for ticks labels. Default is 8.</p> <code>8</code> <code>width</code> <code>float, optional</code> <p>Sets the width of the ticks. Default is 0.5.</p> <code>0.5</code> <code>length</code> <code>float, optional</code> <p>Sets the length of the ticks. Default is 3.5.</p> <code>3.5</code> <p>Returns:</p> Type Description <code>    None</code> Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>def set_custom_tick_options(\nax, left=True, right=True, bottom=True, top=True, label_size=8, width=0.5, length=3.5):\n\"\"\"\n    Sets custom tick options for a matplotlib axis.\n    Parameters\n    ----------\n    ax : matplotlib axis\n        The axis to which the tick options will be applied.\n    left : bool, optional\n        If True, left ticks will be visible. Default is True.\n    right : bool, optional\n        If True, right ticks will be visible. Default is True.\n    bottom : bool, optional\n        If True, bottom ticks will be visible. Default is True.\n    top : bool, optional\n        If True, top ticks will be visible. Default is True.\n    label_size : int, optional\n        Controls the font size for ticks labels. Default is 8.\n    width : float, optional\n        Sets the width of the ticks. Default is 0.5.\n    length : float, optional\n        Sets the length of the ticks. Default is 3.5.\n    Returns\n    -------\n        None\n    \"\"\"\nax.minorticks_on()\nax.tick_params(\nwhich=\"major\",\ndirection=\"in\",\nlength=length,\nwidth=width,\nbottom=bottom,\ntop=top,\nleft=left,\nright=right,\nlabelsize=label_size,\npad=2\n)\nax.tick_params(\nwhich=\"minor\",\ndirection=\"in\",\nlength=length / 2,\nwidth=width,\nbottom=bottom,\ntop=top,\nleft=left,\nright=right,\nlabelsize=label_size,\npad=2\n)\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.plot_chains","title":"plot_chains","text":"<pre><code>plot_chains(\nchain,\nparams,\nparams_name=None,\nlabel_size=13,\nsave=False,\nmodel_name=None,\n)\n</code></pre> <p>Plot the MCMC (Markov chain Monte Carlo) chain for the parameters specified by params.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>numpy.ndarray</code> <p>A numpy array containing the MCMC chain to be plotted. Each row corresponds to a step in the chain, and each column corresponds to a parameter.</p> required <code>params</code> <code>list of str</code> <p>A list with the names of the parameters appearing in the chain.</p> required <code>params_name</code> <code>dict, optional</code> <p>A dictionary with keys being the names of the parameters in the params list to be plotted,  and values being the formatted parameters name to be shown in the plots. Default is None, which plots all the common parameters + the MCMC parameters without any formatting.</p> <code>None</code> <code>label_size</code> <code>int, optional</code> <p>Controls the font size for the axis and ticks labels. Default is 13.</p> <code>13</code> <code>save</code> <code>bool, optional</code> <p>If set to True, the plot is saved in the folder \"./plots/\". Default is False.</p> <code>False</code> <code>model_name</code> <code>str, optional</code> <p>A string with the model name. Used to name the output files. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>Warning</code> <p>If some of the requested parameters do not appear in the parameter list.</p> Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>def plot_chains(\nchain, params, params_name=None, label_size=13, save=False, model_name=None):\n\"\"\"\n    Plot the MCMC (Markov chain Monte Carlo) chain for the parameters specified by params.\n    Parameters\n    ----------\n    chain : numpy.ndarray\n        A numpy array containing the MCMC chain to be plotted.\n        Each row corresponds to a step in the chain, and each column corresponds to a parameter.\n    params : list of str\n        A list with the names of the parameters appearing in the chain.\n    params_name : dict, optional\n        A dictionary with keys being the names of the parameters in the params list to be plotted, \n        and values being the formatted parameters name to be shown in the plots.\n        Default is None, which plots all the common parameters + the MCMC parameters without any formatting.\n    label_size : int, optional\n        Controls the font size for the axis and ticks labels. Default is 13.\n    save : bool, optional\n        If set to True, the plot is saved in the folder \"./plots/\". Default is False.\n    model_name : str, optional\n        A string with the model name. Used to name the output files. Default is None.\n    Returns\n    -------\n    None\n    Raises\n    ------\n    Warning\n        If some of the requested parameters do not appear in the parameter list.\n    \"\"\"\nplt.rcParams.update(plt_params)\nparams_dic = {}\nif params_name:\nfor idx, par in enumerate(params):\nif par in params_name.keys():\nformatted_name = params_name[par]\nparams_dic[formatted_name] = idx\nif len(params_dic) != len(params_name):\nprint(\nf\"{bcolors.WARNING}WARNING{bcolors.ENDC}: some of the requested parameters does not appear in the parameter list\"\n)\nelse:\nfor idx, par in enumerate(params):\nif \"+\" not in par and \"-\" not in par and \"n_parall\" not in par:\nkey = par.replace(\"_\", \"\\_\")\nkey = rf\"$\\mathrm{{{key}}}$\"\nparams_dic[key] = idx\nn_par = len(params_dic)\nn_row = int(n_par**0.5)\nn_col = int(math.ceil(n_par / float(n_row)))\nfig, axs = plt.subplots(n_row, n_col, figsize=(5 * n_col, 2.5 * n_row), sharex=True)\nif n_par == 1:\naxs = np.array([axs])\nfor idx, (ax, key) in enumerate(zip(axs.reshape(-1), params_dic)):\nax.plot(chain[:, params_dic[key]])\nset_custom_tick_options(ax, label_size=label_size)\nax.set_ylabel(f\"{key}\", fontsize=label_size)\nfor ax in axs[-1]:\nax.set_xlabel(\"$\\mathrm{MCMC\\;sample}$\", fontsize=label_size)\nplt.tight_layout()\nplt.show()\nif save:\nif model_name:\nplt.savefig(f\"./plots/{model_name}_chains.pdf\")\nelse:\nprint(\"Please specify a model name to save the chain plot.\")\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.create_ax_labels","title":"create_ax_labels","text":"<pre><code>create_ax_labels(par_names, labelsize = 8)\n</code></pre> <p>Formats the axes for posterior plots</p> <p>This function fetches the current figure and all its axes, sets custom tick options  and labels for all axes according to the names of the parameters. </p> <p>Parameters:</p> Name Type Description Default <code>par_names</code> <code>list of str</code> <p>A list of names of the parameters for each of the axes.</p> required <code>labelsize</code> <code>int, optional</code> <p>The font size of the labels. Default is 8. If there is only one parameter, this value is set to 12.</p> <code>8</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.create_ax_labels--notes","title":"Notes","text":"<ul> <li>The function assumes that the number of axes in the current figure matches the    number of parameter names provided. If this is not the case, the behavior is undefined.</li> <li>A label with the name 'A' and alpha=0 is set for the y-axis in the case of a single parameter    to prevent padding issues.</li> </ul> Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>def create_ax_labels(par_names, labelsize=8):\n\"\"\"\n    Formats the axes for posterior plots\n    This function fetches the current figure and all its axes, sets custom tick options \n    and labels for all axes according to the names of the parameters. \n    Parameters\n    ----------\n    par_names : list of str\n        A list of names of the parameters for each of the axes.\n    labelsize : int, optional\n        The font size of the labels. Default is 8. If there is only one parameter,\n        this value is set to 12.\n    Returns\n    -------\n    None\n    Notes\n    -----\n    - The function assumes that the number of axes in the current figure matches the \n      number of parameter names provided. If this is not the case, the behavior is undefined.\n    - A label with the name 'A' and alpha=0 is set for the y-axis in the case of a single parameter \n      to prevent padding issues.\n    \"\"\"\n#small_font = 5\nN_params = len(par_names)\nf = plt.gcf()\naxs = f.get_axes()\nif N_params == 1:\nlabelsize = 12\nset_custom_tick_options(axs[0], width=0.5, length=5, label_size=labelsize)\naxs[0].set_xlabel(par_names[0], fontsize=labelsize, labelpad=10)\naxs[0].set_ylabel('A', alpha=0) # here just ot prevent padding issues\nreturn\n# do this loop using combinations_with_replacement from itertools \nfor idx in range(N_params):\nfor idy in range(N_params - idx):\nid = int(N_params * idx + idy - max(idx * (idx - 1) /2, 0))\nset_custom_tick_options(axs[id], width=0.5, label_size=labelsize)\nif idx == 0 and idy == 0:\nset_custom_tick_options(axs[id], width=0.5)\naxs[id].set_xlabel(par_names[idx], fontsize=labelsize, labelpad=7)\naxs[id].set_ylabel(par_names[N_params - idy - 1], fontsize=labelsize)\nelif idx == N_params - 1:\nset_custom_tick_options(axs[id], left=False, right=False, width=0.5)\naxs[id].set_xlabel(par_names[idx], fontsize=labelsize, labelpad=7)\nelif idy == N_params - idx - 1:\nset_custom_tick_options(axs[id], left=False, right=False, width=0.5)\nelif idx == 0:\nset_custom_tick_options(axs[id], width=0.5)\naxs[id].set_ylabel(par_names[N_params - idy - 1],\nfontsize=labelsize)\nelif idy == 0:\nset_custom_tick_options(axs[id], width=0.5)\naxs[id].set_xlabel(par_names[idx], fontsize=labelsize, labelpad=7)\nelse:\nset_custom_tick_options(axs[id], width=0.5)\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.level_to_sigma","title":"level_to_sigma","text":"<pre><code>level_to_sigma(level)\n</code></pre> <p>Converts confidence level to standard deviation (sigma).</p> <p>This function uses the inverse of the cumulative distribution function (CDF) for a  normal distribution to convert a confidence level to the equivalent number of  standard deviations (sigma).</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>float</code> <p>The confidence level to convert. This should be a fraction between 0 and 1.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The number of standard deviations corresponding to the provided confidence level.</p> <p>Raises:</p> Type Description <code>SystemExit</code> <p>If the provided level is not between 0 and 1.</p> Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>def level_to_sigma(level):\n\"\"\"\n    Converts confidence level to standard deviation (sigma).\n    This function uses the inverse of the cumulative distribution function (CDF) for a \n    normal distribution to convert a confidence level to the equivalent number of \n    standard deviations (sigma).\n    Parameters\n    ----------\n    level : float\n        The confidence level to convert. This should be a fraction between 0 and 1.\n    Returns\n    -------\n    float\n        The number of standard deviations corresponding to the provided confidence level.\n    Raises\n    ------\n    SystemExit\n        If the provided level is not between 0 and 1.\n    \"\"\"\nif 0 &lt; level &lt; 1:\nreturn np.sqrt(-2 * np.log(1-level))\nelse:\nerror = (f\"{bcolors.FAIL}ERROR{bcolors.ENDC}:\" +\n\"The level value needs to be between 0 and 1.\")\nsys.exit(error)\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.plot_bhb_prior","title":"plot_bhb_prior","text":"<pre><code>plot_bhb_prior(plot, bhb_prior, levels)\n</code></pre> <p>Plot the prior distribution for SMBHB signal.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>object</code> <p>The plot object to which the priors will be added.  This object should have methods <code>get_axes_for_params(param1, param2)</code> that return the Axes object for the given parameters.</p> required <code>bhb_prior</code> <code>str</code> <p>The specific BHB prior to be used, choices are \"NG15\" and \"IPTA2\".</p> required <code>levels</code> <code>list of float</code> <p>A list of threshold levels. The sigma equivalent of these levels will be plotted.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>def plot_bhb_prior(plot, bhb_prior, levels):\n\"\"\"\n    Plot the prior distribution for SMBHB signal.\n    Parameters\n    ----------\n    plot : object\n        The plot object to which the priors will be added. \n        This object should have methods `get_axes_for_params(param1, param2)` that return the Axes object for the given parameters.\n    bhb_prior : str\n        The specific BHB prior to be used, choices are \"NG15\" and \"IPTA2\".\n    levels : list of float\n        A list of threshold levels. The sigma equivalent of these levels will be plotted.\n    Returns\n    -------\n    None\n    \"\"\"\nsigmas = [level_to_sigma(level) for level in levels]\nif bhb_prior == \"NG15\":\nmu = np.array([-15.61492963, 4.70709637])\ncov = np.array([[0.27871359, -0.00263617], [-0.00263617, 0.12415383]])\nelif bhb_prior == \"IPTA2\":\nmu = np.array([-15.02928454, 4.14290127])\ncov = np.array([[0.06869369, 0.00017051], [0.00017051, 0.04681747]])\nA_0, gamma_0 = mu\neig = np.linalg.eig(np.linalg.inv(cov))\na, b = eig[0]\nR_rot = eig[1]\nt = np.linspace(0, 2 * np.pi, 100)\nEll = -np.array([(a) ** (-1 / 2) * np.cos(t), (b) ** (-1 / 2) * np.sin(t)])\nEll_rot = np.zeros((len(sigmas), 2, Ell.shape[1]))\nfor idx, sigma in enumerate(sigmas):\nEll_rot[idx, :, :] = np.dot(R_rot, sigma * Ell)\nlw = 0.5\nax_0 = plot.get_axes_for_params(\"gw-bhb-0\")\nax_1 = plot.get_axes_for_params(\"gw-bhb-1\")\nif ax_0 and ax_1:\nA_pts = np.arange(-17, -13, 0.001)\ng_pts = np.arange(2, 6, 0.001)\nax_0.plot(\nA_pts,\nnorm.pdf(A_pts, mu[0], cov[0, 0] ** (1 / 2)),\ncolor=\"black\",\nlinestyle=\"dashed\",\nlinewidth=lw)\nax_1.plot(\ng_pts,\nnorm.pdf(g_pts, mu[1], cov[1, 1] ** (1 / 2)),\ncolor=\"black\",\nlinestyle=\"dashed\",\nlinewidth=lw)\nfor idx in range(len(sigmas)):\nax = plot.get_axes_for_params(\"gw-bhb-0\", \"gw-bhb-1\")\nif ax:\nax.plot(\nA_0 + Ell_rot[idx, 0, :],\ngamma_0 + Ell_rot[idx, 1, :],\ncolor=\"black\",\nlinestyle=\"dashed\",\nlinewidth=lw,\nalpha=0.9)\nax = plot.get_axes_for_params(\"gw-bhb-1\", \"gw-bhb-0\")\nif ax:\nax.plot(\ngamma_0 + Ell_rot[idx, 1, :],\nA_0 + Ell_rot[idx, 0, :],\n\"black\",\nlinestyle=\"dashed\",\nlinewidth=lw,\nalpha=0.9)\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.corner_plot_settings","title":"corner_plot_settings","text":"<pre><code>corner_plot_settings(\nlevels,\nsamples,\none_column,\nlegend_size=12,\nfig_width_pt=None,\n)\n</code></pre> <p>Configures the settings for corner plots.</p> <p>Parameters:</p> Name Type Description Default <code>levels</code> <code>list of float, optional</code> <p>The list of confidence levels for which the HPI should be computed. Each value in the list should be between 0 and 1. Default is None.</p> required <code>samples</code> <code>list of MCSamples</code> <p>A list of instances of the MCSamples class, each containing multivariate Monte Carlo samples on which the function is operating.</p> required <code>one_column</code> <code>bool</code> <p>Whether to set the figure width for a one-column format. If False, a wider format is used.</p> required <code>fig_width_pt</code> <code>float, optional</code> <p>Sets the font size of the legend captions. Default is 12.</p> <code>None</code> <code>fig_width_pt</code> <code>float, optional</code> <p>If provided, the figure width in points. This parameter can be used to override the default figure widths for one- or two-column formats. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>GetDistPlotSettings</code> <p>An instance of the GetDistPlotSettings class, with the corner plot settings configured as specified.</p> <p>Returns:</p> Type Description <code>GetDistPlotSettings</code> <p>An instance of the GetDistPlotSettings class, with the corner plot settings configured as specified.</p> Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>def corner_plot_settings(\nlevels, samples, one_column, legend_size=12, fig_width_pt=None):\n\"\"\"\n    Configures the settings for corner plots.\n    Parameters\n    ----------\n    levels : list of float, optional\n        The list of confidence levels for which the HPI should be computed.\n        Each value in the list should be between 0 and 1. Default is None.\n    samples : list of MCSamples\n        A list of instances of the MCSamples class, each containing\n        multivariate Monte Carlo samples on which the function is operating.\n    one_column : bool\n        Whether to set the figure width for a one-column format. If False,\n        a wider format is used.\n    fig_width_pt : float, optional\n        Sets the font size of the legend captions.\n        Default is 12.\n    fig_width_pt : float, optional\n        If provided, the figure width in points. This parameter can be used\n        to override the default figure widths for one- or two-column formats.\n        Default is None.\n    Returns\n    -------\n    GetDistPlotSettings\n        An instance of the GetDistPlotSettings class, with the corner plot\n        settings configured as specified.\n    Returns\n    -------\n    GetDistPlotSettings\n        An instance of the GetDistPlotSettings class, with the corner plot\n        settings configured as specified.\n    \"\"\"\nsets = plots.GetDistPlotSettings()\nsets.prob_y_ticks = False\nsets.figure_legend_loc = \"upper right\"\nsets.norm_1d_density = \"integral\"\nsets.alpha_filled_add = 0.8\nsets.legend_fontsize = legend_size\nsets.linewidth = 2.35\nif fig_width_pt:\nsets.fig_width_inch = set_size(fig_width_pt, ratio=1)[0]\nelif one_column:\nsets.fig_width_inch = set_size(246, ratio=1)[0]\nelse:\nsets.fig_width_inch = set_size(510, ratio=1, fraction=0.65)[0]\nif levels is not None:\nsets.num_plot_contours = len(levels)\nfor sample in samples:\nsample.updateSettings({\"contours\": levels})\nreturn sets\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.oned_plot_settings","title":"oned_plot_settings","text":"<pre><code>oned_plot_settings(legend_size = 9)\n</code></pre> <p>Configures the settings for one-dimensional (1D) plots.</p> <p>Returns:</p> Type Description <code>GetDistPlotSettings</code> <p>An instance of the GetDistPlotSettings class, with the 1D plot  settings configured as specified.</p> Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>def oned_plot_settings(legend_size=9):\n\"\"\"\n    Configures the settings for one-dimensional (1D) plots.\n    Returns\n    -------\n    GetDistPlotSettings\n        An instance of the GetDistPlotSettings class, with the 1D plot \n        settings configured as specified.\n    \"\"\"\nsets = plots.GetDistPlotSettings()\nsets.legend_fontsize = legend_size\nsets.prob_y_ticks = False\nsets.linewidth = 1.1\nsets.figure_legend_loc = 'upper right'\nsets.norm_1d_density = 'integral'\nsets.line_styles = colors\nreturn sets\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.plot_k_bounds","title":"plot_k_bounds","text":"<pre><code>plot_k_bounds(plot, samples, k_levels)\n</code></pre> <p>Add the k-ratio bounds to an existing plot.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>TrianglePlot instance</code> <p>The plot to which the k-ratio bounds should be added.</p> required <code>samples</code> <code>list of MCSamples</code> <p>A list of instances of the MCSamples class, each containing  multivariate Monte Carlo samples on which the function is operating.</p> required <code>k_levels</code> <code>list of array</code> <p>A list of 1D or 2D arrays representing the K-ratio bounds for  each sample. Each array should contain the parameter names and  corresponding K-ratio bound.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>def plot_k_bounds(plot, samples, k_levels):\n\"\"\"\n    Add the k-ratio bounds to an existing plot.\n    Parameters\n    ----------\n    plot : TrianglePlot instance\n        The plot to which the k-ratio bounds should be added.\n    samples : list of MCSamples\n        A list of instances of the MCSamples class, each containing \n        multivariate Monte Carlo samples on which the function is operating.\n    k_levels : list of array\n        A list of 1D or 2D arrays representing the K-ratio bounds for \n        each sample. Each array should contain the parameter names and \n        corresponding K-ratio bound.\n    Returns\n    -------\n    None\n    \"\"\"\nfor idx, sample in enumerate(samples):\nif k_levels[idx]:\nfor x in k_levels[idx][0]:\nif x[-1]:\npar = x[0]\np0 = float(x[-1])\nif len(k_levels[idx][0]) == 1:\nplt.plot(\n[p0, p0], [0, 10], color=colors[idx], alpha=0.8, lw=0.8)\nelse:\nax = plot.get_axes_for_params(par)\nax.plot([p0, p0], [0, 10], color=colors[idx], alpha=0.8, lw=0.8)\nfor x in k_levels[idx][1]:\npar_1 = x[0]\npar_2 = x[1]\nlevel = float(x[-1])\npar_1, par_2 = plot.get_param_array(sample, [par_1, par_2])\nax = plot.get_axes_for_params(par_1, par_2)\ndensity = plot.sample_analyser.get_density_grid(\nsample,\npar_1,\npar_2,\nconts=plot.settings.num_plot_contours,\nlikes=plot.settings.shade_meanlikes)\nlevels = sorted(np.append([density.P.max() + 1], level))\ncs = ax.contourf(\ndensity.x,\ndensity.y,\ndensity.P,\nlevels,\ncolors=\"#ffffff00\",\nalpha=0.1,\nextend=\"both\")\ncs.cmap.set_over(\"#ffffff00\")\ncs.cmap.set_under(\"gray\")\ncs.changed()\nlevels = sorted(np.append([density.P.max() + 1], level))\nax.contour(\ndensity.x,\ndensity.y,\ndensity.P,\nlevels=[level],\ncolors=\"grey\",\nlinewidths=0.5,\nalpha=1)\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.plot_hpi","title":"plot_hpi","text":"<pre><code>plot_hpi(plot, samples, hpi_points)\n</code></pre> <p>Add the highest posterior interval (HPI) to an existing plot.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>TrianglePlot instance</code> <p>The plot to which the HPI should be added.</p> required <code>samples</code> <code>list of MCSamples</code> <p>A list of instances of the MCSamples class, each containing  multivariate Monte Carlo samples on which the function is operating.</p> required <code>hpi_points</code> <code>list of array</code> <p>A list of arrays representing the HPI for each sample. Each array  should contain the parameter name and corresponding HPI.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>def plot_hpi(plot, samples, hpi_points):\n\"\"\"\n    Add the highest posterior interval (HPI) to an existing plot.\n    Parameters\n    ----------\n    plot : TrianglePlot instance\n        The plot to which the HPI should be added.\n    samples : list of MCSamples\n        A list of instances of the MCSamples class, each containing \n        multivariate Monte Carlo samples on which the function is operating.\n    hpi_points : list of array\n        A list of arrays representing the HPI for each sample. Each array \n        should contain the parameter name and corresponding HPI.\n    Returns\n    -------\n    None\n    \"\"\"\nlw=0.6\nfor idx, sample in enumerate(samples):\nhpi = hpi_points[idx]\nfor x in hpi:\nfor level in x[1]:\npar = x[0]\nx1 = level[0]\nx2 = level[1]\ndensity = MCSamples.get1DDensity(sample, par)\nif len(hpi) == 1:\nf = plt.gcf()\nax = f.get_axes()[0]\nelse:\nax = plot.get_axes_for_params(par)\nif x1:\np1 = density(x1)[0]\nax.plot([x1, x1], [0, p1], ls = 'dashed', color = colors[idx], lw=lw)\nif x2:\np2 = density(x2)[0]\nax.plot([x2, x2], [0, p2], ls = 'dashed', color = colors[idx], lw=lw)\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.print_stats","title":"print_stats","text":"<pre><code>print_stats(\nk_levels, hpi_points, bayes_est, max_pos, levels\n)\n</code></pre> <p>Print the statistical summary for each sample.</p> <p>Parameters:</p> Name Type Description Default <code>k_levels</code> <code>list of array</code> <p>A list of arrays representing the K-ratio bounds for each sample. Each array  should contain the parameter name and corresponding K-ratio bound.</p> required <code>hpi_points</code> <code>list of array</code> <p>A list of arrays representing the highest posterior interval (HPI) for each sample.  Each array should contain the parameter name and corresponding HPI.</p> required <code>bayes_est</code> <code>list of dict</code> <p>A list of dictionaries, each containing the Bayes estimator for each parameter in the sample.</p> required <code>max_pos</code> <code>list of dict</code> <p>A list of dictionaries, each containing the maximum posterior value for each parameter in the sample.</p> required <code>levels</code> <code>list of float</code> <p>The list of confidence levels for which the HPI should be computed. Each value  in the list should be between 0 and 1.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>def print_stats(k_levels, hpi_points, bayes_est, max_pos, levels):\n\"\"\"\n    Print the statistical summary for each sample.\n    Parameters\n    ----------\n    k_levels : list of array\n        A list of arrays representing the K-ratio bounds for each sample. Each array \n        should contain the parameter name and corresponding K-ratio bound.\n    hpi_points : list of array\n        A list of arrays representing the highest posterior interval (HPI) for each sample. \n        Each array should contain the parameter name and corresponding HPI.\n    bayes_est : list of dict\n        A list of dictionaries, each containing the Bayes estimator for each parameter in the sample.\n    max_pos : list of dict\n        A list of dictionaries, each containing the maximum posterior value for each parameter in the sample.\n    levels : list of float\n        The list of confidence levels for which the HPI should be computed. Each value \n        in the list should be between 0 and 1.\n    Returns\n    -------\n    None\n    \"\"\"\nfor idx in np.arange(len(k_levels)):\nprint(f'----- Stats for sample #{idx}-----')\nif k_levels[idx] and any(x != [] for x in k_levels[idx]):\nk_level = k_levels[idx][0]\nfor par, level in k_level:\nif level:\nprint(f'k-ratio limit = is reached for {par} = {level}')\nelse:\nprint(f'k-ratio limit is not reached for {par}')\nelse:\nprint(f'No 1D k-bounds available for this sample\\n')\nhpi = hpi_points[idx]\nfor x in hpi:\nfor idy, level in enumerate(x[1]):\npar = x[0]\nx1 = level[0]\nx2 = level[1]\nif x1:\nprint(f'Lower {100*levels[idy]}%-HPDI limit is reached for {par} = {10**x1}')\nelse:\nprint(f'Lower {100*levels[idy]}%-HPDI limit is reached for {par} does not exist')\nif x2:\nprint(f'Upper {100*levels[idy]}%-HPDI limit is reached for {par} = {10**x2}')\nelse:\nprint(f'Upper {100*levels[idy]}%-HPDI limit is reached for {par} does not exist')\nfor par, val in bayes_est[idx].items():\nprint(f'The Bayes estimator for {par} is {val[0]} +- {val[1]}')\nfor par, val in max_pos[idx].items():\nprint(f'The maximum posterior value for {par} is {val}')\nprint('\\n')\nreturn\n</code></pre>"},{"location":"reference/ptarcade/plotting_utils/#ptarcade.plotting_utils.plot_posteriors","title":"plot_posteriors","text":"<pre><code>plot_posteriors(\nchains,\nparams,\npar_to_plot=None,\npar_names=None,\nmodel_id=None,\nsamples_name=None,\nhpi_levels=[0.68, 0.95],\nk_ratio=None,\nbf=None,\nranges={},\nlevels=None,\nbhb_prior=False,\none_column=False,\nfig_width_pt=None,\nlabelsize=8,\nlegend_size=12,\nverbose=False,\nsave=False,\nmodel_name=None,\n)\n</code></pre> <p>Plot posterior distributions for the chosen parameters in the chains.</p> <p>Parameters:</p> Name Type Description Default <code>chains</code> <code>list of lists</code> <p>Contains all the chains to be plotted.</p> required <code>params</code> <code>list of lists</code> <p>Contains the name of the parameters appearing in the chains.</p> required <code>par_to_plot</code> <code>list of lists, optional</code> <p>Contains the parameter to plot from each chain.</p> <code>None</code> <code>par_names</code> <code>lists of list, optional</code> <p>Contains the LaTeX formatted names for the plotted parameters of each model. If not specified the name in the par files will be used.</p> <code>None</code> <code>model_id</code> <code>list of int, optional</code> <p>Assuming that the data are generated using hypermodels, specifies the model for  which to plot the posteriors (default is None and in this case nmodel is taken to be 0).</p> <code>None</code> <code>samples_name</code> <code>list of strings, optional</code> <p>Contains the name of the models associated to each chain, and it's used to create the legend. If not specified, the labels in the legend will be Sample 1, Sample 2, etc.</p> <code>None</code> <code>hpi_levels</code> <code>list of float, optional</code> <p>The list of confidence levels for which the highest posterior interval (HPI)  should be computed. Each value in the list should be between 0 and 1.</p> <code>[0.68, 0.95]</code> <code>k_ratio</code> <code>list of float, optional</code> <p>The list of K-ratio bounds for each chain. Each value in the list should be between 0 and 1.</p> <code>None</code> <code>bf</code> <code>list of float, optional</code> <p>Bayes factor for each chain, used to calculate K-ratio bounds.</p> <code>None</code> <code>ranges</code> <code>dict, optional</code> <p>The parameter ranges to display on the plot. Keys should be parameter names, and values should be tuples  or lists specifying the lower and upper bounds of the range.</p> <code>{}</code> <code>levels</code> <code>list of float, optional</code> <p>The list of confidence levels for which the contour should be computed. Each value  in the list should be between 0 and 1.</p> <code>None</code> <code>bhb_prior</code> <code>string, optional</code> <p>String indicating the bhb prior to plot (possible choiches are NG15 and IPTA2.</p> <code>False</code> <code>one_column</code> <code>bool, optional</code> <p>Whether to display the plot in one column format.</p> <code>False</code> <code>fig_width_pt</code> <code>float, optional</code> <p>The width of the figure in points.</p> <code>None</code> <code>labelsize</code> <code>float, optional</code> <p>The fontsize for the labels on the plot.</p> <code>8</code> <code>labelsize</code> <code>float, optional</code> <p>The fontsize for the labels on the plot.</p> <code>8</code> <code>verbose</code> <code>bool, optional</code> <p>If set to True, the function will print statistical summaries of the data.</p> <code>False</code> <code>save</code> <code>bool, optional</code> <p>If set to True, the function will save the plot to a PDF file.</p> <code>False</code> <code>model_name</code> <code>str, optional</code> <p>Model name used to name the output files. If not specified the plot will be saved as 'corner.pdf'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>matplotlib.figure.Figure</code> <p>The figure containing the plot.</p> <code>axs</code> <code>list of matplotlib.axes.Axes</code> <p>The axes of the figure.</p> Source code in <code>src/ptarcade/plotting_utils.py</code> <pre><code>def plot_posteriors(\nchains,\nparams,\npar_to_plot=None,\npar_names=None,\nmodel_id=None,\nsamples_name=None,\nhpi_levels=[0.68, 0.95],\nk_ratio=None,\nbf=None,\nranges={},\nlevels=None,\nbhb_prior=False,\none_column=False,\nfig_width_pt=None,\nlabelsize=8,\nlegend_size=12,\nverbose=False,\nsave=False,\nmodel_name=None):\n\"\"\"\n    Plot posterior distributions for the chosen parameters in the chains.\n    Parameters\n    ----------\n    chains : list of lists\n        Contains all the chains to be plotted.\n    params : list of lists\n        Contains the name of the parameters appearing in the chains.\n    par_to_plot : list of lists, optional\n        Contains the parameter to plot from each chain.\n    par_names : lists of list, optional\n        Contains the LaTeX formatted names for the plotted parameters of each model.\n        If not specified the name in the par files will be used.\n    model_id : list of int, optional\n        Assuming that the data are generated using hypermodels, specifies the model for \n        which to plot the posteriors (default is None and in this case nmodel is taken to be 0).\n    samples_name : list of strings, optional\n        Contains the name of the models associated to each chain, and it's used to\n        create the legend. If not specified, the labels in the legend will be Sample 1, Sample 2, etc.\n    hpi_levels : list of float, optional\n        The list of confidence levels for which the highest posterior interval (HPI) \n        should be computed. Each value in the list should be between 0 and 1.\n    k_ratio : list of float, optional\n        The list of K-ratio bounds for each chain. Each value in the list should be between 0 and 1.\n    bf : list of float, optional\n        Bayes factor for each chain, used to calculate K-ratio bounds.\n    ranges : dict, optional\n        The parameter ranges to display on the plot. Keys should be parameter names, and values should be tuples \n        or lists specifying the lower and upper bounds of the range.\n    levels : list of float, optional\n        The list of confidence levels for which the contour should be computed. Each value \n        in the list should be between 0 and 1.\n    bhb_prior : string, optional\n        String indicating the bhb prior to plot (possible choiches are NG15 and IPTA2.\n    one_column : bool, optional\n        Whether to display the plot in one column format.\n    fig_width_pt : float, optional\n        The width of the figure in points.\n    labelsize : float, optional\n        The fontsize for the labels on the plot.\n    labelsize : float, optional\n        The fontsize for the labels on the plot.\n    verbose : bool, optional\n        If set to True, the function will print statistical summaries of the data.\n    save : bool, optional\n        If set to True, the function will save the plot to a PDF file.\n    model_name : str, optional\n        Model name used to name the output files. If not specified the plot will be\n        saved as 'corner.pdf'.\n    Returns\n    -------\n    fig : matplotlib.figure.Figure\n        The figure containing the plot.\n    axs : list of matplotlib.axes.Axes\n        The axes of the figure.\n    \"\"\"\nplt.rcParams.update(plt_params)\nN_chains = len(chains)\npriors = params\nparams = [np.array(list(par.keys())) for par in params]\nif par_to_plot is None:\npar_to_plot = [None] * N_chains\nif model_id is None:\nmodel_id = [None] * N_chains\nif k_ratio is None:\nk_ratio = [None] * N_chains\nif bf is None:\nbf = [\nutils.compute_bf(chain, params[idx])[0] for idx, chain in enumerate(chains)]\nif not samples_name:\nsamples_name = [f\"Sample {idx+1}\" for idx in range(N_chains)]\nsamples = []\npar_union = []\nk_levels = [[]] * N_chains\nhpi_points = [[]] * N_chains\nbayes_est = [[]] * N_chains\nmax_pos = [[]] * N_chains\nfor idx, chain in enumerate(chains):\nfiltered = utils.chain_filter(\nchain, params[idx], model_id[idx], par_to_plot[idx]\n)\nfiltered_priors = {\nk.replace(\"_\", \"-\"): v\nfor k, v in priors[idx].items()\nif k.replace(\"_\", \"-\") in filtered[1] and v is not None\n}\nsamples.append(\nMCSamples(\nsamples=filtered[0],\nnames=filtered[1],\nranges=filtered_priors,\nignore_rows=1,\n)\n)\nif k_ratio[idx] and bf[idx]:\nk_levels[idx] = utils.get_k_levels(\nsample=samples[-1],\npars=filtered[1],\npriors=filtered_priors,\nbf=bf[idx],\nk_ratio=k_ratio[idx])\nelse:\nk_levels[idx] = None\nif hpi_levels:\nhpi_points[idx] = utils.get_c_levels(\nsample=samples[-1], pars=filtered[1], levels=hpi_levels)\nif verbose:\nbayes_est[idx] = utils.get_bayes_est(samples[-1], filtered[1])\nmax_pos[idx] = utils.get_max_pos(\nfiltered[1], bayes_est[idx], samples[-1], filtered_priors)\npar_union += [par for par in filtered[1] if par not in par_union]\nif len(par_union) &gt; 1:\nif not levels:\nlevels = [0.68, 0.95]\nsets = corner_plot_settings(levels, samples, one_column, legend_size, fig_width_pt)\ng = plots.get_subplot_plotter(settings=sets)\ng.triangle_plot(\nsamples,\nfilled=True,\nparams=par_union,\nlegend_labels=samples_name,\nsharey=True,\ndiag1d_kwargs={\"normalized\": True},\nparam_limits=ranges)\nif bhb_prior:\nplot_bhb_prior(g, bhb_prior, levels)\nelif len(par_union) == 1:\nsets = oned_plot_settings()\nif fig_width_pt:\nsize = set_size(fig_width_pt, ratio=1)[0]\nelif one_column:\nsize = set_size(246, ratio=1)[0]\nelse:\nsize = set_size(510, ratio=1)[0]\ng = plots.get_single_plotter(settings=sets, ratio=1, width_inch=size)\ng.plot_1d(samples, par_union[0], normalized=True)\ng.add_legend(samples_name, legend_loc=\"best\")\nif any(k_ratio):\nplot_k_bounds(g, samples, k_levels)\nif hpi_levels:\nplot_hpi(g, samples, hpi_points)\nif par_names is None:\npar_names_union = par_union\nelse:\npar_names_union = []\nfor names in par_names:\npar_names_union += [name for name in names if name not in par_names_union]\ncreate_ax_labels(par_names_union, labelsize=labelsize)\ng.fig.align_labels()\nif save and model_name:\nplt.savefig(f\"./plots/{model_name}_posteriors.pdf\", bbox_inches=\"tight\")\nelif save:\nplt.savefig(\"./plots/posteriors.pdf\", bbox_inches=\"tight\")\nif verbose:\nprint_stats(k_levels, hpi_points, bayes_est, max_pos, hpi_levels)\nf = plt.gcf()\naxs = f.get_axes()\nreturn f, axs\n</code></pre>"},{"location":"reference/ptarcade/pta_importer/","title":"pta_importer","text":""},{"location":"reference/ptarcade/pta_importer/#ptarcade.pta_importer-functions","title":"Functions","text":""},{"location":"reference/ptarcade/pta_importer/#ptarcade.pta_importer.get_ephem_conv","title":"get_ephem_conv","text":"<pre><code>get_ephem_conv(par_file)\n</code></pre> <p>get the ephemeris convention used in par files.</p> Source code in <code>src/ptarcade/pta_importer.py</code> <pre><code>def get_ephem_conv(par_file):\n\"\"\"\n    get the ephemeris convention used in par files.\n    \"\"\"\nf = open(par_file, 'r')\nlines = f.readlines()\nfor line in lines:\nline = line.split()\nif line[0] == 'EPHEM':\nephem = line[-1]\nf.close()\nreturn ephem\n</code></pre>"},{"location":"reference/ptarcade/pta_importer/#ptarcade.pta_importer.get_pulsars","title":"get_pulsars","text":"<pre><code>get_pulsars(pta_data, filter = None)\n</code></pre> Source code in <code>src/ptarcade/pta_importer.py</code> <pre><code>def get_pulsars(pta_data, filter=None):\nif os.path.isfile(pta_data):\nwith open(pta_data, 'rb') as handle:\npsrs = pickle.load(handle)\nreturn psrs\nelif os.path.isdir(pta_data):\nparfiles = sorted(glob.glob(os.path.join(pta_data, '*.par')))\ntimfiles = sorted(glob.glob(os.path.join(pta_data, '*.tim')))\n# filter\nif filter is not None:\nparfiles = [x for x in parfiles if x.split('/')[-1].split('.')[0] in filter]\ntimfiles = [x for x in timfiles if x.split('/')[-1].split('.')[0] in filter]\n# TODO Need to check that all tim and par files have matches!\n# load the pulsars into enterprise \npsrs = []\nfor p, t in zip(parfiles, timfiles):\nephemeris = get_ephem_conv(p)\npsr = Pulsar(p, t, ephem=ephemeris)\npsrs.append(psr)\nreturn psrs\n</code></pre>"},{"location":"reference/ptarcade/pta_importer/#ptarcade.pta_importer.get_wn","title":"get_wn","text":"<pre><code>get_wn(wn_data)\n</code></pre> Source code in <code>src/ptarcade/pta_importer.py</code> <pre><code>def get_wn(wn_data):\nif wn_data is None:\nreturn None\nparams = {}\nif os.path.isfile(wn_data):\nwith open(wn_data, 'r') as fp:\nparams.update(json.load(fp))\nreturn params\nelif os.path.isdir(wn_data):\nfor filename in os.listdir(wn_data):\nwith open(os.path.join(wn_data, filename), 'r') as f:\ndata = json.load(f)\nfor key, value in data.items():\nparams.update({key: value})\nreturn params\n</code></pre>"},{"location":"reference/ptarcade/pta_importer/#ptarcade.pta_importer.pta_data_importer","title":"pta_data_importer","text":"<pre><code>pta_data_importer(pta_data)\n</code></pre> <p>Import pta pulsars objects, white noise parameters, and empirical distributions.</p> Source code in <code>src/ptarcade/pta_importer.py</code> <pre><code>def pta_data_importer(pta_data):\n\"\"\"\n    Import pta pulsars objects, white noise parameters, and empirical distributions.\n    \"\"\"\nif pta_data == 'NG15':\n# This returns a path in the astropy cache that points to these files, otherwise\n# it downloads them there and returns the path\nng15_dic = {\n'psrs_data': download_file('https://data.nanograv.org/ng15_psrs_v1p1.pkl', cache=True, pkgname='ptarcade'),\n'noise_data': download_file('https://data.nanograv.org/ng15_wn_v1p1.json', cache=True, pkgname='ptarcade'),\n'emp_dist': download_file('https://data.nanograv.org/ng15_emp_v1p1.pkl', cache=True, pkgname='ptarcade')}\npsrs = get_pulsars(ng15_dic['psrs_data'])\nparams = get_wn(ng15_dic['noise_data'])\nemp_dist = ng15_dic['emp_dist']\nelif pta_data == 'NG12':\nng12_dic = {\n'psrs_data': download_file('https://data.nanograv.org/ng12_psrs_v4.pkl', cache=True, pkgname='ptarcade'),\n'noise_data': download_file('https://data.nanograv.org/ng12_wn_v4.json', cache=True, pkgname='ptarcade'),\n'emp_dist': None}\npsrs = get_pulsars(ng12_dic['psrs_data'])\nparams = get_wn(ng12_dic['noise_data'])\nemp_dist = ng12_dic['emp_dist']\nelif pta_data == 'IPTA2':\nipta2_dic = {\n'psrs_data': download_file('https://data.nanograv.org/ipta2_psrs_de438.pkl', cache=True, pkgname='ptarcade'),\n'noise_data': download_file('https://data.nanograv.org/ipta2_wn_de438.json', cache=True, pkgname='ptarcade'),\n'emp_dist': None}\npsrs = get_pulsars(ipta2_dic['psrs_data'])\nparams = get_wn(ipta2_dic['noise_data'])\nemp_dist = ipta2_dic['emp_dist']\nelse:\npsrs = get_pulsars(pta_data['psrs_data'])\nparams = get_wn(pta_data['noise_data'])\nemp_dist = pta_data['emp_dist']\nreturn psrs, params, emp_dist\n</code></pre>"},{"location":"reference/ptarcade/sampler/","title":"sampler","text":""},{"location":"reference/ptarcade/sampler/#ptarcade.sampler-functions","title":"Functions","text":""},{"location":"reference/ptarcade/sampler/#ptarcade.sampler.cpu_model","title":"cpu_model","text":"<pre><code>cpu_model()\n</code></pre> Source code in <code>src/ptarcade/sampler.py</code> <pre><code>def cpu_model():\nreturn \"unknown CPU (for better info install py-cpuinfo)\"\n</code></pre>"},{"location":"reference/ptarcade/sampler/#ptarcade.sampler.main","title":"main","text":"<pre><code>main()\n</code></pre> Source code in <code>src/ptarcade/sampler.py</code> <pre><code>def main():\nprint('\\n--- Starting to run ---\\n')\nprint(\"\\tNode\", platform.node(), cpu_model(),\"\\n\");\nstart_cpu = time.process_time()\nstart_real = time.perf_counter()\n###############################################################################\n# load inputs\n###############################################################################\n# parse command line inputs\ninput_options, cmd_input_okay = input_handler.get_cmdline_arguments()\nif not cmd_input_okay:\nprint('ERROR:')\nprint(\"\\t- Model and configuration files must be present\\n\"+\n\"\\t- These are added with the -m, -c input flags. Add -h (--help) flags for more help.\")\nsys.exit()\ninputs = input_handler.load_inputs(input_options)\ninput_handler.check_config(inputs['config'])\n###############################################################################\n# load pulsars and noise parameters\n###############################################################################\nprint('--- Loading Pulsars and noise data ... ---\\n')\n# import pta data\npsrs, noise_params, emp_dist = pta_importer.pta_data_importer(inputs['config'].pta_data)\nprint(f\"\\tloaded {len(psrs)} pulsars\\n\")\ninput_handler.check_model(\nmodel=inputs['model'],\npsrs=psrs,\nred_components=inputs['config'].red_components,\ngwb_components=inputs['config'].gwb_components)\nprint('--- Done loading Pulsars and noise data. ---\\n')\n###############################################################################\n# define models and initialize PTA\n###############################################################################\nprint('--- Initializing PTA ... ---\\n')\npta = {}\npta[0] = signal_builder.builder(\npsrs=psrs,\nmodel=inputs['model'],\nnoisedict=noise_params,\npta_dataset=inputs['config'].pta_data,\nbhb_th_prior=inputs['config'].bhb_th_prior,\ngamma_bhb=inputs['config'].gamma_bhb,\nA_bhb_logmin=inputs['config'].A_bhb_logmin,\nA_bhb_logmax=inputs['config'].A_bhb_logmax,\ncorr=inputs['config'].corr,\nred_components=inputs[\"config\"].red_components,\ngwb_components=inputs[\"config\"].gwb_components)\nif inputs[\"config\"].mod_sel:\npta[1] = pta[0]\npta[0] = signal_builder.builder(\npsrs=psrs,\nmodel=None,\nnoisedict=noise_params,\npta_dataset=inputs['config'].pta_data,\nbhb_th_prior=inputs['config'].bhb_th_prior,\ngamma_bhb=inputs['config'].gamma_bhb,\nA_bhb_logmin=inputs['config'].A_bhb_logmin,\nA_bhb_logmax=inputs['config'].A_bhb_logmax,\ncorr=inputs['config'].corr,\nred_components=inputs[\"config\"].red_components,\ngwb_components=inputs[\"config\"].gwb_components)\nprint('--- Done initializing PTA. ---\\n\\n')\n###############################################################################\n# define sampler and sample\n###############################################################################\nout_dir = os.path.join(\ninputs[\"config\"].out_dir, inputs[\"model\"].name, f'chain_{input_options[\"n\"]}')\nsuper_model = hypermodel.HyperModel(pta)\ngroups = signal_builder.unique_sampling_groups(super_model)\nif inputs[\"model\"].group:\nidx_params = [super_model.param_names.index(pp) for pp in inputs[\"model\"].group]\n[groups.append(idx_params) for _ in range(5)]\n# add nmodel index to group structure\ngroups.extend([[len(super_model.param_names)-1]])\nsampler = super_model.setup_sampler(\nresume=inputs[\"config\"].resume,\noutdir=out_dir,\nsample_nmodel=inputs[\"config\"].mod_sel,\ngroups=groups,\nempirical_distr=emp_dist)\nx0 = super_model.initial_sample()\nsuper_model.get_lnlikelihood(x0) # Cache now to make timing more accurate\nprint(\"Setup times (including first sample) {:.2f} seconds real, {:.2f} seconds CPU\\n\".format(\ntime.perf_counter()-start_real, time.process_time()-start_cpu));\nstart_cpu = time.process_time()\nstart_real = time.perf_counter()\nN_samples = inputs[\"config\"].N_samples\nprint(f'--- Starting to sample {N_samples} samples... ---\\n')\nsampler.sample(\nx0,\nN_samples,\nSCAMweight=inputs['config'].scam_weight,\nAMweight=inputs['config'].am_weight,\nDEweight=inputs['config'].de_weight)\nprint('--- Done sampling. ---')\nreal_time = time.perf_counter()-start_real\ncpu_time = time.process_time()-start_cpu\nprint(\"Sampling times {:.2f} seconds real =  {:.4f} s/sample, {:.2f} seconds CPU =  {:.4f} s/sample\\n\".format(\nreal_time, real_time/N_samples, cpu_time, cpu_time/N_samples))\n</code></pre>"},{"location":"reference/ptarcade/signal_builder/","title":"signal_builder","text":""},{"location":"reference/ptarcade/signal_builder/#ptarcade.signal_builder-functions","title":"Functions","text":""},{"location":"reference/ptarcade/signal_builder/#ptarcade.signal_builder.unique_sampling_groups","title":"unique_sampling_groups","text":"<pre><code>unique_sampling_groups(super_model)\n</code></pre> <p>Fixes the hypermodel group structure</p> Source code in <code>src/ptarcade/signal_builder.py</code> <pre><code>def unique_sampling_groups(super_model):\n\"\"\"\n    Fixes the hypermodel group structure\n    \"\"\"\nunique_groups = []\nfor p in super_model.models.values():\ngroups = get_parameter_groups(p)\nfor group in groups:\ncheck_group = []\nfor idx in group:\nparam_name = p.param_names[idx]\ncheck_group.append(super_model.param_names.index(param_name))\nif check_group not in unique_groups:\nunique_groups.append(check_group)\nreturn unique_groups\n</code></pre>"},{"location":"reference/ptarcade/signal_builder/#ptarcade.signal_builder.powerlaw2","title":"powerlaw2","text":"<pre><code>powerlaw2(f, log10_Agamma, components = 2)\n</code></pre> <p>Defines a modified  powerlaw function that takes as input an array containing the values of the amplitude and spectral index.</p> Source code in <code>src/ptarcade/signal_builder.py</code> <pre><code>@parameter.function\ndef powerlaw2(f, log10_Agamma, components=2):\n\"\"\"\n    Defines a modified  powerlaw function that takes as input an\n    array containing the values of the amplitude and spectral index.\n    \"\"\"\ndf = np.diff(np.concatenate((np.array([0]), f[::components])))\nreturn (\n(10 ** log10_Agamma[0]) ** 2\n/ 12.0\n/ np.pi**2\n* const.fyr ** (log10_Agamma[1] - 3)\n* f ** (-log10_Agamma[1])\n* np.repeat(df, components)\n)\n</code></pre>"},{"location":"reference/ptarcade/signal_builder/#ptarcade.signal_builder.tnequad_conv","title":"tnequad_conv","text":"<pre><code>tnequad_conv(noisedict)\n</code></pre> <p>Checks if the TempoNest definition of equad is used in  the white noise dictionary.</p> Source code in <code>src/ptarcade/signal_builder.py</code> <pre><code>def tnequad_conv(noisedict):\n\"\"\"\n    Checks if the TempoNest definition of equad is used in \n    the white noise dictionary. \n    \"\"\"\nt2equad = False\ntnequad = False\nfor x in noisedict:\nif 'tnequad' in x:\ntnequad = True\nelif 't2equad' in x:\nt2equad = True\nif t2equad and tnequad:\nsys.exit('ERROR: The convention for equad is not consistent across the PTA data.')\nreturn tnequad\n</code></pre>"},{"location":"reference/ptarcade/signal_builder/#ptarcade.signal_builder.builder","title":"builder","text":"<pre><code>builder(\npsrs,\nmodel=None,\nnoisedict=None,\npta_dataset=None,\nbhb_th_prior=False,\ngamma_bhb=None,\nA_bhb_logmin=None,\nA_bhb_logmax=None,\ncorr=False,\nred_components=30,\ngwb_components=14,\n)\n</code></pre> <p>Reads in list of enterprise Pulsar instances and returns a PTA object instantiated with user-supplied options. :param model: object containing the parameters of the exotic     signal.      [default = None] :param noisedict: Dictionary of pulsar noise properties.     [default = None] :param bhb_th_prior: if set to True the prior for the bhb signal will be      derived by fitting a 2D Gaussian to the distribution of A and gamma      in the holodeck library astro-02-gw     [default = False] :param gamma_bhb: fixed common bhb process spectral index value. If set to     None we vary the spectral index over the range [0, 7].     [default = None] :param A_bhb_logmin: specifies lower prior on the log amplitude of the bhb     common process. If set to None, -18 is used.     [default = None]  :param A_bhb_logmax: specifies upper prior on the log amplitude of the bhb     common process. If set to None, -14 is used if gamma_bhb = 13/3, -11 is     used otherwise.     [default = None] :param corr: if set to True HD correlations are assumed for GWBs     [default = False] :red_components: number of frequency components for the intrinsic     red noise.      [default = 30] :gwb_components: number of frequency components for the common processes.     [default = 14]</p> Source code in <code>src/ptarcade/signal_builder.py</code> <pre><code>def builder(\npsrs, \nmodel=None, \nnoisedict=None, \npta_dataset=None,\nbhb_th_prior=False,\ngamma_bhb=None, \nA_bhb_logmin=None, \nA_bhb_logmax=None,\ncorr=False, \nred_components=30, \ngwb_components=14):\n\"\"\"\n    Reads in list of enterprise Pulsar instances and returns a PTA\n    object instantiated with user-supplied options.\n    :param model: object containing the parameters of the exotic\n        signal. \n        [default = None]\n    :param noisedict: Dictionary of pulsar noise properties.\n        [default = None]\n    :param bhb_th_prior: if set to True the prior for the bhb signal will be \n        derived by fitting a 2D Gaussian to the distribution of A and gamma \n        in the holodeck library astro-02-gw\n        [default = False]\n    :param gamma_bhb: fixed common bhb process spectral index value. If set to\n        None we vary the spectral index over the range [0, 7].\n        [default = None]\n    :param A_bhb_logmin: specifies lower prior on the log amplitude of the bhb\n        common process. If set to None, -18 is used.\n        [default = None] \n    :param A_bhb_logmax: specifies upper prior on the log amplitude of the bhb\n        common process. If set to None, -14 is used if gamma_bhb = 13/3, -11 is\n        used otherwise.\n        [default = None]\n    :param corr: if set to True HD correlations are assumed for GWBs\n        [default = False]\n    :red_components: number of frequency components for the intrinsic\n        red noise. \n        [default = 30]\n    :gwb_components: number of frequency components for the common processes.\n        [default = 14]\n    \"\"\"\n# timing model\ntm = gp_signals.MarginalizingTimingModel(use_svd=True)\ns = tm\n# find the maximum time span to set the GW frequency sampling \nTspan = model_utils.get_tspan(psrs)\n# add pulsar intrinsic red noise \ns += red_noise_block(\npsd='powerlaw', \nprior='log-uniform', \nTspan=Tspan,\ncomponents=red_components)\n# add common red noise\nif model is None or model.smbhb:\nif corr:\norf = 'hd'\nelse:\norf = None\nif bhb_th_prior and (pta_dataset=='NG15' or pta_dataset=='IPTA2'):\n# gaussian parameters extracted from the holodeck library astro-02-gw\nif pta_dataset == 'NG15':\nmu = np.array([-15.61492963, 4.70709637])\nsigma = np.array([[0.27871359, -0.00263617], [-0.00263617, 0.12415383]])\nelif pta_dataset == 'IPTA2':\nmu = np.array([-15.02928454, 4.14290127])\nsigma = np.array([[0.06869369, 0.00017051], [0.00017051, 0.04681747]])\nif model is None:\nlog10_Agamma_gw = parameter.Normal(mu=mu, sigma=sigma , size=2)('gw_bhb')\nelif model.smbhb:\nlog10_Agamma_gw = parameter.Normal(mu=mu, sigma=sigma , size=2)('gw_bhb_np')\npowerlaw_gw = powerlaw2(log10_Agamma=log10_Agamma_gw)\nif orf == 'hd':\ns += gp_signals.FourierBasisCommonGP(\nspectrum=powerlaw_gw,\norf=utils.hd_orf(),\ncomponents=gwb_components,\nTspan=Tspan,\nname='gw_bhb')\nelse:\ns += gp_signals.FourierBasisGP(\nspectrum=powerlaw_gw,\ncomponents=gwb_components,\nTspan=Tspan,\nname='gw_bhb')\nelif bhb_th_prior and pta_dataset!='NG15' and pta_dataset!='IPTA2':\nprint('WARNING: Theory motivated priors for the SMBHB singal parameters are available only for NG15 and IPTA2. Reverting back to log uniform prior for A and uniform prior for gamma.\\n')\ns += common_red_noise_block(\npsd='powerlaw', \nprior='log-uniform', \nTspan=Tspan, \ncomponents=gwb_components,\norf=orf, \nname = 'gw_bhb')\nelse:\ns += common_red_noise_block(\npsd='powerlaw', \nprior='log-uniform', \nTspan=Tspan, \ncomponents=gwb_components,\ngamma_val=gamma_bhb, \norf=orf, \nname = 'gw_bhb',\nlogmin=A_bhb_logmin, \nlogmax=A_bhb_logmax)\n# add DM variations \ndm_var = [hasattr(psr, 'dmx') for psr in psrs] # check if dmx parameters are present in pulsars objects\nif all(dm_var):\npass\nelif not any(dm_var):\ns += dm_noise_block(\ngp_kernel='diag', \npsd='powerlaw',\nprior='log-uniform',\ncomponents=30, \ngamma_val=None)\nelse:\nsys.exit('ERROR: The convention for DM variation is not consistent across the PTA data.')\n# add new-physics signal\nif model:\nif hasattr(model, \"signal\"):\nsignal = function(model.signal)\nsignal = signal(**model.parameters)\nnp_signal = deterministic_signals.Deterministic(signal, name=model.name)\ns += np_signal\nelif hasattr(model, \"spectrum\"):\nspectrum = aux.omega2cross(model.spectrum)\ncpl_np = spectrum(**model.parameters)\nif corr:\norf = utils.hd_orf()\nnp_gwb = gp_signals.FourierBasisCommonGP(\nspectrum=cpl_np, \norf=orf, \ncomponents=gwb_components, \nTspan=Tspan,\nname=model.name)\nelse:\nnp_gwb = gp_signals.FourierBasisGP(\nspectrum=cpl_np, \ncomponents=gwb_components,\nTspan=Tspan, \nname=model.name)\ns += np_gwb\n# add white-noise, and act on psr objects \nmodels = []\nif noisedict is None:\nwhite_vary = True\ntnequad = False\nelse:\nwhite_vary = False\ntnequad = tnequad_conv(noisedict)\nfor p in psrs:\nif 'NANOGrav' in p.flags['pta']:\ns2 = s + white_noise_block(\nvary=white_vary, inc_ecorr=True, tnequad=tnequad, select='backend')\nif '1713' in p.name and not any(dm_var):\ns3 = s2 + chrom.dm_exponential_dip(\ntmin=54500, tmax=55000, idx=2, sign=False, name='dmexp_1')\nif p.toas.max() / const.day &gt; 57850:\ns3 += chrom.dm_exponential_dip(\ntmin=57300, tmax=57850, idx=2, sign=False, name='dmexp_2')\nmodels.append(s3(p))\nelse:\nmodels.append(s2(p))\nelse:\ns4 = s + white_noise_block(\nvary=white_vary, inc_ecorr=False, tnequad=tnequad, select='backend')\nif '1713' in p.name and not any(dm_var):\ns5 = s4 + chrom.dm_exponential_dip(\ntmin=54500, tmax=55000, idx=2, sign=False, name='dmexp_1')\nif p.toas.max() / const.day &gt; 57850:\ns5 += chrom.dm_exponential_dip(\ntmin=57300, tmax=57850, idx=2, sign=False, name='dmexp_2')\nmodels.append(s5(p))\nelse:\nmodels.append(s4(p))\n# set up PTA\npta = signal_base.PTA(models)\n# set white noise parameters\nif noisedict is not None:\npta.set_default_params(noisedict)\nreturn pta\n</code></pre>"},{"location":"reference/ptarcade/data/__init__/","title":"init","text":""},{"location":"reference/ptarcade/data/full_run/","title":"full_run","text":"<p>Example NumPy style docstrings.</p> <p>This module demonstrates documentation as specified by the <code>NumPy Documentation HOWTO</code>_. Docstrings may extend over multiple lines. Sections are created with a section header followed by an underline of equal length.</p>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run--example","title":"Example","text":"<p>Examples can be given using either the <code>Example</code> or <code>Examples</code> sections. Sections support any reStructuredText formatting, including literal blocks::</p> <pre><code>$ python example_numpy.py\n</code></pre> <p>Section breaks are created with two blank lines. Section breaks are also implicitly created anytime a new section starts. Section bodies may be indented:</p>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run--notes","title":"Notes","text":"<pre><code>This is an example of an indented section. It's like any other section,\nbut the body is indented to help it stand out from surrounding text.\n</code></pre> <p>If a section is indented, then a section break is created by resuming unindented text.</p> <p>Attributes:</p> Name Type Description <code>module_level_variable1</code> <code>int</code> <p>Module level variables may be documented in either the <code>Attributes</code> section of the module docstring, or in an inline docstring immediately following the variable.</p> <p>Either form is acceptable, but the two should not be mixed. Choose one convention to document module level variables and be consistent with it.</p> <p>.. _NumPy Documentation HOWTO:    https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt</p>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run-attributes","title":"Attributes","text":""},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run.pta_data","title":"pta_data  <code>module-attribute</code>","text":"<pre><code>pta_data = 'NG15'\n</code></pre>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run.mod_sel","title":"mod_sel  <code>module-attribute</code>","text":"<pre><code>mod_sel = False\n</code></pre>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run.out_dir","title":"out_dir  <code>module-attribute</code>","text":"<pre><code>out_dir = './chains/'\n</code></pre>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run.resume","title":"resume  <code>module-attribute</code>","text":"<pre><code>resume = False\n</code></pre>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run.N_samples","title":"N_samples  <code>module-attribute</code>","text":"<pre><code>N_samples = int(2000000.0)\n</code></pre>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run.red_components","title":"red_components  <code>module-attribute</code>","text":"<pre><code>red_components = 30\n</code></pre>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run.corr","title":"corr  <code>module-attribute</code>","text":"<pre><code>corr = False\n</code></pre>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run.gwb_components","title":"gwb_components  <code>module-attribute</code>","text":"<pre><code>gwb_components = 14\n</code></pre>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run.bhb_th_prior","title":"bhb_th_prior  <code>module-attribute</code>","text":"<pre><code>bhb_th_prior = True\n</code></pre>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run.A_bhb_logmin","title":"A_bhb_logmin  <code>module-attribute</code>","text":"<pre><code>A_bhb_logmin = None\n</code></pre>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run.A_bhb_logmax","title":"A_bhb_logmax  <code>module-attribute</code>","text":"<pre><code>A_bhb_logmax = None\n</code></pre>"},{"location":"reference/ptarcade/data/full_run/#ptarcade.data.full_run.gamma_bhb","title":"gamma_bhb  <code>module-attribute</code>","text":"<pre><code>gamma_bhb = None\n</code></pre>"}]}